<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月29日</title>
    <link href="/2021/06/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8829%E6%97%A5/"/>
    <url>/2021/06/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1854. 人口最多的年份</p><span id="more"></span><h1 id="1854-人口最多的年份"><a href="#1854-人口最多的年份" class="headerlink" title="1854. 人口最多的年份"></a><a href="https://leetcode-cn.com/problems/maximum-population-year/">1854. 人口最多的年份</a></h1><p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birth, death]</code> 表示第 <code>i</code> 个人的出生和死亡年份。<br>年份 <code>x</code> 的 <strong>人口</strong> 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 <code>x</code> 的人口需要满足：<code>x</code> 在闭区间 <code>[birth, death - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。<br>返回 <strong>人口最多</strong> 且 <strong>最早</strong> 的年份。<br><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：logs = <span class="hljs-string">[[1993,1999],[2000,2010]]</span><br>输出：<span class="hljs-number">1993</span><br>解释：人口最多为 <span class="hljs-number">1</span> ，而 <span class="hljs-number">1993</span> 是人口为 <span class="hljs-number">1</span> 的最早年份。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：logs</span> <span class="hljs-string">=</span> [[<span class="hljs-number">1950</span>,<span class="hljs-number">1961</span>],[<span class="hljs-number">1960</span>,<span class="hljs-number">1971</span>],[<span class="hljs-number">1970</span>,<span class="hljs-number">1981</span>]]<br><span class="hljs-string">输出：1960</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">人口最多为</span> <span class="hljs-number">2</span> <span class="hljs-string">，分别出现在</span> <span class="hljs-number">1960</span> <span class="hljs-string">和</span> <span class="hljs-number">1970</span> <span class="hljs-string">。</span><br><span class="hljs-string">其中最早年份是</span> <span class="hljs-number">1960</span> <span class="hljs-string">。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= logs.length &lt;= 100</code></li><li><code>1950 &lt;= birth &lt; death &lt;= 2050</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>差分数组，先新建一个 102 个长度的数组填充 0。遍历 logs，每个出生年加一，死亡年减去一（表示当前年与上一年的区别）。再遍历一次，当前年加等于上一年的人数就为每一年存在的人口的数量。用一个 max 记录人口最多的数量，如果遍历时得到的人数比 max 来的大，就更新 max，因为返回最早的一年，所以要同时记录下标。最后返回下标加上 1950 的 offset。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">logs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximumPopulation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">logs</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">101</span>).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">let</span> max = -<span class="hljs-literal">Infinity</span>,<br>    res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> log <span class="hljs-keyword">of</span> logs) &#123;<br>    <span class="hljs-keyword">const</span> [birth, death] = log;<br>    arr[birth - <span class="hljs-number">1950</span>]++;<br>    arr[death - <span class="hljs-number">1950</span>]--;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    arr[i] += arr[i - <span class="hljs-number">1</span>] ? arr[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>      res = i;<br>      max = arr[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res + <span class="hljs-number">1950</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月28日</title>
    <link href="/2021/06/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/06/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt232. 用栈实现队列</p><span id="more"></span><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：<br>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p><strong>示例：</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">输入：<br>[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>]<br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用两个栈，一个入栈一个出栈，当出栈的栈为空时，把另外一个栈反序搬过来，出栈的排序方式就是符合队列的顺序了。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> MyQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.stack1 = [];<br>  <span class="hljs-built_in">this</span>.stack2 = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push element x to the back of queue.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.stack1.push(x);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element from in front of queue and returns that element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stack2.length) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.stack1.length) &#123;<br>      <span class="hljs-built_in">this</span>.stack2.push(<span class="hljs-built_in">this</span>.stack1.pop());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack2.pop();<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the front element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.peek = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stack2.length) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.stack1.length) &#123;<br>      <span class="hljs-built_in">this</span>.stack2.push(<span class="hljs-built_in">this</span>.stack1.pop());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack2[<span class="hljs-built_in">this</span>.stack2.length - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns whether the queue is empty.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.empty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.stack1.length &amp;&amp; !<span class="hljs-built_in">this</span>.stack2.length;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MyQueue()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * var param_2 = obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.peek()</span><br><span class="hljs-comment"> * var param_4 = obj.empty()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>队列</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月27日</title>
    <link href="/2021/06/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/06/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt933. 最近的请求次数</p><span id="more"></span><h1 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">933. 最近的请求次数</a></h1><p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。<br>请你实现 <code>RecentCounter</code> 类：</p><ul><li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li><li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li></ul><p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。<br><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;RecentCounter&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">100</span>], [<span class="hljs-number">3001</span>], [<span class="hljs-number">3002</span>]]<br>输出：<br>[null, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br>解释：<br><span class="hljs-symbol">RecentCounter</span> recentCounter = new <span class="hljs-symbol">RecentCounter</span>();<br>recentCounter.ping(<span class="hljs-number">1</span>);     // requests = [<span class="hljs-number">1</span>]，范围是 [<span class="hljs-number">-2999</span>,<span class="hljs-number">1</span>]，返回 <span class="hljs-number">1</span><br>recentCounter.ping(<span class="hljs-number">100</span>);   // requests = [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>]，范围是 [<span class="hljs-number">-2900</span>,<span class="hljs-number">100</span>]，返回 <span class="hljs-number">2</span><br>recentCounter.ping(<span class="hljs-number">3001</span>);  // requests = [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3001</span>]，范围是 [<span class="hljs-number">1</span>,<span class="hljs-number">3001</span>]，返回 <span class="hljs-number">3</span><br>recentCounter.ping(<span class="hljs-number">3002</span>);  // requests = [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3001</span>, <span class="hljs-number">3002</span>]，范围是 [<span class="hljs-number">2</span>,<span class="hljs-number">3002</span>]，返回 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= t &lt;= 10</code></li><li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li><li>至多调用 <code>ping</code> 方法 <code>10</code> 次</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次插入，计算出最小及最大的区间，遍历历史所有请求计算在区间内的请求个数即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> RecentCounter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.arr = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>RecentCounter.prototype.ping = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.arr.push(t);<br>  <span class="hljs-keyword">const</span> min = t - <span class="hljs-number">3000</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (b &gt;= min &amp;&amp; b &lt;= t) <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new RecentCounter()</span><br><span class="hljs-comment"> * var param_1 = obj.ping(t)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月26日</title>
    <link href="/2021/06/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/06/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1656. 设计有序流</p><span id="more"></span><h1 id="1656-设计有序流"><a href="#1656-设计有序流" class="headerlink" title="1656. 设计有序流"></a><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/">1656. 设计有序流</a></h1><p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。<br>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按 <code>id</code> 递增的顺序</strong> 返回一些值。<br>实现 <code>OrderedStream</code> 类：</p><ul><li><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</li><li><code>String[] insert(int id, String value)</code>向流中存储新的<code>(id, value)</code>对。存储后：<ul><li>如果流存储有 <code>id = ptr</code> 的 <code>(id, value)</code> 对，则找出从 <code>id = ptr</code> 开始的 <strong>最长 id 连续递增序列</strong> ，并 <strong>按顺序</strong> 返回与这些 id 关联的值的列表。然后，将 <code>ptr</code> 更新为最后那个   <code>id + 1</code> 。</li><li>否则，返回一个空列表。</li></ul></li></ul><p><strong>示例：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/gif/1639155/1624687940683-e0bc2426-e4e2-4c45-912d-6d206d6469d7.gif#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=682&size=0&status=done&style=none&width=682"></strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;OrderedStream&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ccccc&quot;</span>], [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaaaa&quot;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bbbbb&quot;</span>], [<span class="hljs-number">5</span>, <span class="hljs-string">&quot;eeeee&quot;</span>], [<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ddddd&quot;</span>]]<br>输出<br>[null, [], [<span class="hljs-string">&quot;aaaaa&quot;</span>], [<span class="hljs-string">&quot;bbbbb&quot;</span>, <span class="hljs-string">&quot;ccccc&quot;</span>], [], [<span class="hljs-string">&quot;ddddd&quot;</span>, <span class="hljs-string">&quot;eeeee&quot;</span>]]<br>解释<br><span class="hljs-symbol">OrderedStream</span> os= new <span class="hljs-symbol">OrderedStream</span>(<span class="hljs-number">5</span>);<br>os.insert(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ccccc&quot;</span>); // 插入 (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ccccc&quot;</span>)，返回 []<br>os.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaaaa&quot;</span>); // 插入 (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaaaa&quot;</span>)，返回 [<span class="hljs-string">&quot;aaaaa&quot;</span>]<br>os.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bbbbb&quot;</span>); // 插入 (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bbbbb&quot;</span>)，返回 [<span class="hljs-string">&quot;bbbbb&quot;</span>, <span class="hljs-string">&quot;ccccc&quot;</span>]<br>os.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;eeeee&quot;</span>); // 插入 (<span class="hljs-number">5</span>, <span class="hljs-string">&quot;eeeee&quot;</span>)，返回 []<br>os.insert(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ddddd&quot;</span>); // 插入 (<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ddddd&quot;</span>)，返回 [<span class="hljs-string">&quot;ddddd&quot;</span>, <span class="hljs-string">&quot;eeeee&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= id &lt;= n</code></li><li><code>value.length == 5</code></li><li><code>value</code> 仅由小写字母组成</li><li>每次调用 <code>insert</code> 都会使用一个唯一的 <code>id</code></li><li>恰好调用 <code>n</code> 次 <code>insert</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 cur 记录当前的流，每次插入的时候判断是否能继续执行。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> OrderedStream = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);<br>  <span class="hljs-built_in">this</span>.cur = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">idKey</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">value</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>OrderedStream.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">idKey, value</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.arr[idKey - <span class="hljs-number">1</span>] = value;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">this</span>.cur;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.arr[<span class="hljs-built_in">this</span>.cur]) &#123;<br>    <span class="hljs-built_in">this</span>.cur++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.arr.slice(start, <span class="hljs-built_in">this</span>.cur);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your OrderedStream object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new OrderedStream(n)</span><br><span class="hljs-comment"> * var param_1 = obj.insert(idKey,value)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月25日</title>
    <link href="/2021/06/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/06/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1598. 文件夹操作日志搜集器</p><span id="more"></span><h1 id="1598-文件夹操作日志搜集器"><a href="#1598-文件夹操作日志搜集器" class="headerlink" title="1598. 文件夹操作日志搜集器"></a><a href="https://leetcode-cn.com/problems/crawler-log-folder/">1598. 文件夹操作日志搜集器</a></h1><p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。<br>下面给出对变更操作的说明：</p><ul><li><code>&quot;../&quot;</code> ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 <strong>继续停留在当前文件夹</strong> 。</li><li><code>&quot;./&quot;</code> ：继续停留在当前文件夹<strong>。</strong></li><li><code>&quot;x/&quot;</code> ：移动到名为 <code>x</code> 的子文件夹中。题目数据 <strong>保证总是存在文件夹 <code>x</code></strong> 。</li></ul><p>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>i</code> 步执行的操作。<br>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。<br>执行完所有变更文件夹操作后，请你找出 <strong>返回主文件夹所需的最小步数</strong> 。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1624631570700-df481c36-2c63-476f-ad6b-2938909a7192.png#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&originHeight=171&originWidth=892&size=0&status=done&style=none&width=775"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">logs</span> = [<span class="hljs-string">&quot;d1/&quot;</span>,<span class="hljs-string">&quot;d2/&quot;</span>,<span class="hljs-string">&quot;../&quot;</span>,<span class="hljs-string">&quot;d21/&quot;</span>,<span class="hljs-string">&quot;./&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：执行 <span class="hljs-string">&quot;../&quot;</span> 操作变更文件夹 <span class="hljs-number">2</span> 次，即可回到主文件夹<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1624631570764-beb23c23-d52e-4e2d-a534-9945f73581b9.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&originHeight=346&originWidth=813&size=0&status=done&style=none&width=600"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">logs</span> = [<span class="hljs-string">&quot;d1/&quot;</span>,<span class="hljs-string">&quot;d2/&quot;</span>,<span class="hljs-string">&quot;./&quot;</span>,<span class="hljs-string">&quot;d3/&quot;</span>,<span class="hljs-string">&quot;../&quot;</span>,<span class="hljs-string">&quot;d31/&quot;</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">logs</span> = [<span class="hljs-string">&quot;d1/&quot;</span>,<span class="hljs-string">&quot;../&quot;</span>,<span class="hljs-string">&quot;../&quot;</span>,<span class="hljs-string">&quot;../&quot;</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= logs.length &lt;= 10</code></li><li><code>2 &lt;= logs[i].length &lt;= 10</code></li><li><code>logs[i]</code> 包含小写英文字母，数字，<code>&#39;.&#39;</code> 和 <code>&#39;/&#39;</code></li><li><code>logs[i]</code> 符合语句中描述的格式</li><li>文件夹名称由小写英文字母和数字组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遇到./跳过，遇到../，res 减到 0 为止，其他情况下累加，最后返回即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">logs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minOperations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">logs</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> log <span class="hljs-keyword">of</span> logs) &#123;<br>    <span class="hljs-keyword">if</span> (log === <span class="hljs-string">&quot;./&quot;</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (log === <span class="hljs-string">&quot;../&quot;</span>) res = res - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : res - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月24日</title>
    <link href="/2021/06/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/06/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt303. 区域和检索 - 数组不可变</p><span id="more"></span><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code>_ _到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。<br>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code>_ *到 <code>j</code>*（_<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：<br>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]<br>[[[<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]], [0, 2], [2, 5], [0, 5]]<br>输出：<br>[null, 1, <span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>]<br><br>解释：<br>NumArray numArray = new NumArray([<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]);<br>numArray.sumRange(0, 2); // return 1 ((<span class="hljs-string">-2</span>) + 0 + 3)<br>numArray.sumRange(2, 5); // return <span class="hljs-string">-1</span> (3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>))<br>numArray.sumRange(0, 5); // return <span class="hljs-string">-3</span> ((<span class="hljs-string">-2</span>) + 0 + 3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>))<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>10</code> 次 <code>sumRange</code>** **方法</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>累加，并记录最大最小的值，最后减去算出平均值即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> NumArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.arr = nums;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">left</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">right</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>NumArray.prototype.sumRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.arr.slice(left, right + <span class="hljs-number">1</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a + +b);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new NumArray(nums)</span><br><span class="hljs-comment"> * var param_1 = obj.sumRange(left,right)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月23日</title>
    <link href="/2021/06/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/06/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1491. 去掉最低工资和最高工资后的工资平均值</p><span id="more"></span><h1 id="1491-去掉最低工资和最高工资后的工资平均值"><a href="#1491-去掉最低工资和最高工资后的工资平均值" class="headerlink" title="1491. 去掉最低工资和最高工资后的工资平均值"></a><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/">1491. 去掉最低工资和最高工资后的工资平均值</a></h1><p>给你一个整数数组 <code>salary</code> ，数组里每个数都是 <strong>唯一</strong> 的，其中 <code>salary[i]</code> 是第 <code>i</code> 个员工的工资。<br>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。<br> <strong>示例 1：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：salary</span> <span class="hljs-string">=</span> [<span class="hljs-number">4000</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>]<br><span class="hljs-string">输出：2500.00000</span><br><span class="hljs-string">解释：最低工资和最高工资分别是</span> <span class="hljs-number">1000</span> <span class="hljs-string">和</span> <span class="hljs-number">4000</span> <span class="hljs-string">。</span><br><span class="hljs-string">去掉最低工资和最高工资以后的平均工资是</span> <span class="hljs-string">(2000+3000)/2=</span> <span class="hljs-number">2500</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：salary</span> <span class="hljs-string">=</span> [<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">3000</span>]<br><span class="hljs-string">输出：2000.00000</span><br><span class="hljs-string">解释：最低工资和最高工资分别是</span> <span class="hljs-number">1000</span> <span class="hljs-string">和</span> <span class="hljs-number">3000</span> <span class="hljs-string">。</span><br><span class="hljs-string">去掉最低工资和最高工资以后的平均工资是</span> <span class="hljs-string">(2000)/1=</span> <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：salary</span> <span class="hljs-string">=</span> [<span class="hljs-number">6000</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">4000</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">1000</span>]<br><span class="hljs-string">输出：3500.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：salary</span> <span class="hljs-string">=</span> [<span class="hljs-number">8000</span>,<span class="hljs-number">9000</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">6000</span>,<span class="hljs-number">1000</span>]<br><span class="hljs-string">输出：4750.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= salary.length &lt;= 100</code></li><li><code>10^3 &lt;= salary[i] &lt;= 10^6</code></li><li><code>salary[i]</code> 是唯一的。</li><li>与真实值误差在 <code>10^-5</code> 以内的结果都将视为正确答案。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>累加，并记录最大最小的值，最后减去算出平均值即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">salary</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> average = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">salary</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> length = salary.length - <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-literal">Infinity</span>,<br>    max = -<span class="hljs-literal">Infinity</span>,<br>    sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> salary) &#123;<br>    min = <span class="hljs-built_in">Math</span>.min(min, num);<br>    max = <span class="hljs-built_in">Math</span>.max(max, num);<br>    sum += num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (sum - min - max) / length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月22日</title>
    <link href="/2021/06/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/06/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1603. 设计停车系统</p><span id="more"></span><h1 id="1603-设计停车系统"><a href="#1603-设计停车系统" class="headerlink" title="1603. 设计停车系统"></a><a href="https://leetcode-cn.com/problems/design-parking-system/">1603. 设计停车系统</a></h1><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。<br>请你实现 <code>ParkingSystem</code> 类：</p><ul><li><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。</li><li><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong> ** **<code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<br>[<span class="hljs-string">&quot;ParkingSystem&quot;</span>, <span class="hljs-string">&quot;addCar&quot;</span>, <span class="hljs-string">&quot;addCar&quot;</span>, <span class="hljs-string">&quot;addCar&quot;</span>, <span class="hljs-string">&quot;addCar&quot;</span>]<br><span class="hljs-string">[[1, 1, 0], [1], [2], [3], [1]]</span><br>输出：<br>[null, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>]<br>解释：<br>ParkingSystem parkingSystem = new ParkingSystem(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>parkingSystem.addCar(<span class="hljs-number">1</span>); // 返回 <span class="hljs-literal">true</span> ，因为有 <span class="hljs-number">1</span> 个空的大车位<br>parkingSystem.addCar(<span class="hljs-number">2</span>); // 返回 <span class="hljs-literal">true</span> ，因为有 <span class="hljs-number">1</span> 个空的中车位<br>parkingSystem.addCar(<span class="hljs-number">3</span>); // 返回 <span class="hljs-literal">false</span> ，因为没有空的小车位<br>parkingSystem.addCar(<span class="hljs-number">1</span>); // 返回 <span class="hljs-literal">false</span> ，因为没有空的大车位，唯一一个大车位已经被占据了<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= big, medium, small &lt;= 1000</code></li><li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li><li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意完成即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">big</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">medium</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">small</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> ParkingSystem = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">big, medium, small</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.rest = &#123; <span class="hljs-number">1</span>: big, <span class="hljs-number">2</span>: medium, <span class="hljs-number">3</span>: small &#125;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">carType</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>ParkingSystem.prototype.addCar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">carType</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.rest[carType]) &#123;<br>    <span class="hljs-built_in">this</span>.rest[carType]--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your ParkingSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new ParkingSystem(big, medium, small)</span><br><span class="hljs-comment"> * var param_1 = obj.addCar(carType)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月21日</title>
    <link href="/2021/06/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/06/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 68 - II. 二叉树的最近公共祖先</p><span id="more"></span><h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1624286368204-6ae47168-d837-4778-ad5d-3787486888d4.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=200&size=0&status=done&style=none&width=200"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于一个二叉树，如果当前节点等于 p 或 q，说明这个树的根节点一定是最近公共祖先。如果不是，递归地求出左边和右边第一个等于 p 或者 q 的节点。有四种情况，左右都找到了、只在左边找到了、只在右边找到了，都没找到。分别对应，当前节点就是公共祖先节点、公共祖先节点在左边、公共祖先节点在右边、不存在公共祖先节点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (root === p || root === q) <span class="hljs-keyword">return</span> root;<br>  <span class="hljs-keyword">const</span> left = lowestCommonAncestor(root.left, p, q);<br>  <span class="hljs-keyword">const</span> right = lowestCommonAncestor(root.right, p, q);<br>  <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right) <span class="hljs-keyword">return</span> right;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left) <span class="hljs-keyword">return</span> left;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月20日</title>
    <link href="/2021/06/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/06/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1619. 删除某些元素后的数组均值</p><span id="more"></span><h1 id="1619-删除某些元素后的数组均值"><a href="#1619-删除某些元素后的数组均值" class="headerlink" title="1619. 删除某些元素后的数组均值"></a><a href="https://leetcode-cn.com/problems/mean-of-array-after-removing-some-elements/">1619. 删除某些元素后的数组均值</a></h1><p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。<br>与 <strong>标准答案</strong> 误差在 <code>10</code> 的结果都被视为正确结果。<br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1,2,2,2</span>,<span class="hljs-number">2,2,2,2</span>,<span class="hljs-number">2,2,2,2</span>,<span class="hljs-number">2,2,2,2</span>,<span class="hljs-number">2,2,2,3</span>]<br>输出：<span class="hljs-number">2.00000</span><br>解释：删除数组中最大和最小的元素后，所有元素都等于 <span class="hljs-number">2</span>，所以平均值为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">6,2,7,5</span>,<span class="hljs-number">1,2,0,3</span>,<span class="hljs-number">10,2,5,0</span>,<span class="hljs-number">5,5,0,8</span>,<span class="hljs-number">7,6,8,0</span>]<br>输出：<span class="hljs-number">4.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">6,0,7,0</span>,<span class="hljs-number">7,5,7,8</span>,<span class="hljs-number">3,4,0,7</span>,<span class="hljs-number">8,1,6,8</span>,<span class="hljs-number">1,1,2,4</span>,<span class="hljs-number">8,1,9,5</span>,<span class="hljs-number">4,3,8,5</span>,<span class="hljs-number">10,8,6,6</span>,<span class="hljs-number">1,0,6,10</span>,<span class="hljs-number">8,2,3,4</span>]<br>输出：<span class="hljs-number">4.77778</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">9,7,8,7</span>,<span class="hljs-number">7,8,4,4</span>,<span class="hljs-number">6,8,8,7</span>,<span class="hljs-number">6,8,8,9</span>,<span class="hljs-number">2,6,0,0</span>,<span class="hljs-number">1,10,8,6</span>,<span class="hljs-number">3,3,5,1</span>,<span class="hljs-number">10,9,0,7</span>,<span class="hljs-number">10,0,10,4</span>,<span class="hljs-number">1,10,6,9</span>,<span class="hljs-number">3,6,0,0</span>,<span class="hljs-number">2,7,0,6</span>,<span class="hljs-number">7,2,9,7</span>,<span class="hljs-number">7,3,0,1</span>,<span class="hljs-number">6,1,10,3</span>]<br>输出：<span class="hljs-number">5.27778</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">4,8,4,10</span>,<span class="hljs-number">0,7,1,3</span>,<span class="hljs-number">7,8,8,3</span>,<span class="hljs-number">4,1,6,2</span>,<span class="hljs-number">1,1,8,0</span>,<span class="hljs-number">9,8,0,3</span>,<span class="hljs-number">9,10,3,10</span>,<span class="hljs-number">1,10,7,3</span>,<span class="hljs-number">2,1,4,9</span>,<span class="hljs-number">10,7,6,4</span>,<span class="hljs-number">0,8,5,1</span>,<span class="hljs-number">2,1,6,2</span>,<span class="hljs-number">5,0,7,10</span>,<span class="hljs-number">9,10,3,7</span>,<span class="hljs-number">10,5,8,5</span>,<span class="hljs-number">7,6,7,6</span>,<span class="hljs-number">10,9,5,10</span>,<span class="hljs-number">5,5,7,2</span>,<span class="hljs-number">10,7,7,8</span>,<span class="hljs-number">2,0,1,1</span>]<br>输出：<span class="hljs-number">5.29167</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>20 &lt;= arr.length &lt;= 1000</code></li><li><code>arr.length</code>** <strong>是 <code>20</code> 的</strong>  倍数**</li><li><code>0 &lt;= arr[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>排序后再删除前后 5%的数据，再累加求出平均数返回即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> trimMean = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> length = arr.length;<br>  arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b).slice(<span class="hljs-number">0.05</span> * length, <span class="hljs-number">0.95</span> * length);<br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b) / arr.length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月19日</title>
    <link href="/2021/06/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/06/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCS 02. 完成一半题目</p><span id="more"></span><h1 id="LCS-02-完成一半题目"><a href="#LCS-02-完成一半题目" class="headerlink" title="LCS 02. 完成一半题目"></a><a href="https://leetcode-cn.com/problems/WqXACV/">LCS 02. 完成一半题目</a></h1><p>有 <code>N</code> 位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了 <code>2*N</code> 道题目，整型数组 <code>questions</code> 中每个数字对应了每道题目所涉及的知识点类型。<br>若每位扣友选择不同的一题，请返回被选的 <code>N</code> 道题目至少包含多少种知识点类型。<br><strong>示例 1：</strong></p><blockquote><p>输入：<code>questions = [2,1,6,2]</code><br>输出：<code>1</code><br>解释：有 2 位扣友在 4 道题目中选择 2 题。<br>可选择完成知识点类型为 2 的题目时，此时仅一种知识点类型<br>因此至少包含 1 种知识点类型。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>questions = [1,5,1,3,4,5,2,5,3,3,8,6]</code><br>输出：<code>2</code><br>解释：有 6 位扣友在 12 道题目中选择题目，需要选择 6 题。<br>选择完成知识点类型为 3、5 的题目，因此至少包含 2 种知识点类型。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>questions.length == 2*n</code></li><li><code>2 &lt;= questions.length &lt;= 10^5</code></li><li><code>1 &lt;= questions[i] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表记录题目出现次数，降序排序，遍历计数累减，而知识点类型累加，直到为 0 表示已经取了 N 题了，返回 res。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">questions</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> halfQuestions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">questions</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> question <span class="hljs-keyword">of</span> questions) &#123;<br>    <span class="hljs-keyword">if</span> (map[question]) map[question]++;<br>    <span class="hljs-keyword">else</span> map[question] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>.entries(map).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">let</span> count = questions.length / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    count -= value;<br>    res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月18日</title>
    <link href="/2021/06/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/06/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1700. 无法吃午餐的学生数量</p><span id="more"></span><h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode-cn.com/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p><ul><li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li><li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li></ul><p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。<br>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i</code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j</code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：students = <span class="hljs-comment">[1,1,0,0]</span>, sandwiches = <span class="hljs-comment">[0,1,0,1]</span><br>输出：0<br>解释：<br>- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = <span class="hljs-comment">[1,0,0,1]</span>。<br>- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = <span class="hljs-comment">[0,0,1,1]</span>。<br>- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = <span class="hljs-comment">[0,1,1]</span>，三明治栈为 sandwiches = <span class="hljs-comment">[1,0,1]</span>。<br>- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = <span class="hljs-comment">[1,1,0]</span>。<br>- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = <span class="hljs-comment">[1,0]</span>，三明治栈为 sandwiches = <span class="hljs-comment">[0,1]</span>。<br>- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = <span class="hljs-comment">[0,1]</span>。<br>- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = <span class="hljs-comment">[1]</span>，三明治栈为 sandwiches = <span class="hljs-comment">[1]</span>。<br>- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = <span class="hljs-comment">[]</span>，三明治栈为 sandwiches = <span class="hljs-comment">[]</span>。<br>所以所有学生都有三明治吃。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：students = <span class="hljs-string">[1,1,1,0,0,1]</span>, sandwiches = <span class="hljs-string">[1,0,0,0,1,1]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li><li><code>students.length == sandwiches.length</code></li><li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li><li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 count 计数判断是否整个队列都已经判断过。判断队首是否相等，是的话，三明治队列队首出队，同时 count 计数归零；不是的话，学生重新入队，count 计数自增。如果计数和学生数量相同，说明所有学生都不喜欢队首的三明治，结束循环。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">students</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">sandwiches</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countStudents = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">students, sandwiches</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>    res = <span class="hljs-number">0</span>,<br>    oriNum = students.length;<br>  <span class="hljs-keyword">while</span> (students.length) &#123;<br>    <span class="hljs-keyword">const</span> peak = students.shift();<br>    <span class="hljs-keyword">if</span> (peak === sandwiches[<span class="hljs-number">0</span>]) &#123;<br>      sandwiches.shift();<br>      count = <span class="hljs-number">0</span>;<br>      res++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      students.push(peak);<br>      count++;<br>      <span class="hljs-keyword">if</span> (count === students.length) <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> oriNum - res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月17日</title>
    <link href="/2021/06/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/06/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt811. 子域名访问计数</p><span id="more"></span><h1 id="811-子域名访问计数"><a href="#811-子域名访问计数" class="headerlink" title="811. 子域名访问计数"></a><a href="https://leetcode-cn.com/problems/subdomain-visit-count/">811. 子域名访问计数</a></h1><p>一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名  “com”。<br>给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。<br>接下来会给出一组访问次数和域名组合的列表<code>cpdomains</code> 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。<br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>[<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>]<br><span class="hljs-section">输出:</span><br>[<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>, <span class="hljs-string">&quot;9001 leetcode.com&quot;</span>, <span class="hljs-string">&quot;9001 com&quot;</span>]<br><span class="hljs-section">说明:</span><br>例子中仅包含一个网站域名：<span class="hljs-string">&quot;discuss.leetcode.com&quot;</span>。按照前文假设，子域名<span class="hljs-string">&quot;leetcode.com&quot;</span>和<span class="hljs-string">&quot;com&quot;</span>都会被访问，所以它们都被访问了9001次。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>[<span class="hljs-string">&quot;900 google.mail.com&quot;</span>, <span class="hljs-string">&quot;50 yahoo.com&quot;</span>, <span class="hljs-string">&quot;1 intel.mail.com&quot;</span>, <span class="hljs-string">&quot;5 wiki.org&quot;</span>]<br><span class="hljs-section">输出:</span><br>[<span class="hljs-string">&quot;901 mail.com&quot;</span>,<span class="hljs-string">&quot;50 yahoo.com&quot;</span>,<span class="hljs-string">&quot;900 google.mail.com&quot;</span>,<span class="hljs-string">&quot;5 wiki.org&quot;</span>,<span class="hljs-string">&quot;5 org&quot;</span>,<span class="hljs-string">&quot;1 intel.mail.com&quot;</span>,<span class="hljs-string">&quot;951 com&quot;</span>]<br><span class="hljs-section">说明:</span><br>按照假设，会访问<span class="hljs-string">&quot;google.mail.com&quot;</span> 900次，<span class="hljs-string">&quot;yahoo.com&quot;</span> 50次，<span class="hljs-string">&quot;intel.mail.com&quot;</span> 1次，<span class="hljs-string">&quot;wiki.org&quot;</span> 5次。<br>而对于父域名，会访问<span class="hljs-string">&quot;mail.com&quot;</span> 900+1 = 901次，<span class="hljs-string">&quot;com&quot;</span> 900 + 50 + 1 = 951次，和 <span class="hljs-string">&quot;org&quot;</span> 5 次。<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><code>cpdomains</code> 的长度小于 <code>100</code>。</li><li>每个域名的长度小于<code>100</code>。</li><li>每个域名地址包含一个或两个”.”符号。</li><li>输入中任意一个域名的访问次数都小于<code>10000</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用哈希表记录每个域名出现的次数，最后返回即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">cpdomains</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subdomainVisits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cpdomains</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cpdomain <span class="hljs-keyword">of</span> cpdomains) &#123;<br>    <span class="hljs-keyword">let</span> [times, domain] = cpdomain.split(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">let</span> next = domain.indexOf(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">while</span> (domain.length) &#123;<br>      <span class="hljs-keyword">if</span> (map[domain]) map[domain] += +times;<br>      <span class="hljs-keyword">else</span> map[domain] = +times;<br>      <span class="hljs-keyword">if</span> (next === -<span class="hljs-number">1</span>) domain = <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">else</span> domain = domain.slice(next + <span class="hljs-number">1</span>);<br>      next = domain.indexOf(<span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(map).map(<span class="hljs-function">(<span class="hljs-params">[domain, times]</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;times&#125;</span> <span class="hljs-subst">$&#123;domain&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月16日</title>
    <link href="/2021/06/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/06/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt938. 二叉搜索树的范围和</p><span id="more"></span><h1 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h1><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623854358164-44d4c051-c83a-4ade-a5d6-d45cc27cfd95.jpeg#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&originHeight=301&originWidth=542&size=0&status=done&style=none&width=400"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">18</span>], <span class="hljs-attr">low</span> = <span class="hljs-number">7</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">15</span><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623854359098-9de96596-b2f3-4eb5-9a38-a021a62ef38d.jpeg#align=left&display=inline&height=335&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=502&size=0&status=done&style=none&width=400"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>], <span class="hljs-attr">low</span> = <span class="hljs-number">6</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 2 * 10]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 10</code></li><li><code>1 &lt;= low &lt;= high &lt;= 10</code></li><li>所有 <code>Node.val</code> <strong>互不相同</strong></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历时，判断节点的值是不是在范围内，是的话累加即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">L</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rangeSumBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, L, R</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    visit(node.left);<br>    <span class="hljs-keyword">if</span> (node.val &gt;= L &amp;&amp; node.val &lt;= R) res += node.val;<br>    visit(node.right);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月15日</title>
    <link href="/2021/06/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/06/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1394. 找出数组中的幸运数</p><span id="more"></span><h1 id="1394-找出数组中的幸运数"><a href="#1394-找出数组中的幸运数" class="headerlink" title="1394. 找出数组中的幸运数"></a><a href="https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/">1394. 找出数组中的幸运数</a></h1><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。<br>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p><ul><li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li><li>如果数组中不含幸运数，则返回 **-1 **。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [2,2,3,4]<br>输出：2<br>解释：数组中唯一的幸运数是<span class="hljs-number"> 2 </span>，因为数值<span class="hljs-number"> 2 </span>的出现频次也是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [1,2,2,3,3,3]<br>输出：3<br>解释：1、2 以及<span class="hljs-number"> 3 </span>都是幸运数，只需要返回其中最大的<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,2,3,3]</span><br>输出：-<span class="hljs-number">1</span><br>解释：数组中不存在幸运数。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：arr </span>=<span class="hljs-string"> [5]</span><br><span class="hljs-string">输出：-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>1 &lt;= arr[i] &lt;= 500</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表记录出现的频率，filter 筛选出出现频率和数字相同的数，降序排序选择最大的。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findLucky = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (map[num]) map[num]++;<br>    <span class="hljs-keyword">else</span> map[num] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> filterArr = <span class="hljs-built_in">Object</span>.entries(map).filter(<br>    <span class="hljs-function">(<span class="hljs-params">[num, times]</span>) =&gt;</span> +num === times<br>  );<br>  <span class="hljs-keyword">if</span> (!filterArr.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> filterArr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月14日</title>
    <link href="/2021/06/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/06/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt892. 三维形体的表面积</p><span id="more"></span><h1 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a><a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/">892. 三维形体的表面积</a></h1><p>给你一个 <code>n * n</code> 的网格 <code>grid</code> ，上面放置着一些 <code>1 x 1 x 1</code> 的正方体。<br>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。<br>放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。<br>请你返回最终这些形体的总表面积。<br><strong>注意：</strong>每个形体的底面也需要计入表面积中。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623643148270-d1634647-94f9-4cea-9ac2-ed92cab8bbc2.jpeg#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&originHeight=82&originWidth=82&size=0&status=done&style=none&width=82"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[2]]</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623643148285-be7d9afe-e8ce-4c07-8459-3265b7d7b650.jpeg#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=162&size=0&status=done&style=none&width=162"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-number">34</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623643148255-995ee05a-90c9-4132-abd8-dbfba1f3b715.jpeg#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=162&size=0&status=done&style=none&width=162"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,0],[0,2]]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623643148265-4b5e5d5e-d260-4d11-8398-f375155b45fa.jpeg#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=242&size=0&status=done&style=none&width=242"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1623643148273-3272a568-6a35-4382-9b77-e0e0567e514a.jpeg#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=242&size=0&status=done&style=none&width=242"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[2,2,2],[2,1,2],[2,2,2]]</span><br>输出：<span class="hljs-number">46</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt;= 50</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个元素，先计算出叠放后的表面积，再减去上下左右被遮挡的面积</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> surfaceArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">const</span> cur = grid[i][j];<br>      <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">const</span> top = i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ? grid[i - <span class="hljs-number">1</span>][j] : <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">const</span> bottom = i + <span class="hljs-number">1</span> &lt; grid.length ? grid[i + <span class="hljs-number">1</span>][j] : <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">const</span> left = grid[i][j - <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">const</span> right = grid[i][j + <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">const</span> area = cur * <span class="hljs-number">6</span> - <span class="hljs-number">2</span> * (cur - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">const</span> topArea = <span class="hljs-built_in">Math</span>.min(cur, top);<br>      <span class="hljs-keyword">const</span> bottomArea = <span class="hljs-built_in">Math</span>.min(cur, bottom);<br>      <span class="hljs-keyword">const</span> leftArea = <span class="hljs-built_in">Math</span>.min(cur, left ? left : <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">const</span> rightArea = <span class="hljs-built_in">Math</span>.min(cur, right ? right : <span class="hljs-number">0</span>);<br>      res += area - topArea - bottomArea - leftArea - rightArea;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月13日</title>
    <link href="/2021/06/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/06/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCP 07. 传递信息</p><span id="more"></span><h1 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h1><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 <code>n</code>，以及按 <code>[玩家编号,对应可传递玩家编号]</code> 关系组成的二维数组 <code>relation</code>。返回信息从小 A (编号 0 ) 经过 <code>k</code> 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。<br><strong>示例 1：</strong></p><blockquote><p>输入：<code>n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</code><br>输出：<code>3</code><br>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>n = 3, relation = [[0,2],[2,1]], k = 2</code><br>输出：<code>0</code><br>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><p><strong>限制：</strong></p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用哈希表记录每个节点的边，深度遍历判断第 k 次传播时，终点为不为 n-1，是的话计数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">relation</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numWays = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, relation, k</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> relation) &#123;<br>    <span class="hljs-keyword">const</span> [start] = item;<br>    <span class="hljs-keyword">if</span> (map.has(start)) map.set(start, [...map.get(start), item]);<br>    <span class="hljs-keyword">else</span> map.set(start, [item]);<br>  &#125;<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">ways, count</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!ways || count &gt;= k) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [start, end] <span class="hljs-keyword">of</span> ways) &#123;<br>      <span class="hljs-keyword">if</span> (count + <span class="hljs-number">1</span> === k &amp;&amp; end === n - <span class="hljs-number">1</span>) res++;<br>      dfs(map.get(end), count + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;;<br>  dfs(map.get(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月12日</title>
    <link href="/2021/06/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/06/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt696. 计数二进制子串</p><span id="more"></span><h1 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h1><p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。<br>重复出现的子串要计算它们出现的次数。<br><strong>示例 1 :</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;00110011&quot;</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br></code></pre></td></tr></table></figure><p>请注意，一些重复出现的子串要计算它们出现的次数。<br>另外，“00110011”不是有效的子串，因为所有的 0（和 1）没有组合在一起。<br><strong>示例 2 :</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;10101&quot;</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s.length</code> 在 1 到 50,000 之间。</li><li><code>s</code> 只包含“0”或“1”字符。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有数字，从中间向两边扩散计数，如果左边等于右边或者不连续了跳出当前扩散，如果左右不相等 res 计数加一。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countBinarySubstrings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> prev = s[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i - j &gt;= <span class="hljs-number">0</span> &amp;&amp; i + <span class="hljs-number">1</span> + j &lt; s.length; j++) &#123;<br>      <span class="hljs-keyword">const</span> left = s[i - j],<br>        right = s[i + <span class="hljs-number">1</span> + j];<br>      <span class="hljs-keyword">if</span> (prev !== left) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span> (left !== right) res++;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>      prev = left;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月11日</title>
    <link href="/2021/06/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/06/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt788. 旋转数字</p><span id="more"></span><h1 id="788-旋转数字"><a href="#788-旋转数字" class="headerlink" title="788. 旋转数字"></a><a href="https://leetcode-cn.com/problems/rotated-digits/">788. 旋转数字</a></h1><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。<br>如果一个数的每位数字被旋转以后仍然还是一个数字，  则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。<br>现在我们有一个正整数  N, 计算从  1 到  N 中有多少个数  X 是好数？<br><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 10</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释:</span><br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>N  的取值范围是 <code>[1, 10000]</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有数字，转为字符串，如果字符串包含 3,4,7，那么直接跳过；如果字符串包含 2,5,6,9 那么反转后数字会不同，进行计数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">N</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotatedDigits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">N</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) &#123;<br>    <span class="hljs-keyword">const</span> str = i + <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (str.includes(<span class="hljs-string">&quot;3&quot;</span>) || str.includes(<span class="hljs-string">&quot;4&quot;</span>) || str.includes(<span class="hljs-string">&quot;7&quot;</span>)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (<br>      str.includes(<span class="hljs-string">&quot;2&quot;</span>) ||<br>      str.includes(<span class="hljs-string">&quot;5&quot;</span>) ||<br>      str.includes(<span class="hljs-string">&quot;6&quot;</span>) ||<br>      str.includes(<span class="hljs-string">&quot;9&quot;</span>)<br>    )<br>      res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月10日</title>
    <link href="/2021/06/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/06/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt868. 二进制间距</p><span id="more"></span><h1 id="868-二进制间距"><a href="#868-二进制间距" class="headerlink" title="868. 二进制间距"></a><a href="https://leetcode-cn.com/problems/binary-gap/">868. 二进制间距</a></h1><p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的**  最长距离  <strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。<br>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 **相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>&quot;1001&quot;</code> 中的两个 <code>1</code> 的距离为 3 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 22<br>输出：2<br>解释：<br>22 的二进制是 &quot;10110&quot; 。<br>在<span class="hljs-number"> 22 </span>的二进制表示中，有三个 1，组成两对相邻的<span class="hljs-number"> 1 </span>。<br>第一对相邻的<span class="hljs-number"> 1 </span>中，两个<span class="hljs-number"> 1 </span>之间的距离为<span class="hljs-number"> 2 </span>。<br>第二对相邻的<span class="hljs-number"> 1 </span>中，两个<span class="hljs-number"> 1 </span>之间的距离为<span class="hljs-number"> 1 </span>。<br>答案取两个距离之中最大的，也就是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">5</span> 的二进制是 <span class="hljs-string">&quot;101&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">1</span><br>解释：<br><span class="hljs-number">6</span> 的二进制是 <span class="hljs-string">&quot;110&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">0</span><br>解释：<br><span class="hljs-number">8</span> 的二进制是 <span class="hljs-string">&quot;1000&quot;</span> 。<br>在 <span class="hljs-number">8</span> 的二进制表示中没有相邻的两个 <span class="hljs-number">1</span>，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= N &lt;= 10^9</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将数字转为二进制字符串，先找到第一个为 1 的数，再从这里开始每遇到一个 1 都计算和上一个 1 中间的间隔，更新 max，最后返回 max 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> binaryGap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> str = n.toString(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> prev,<br>    max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; str.length) <span class="hljs-keyword">if</span> (str[i++] == <span class="hljs-number">1</span>) prev = i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> element = str[i];<br>    <span class="hljs-keyword">if</span> (element == <span class="hljs-number">1</span>) &#123;<br>      max = <span class="hljs-built_in">Math</span>.max(max, i - prev);<br>      prev = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月9日</title>
    <link href="/2021/06/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%889%E6%97%A5/"/>
    <url>/2021/06/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 17.04. 消失的数字</p><span id="more"></span><h1 id="面试题-17-04-消失的数字"><a href="#面试题-17-04-消失的数字" class="headerlink" title="面试题 17.04. 消失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number-lcci/">面试题 17.04. 消失的数字</a></h1><p>数组<code>nums</code>包含从<code>0</code>到<code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在 O(n)时间内完成吗？<br><strong>注意：</strong>本题相对书上原题稍作改动<br><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,0,1]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">9,6,4,2</span>,<span class="hljs-number">3,5,7,0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>实际为一个等差数列，用公式求出来和以后，遍历减去每一个数，最后剩下的就是缺失的数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> missingNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = ((nums.length + <span class="hljs-number">1</span>) * nums.length) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    res -= num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月8日</title>
    <link href="/2021/06/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%888%E6%97%A5/"/>
    <url>/2021/06/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<ol start="338"><li>比特位计数<span id="more"></span></li></ol><h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h1><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num **范围中的每个数字 **i **，计算其二进制数中的 1 的数目并将它们作为数组返回。<br>**示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [0,1,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 5</span><br><span class="hljs-section">输出: [0,1,1,2,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>给出时间复杂度为<strong>O(n*sizeof(integer))**的解答非常容易。但你可以在线性时间</strong>O(n)**内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为**O(n)**。</li><li>你能进一步完善解法吗？要求在 C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一种暴力转二进制字符串然后对 1 计数解。<br>另外一种找规律：如果 i 为偶数，说明只是上一个偶数向左移动了一位，1 的个数不变；如果 i 为奇数，则相当于上一个偶数加上一个 1。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> i.toString(<span class="hljs-number">2</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (num + <span class="hljs-string">&quot;&quot;</span> === <span class="hljs-string">&quot;1&quot;</span>) temp++;<br>    &#125;<br>    res.push(temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) res.push(+res[i / <span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">else</span> res.push(+res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月7日</title>
    <link href="/2021/06/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%887%E6%97%A5/"/>
    <url>/2021/06/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCP 06. 拿硬币</p><span id="more"></span><h1 id="LCP-06-拿硬币"><a href="#LCP-06-拿硬币" class="headerlink" title="LCP 06. 拿硬币"></a><a href="https://leetcode-cn.com/problems/na-ying-bi/">LCP 06. 拿硬币</a></h1><p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。<br><strong>示例 1：</strong></p><blockquote><p>输入：<code>[4,2,1]</code><br>输出：<code>4</code><br>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>[2,3,10]</code><br>输出：<code>8</code></p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，计数加上当前数量/2，如果是奇数再加上余数 1。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">coins</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minCount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">coins</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  coins.forEach(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) res += <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">else</span> res += <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月6日</title>
    <link href="/2021/06/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%886%E6%97%A5/"/>
    <url>/2021/06/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCP 02. 分式化简</p><span id="more"></span><h1 id="LCP-02-分式化简"><a href="#LCP-02-分式化简" class="headerlink" title="LCP 02. 分式化简"></a><a href="https://leetcode-cn.com/problems/deep-dark-fraction/">LCP 02. 分式化简</a></h1><p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？</p><p>连分数是形如上图的分式。在本题中，所有系数都是大于等于 0 的整数。<br>  输入的<code>cont</code>代表连分数的系数（<code>cont[0]</code>代表上图的<code>a</code>，以此类推）。返回一个长度为 2 的数组<code>[n, m]</code>，使得连分数的值等于<code>n / m</code>，且<code>n, m</code>最大公约数为 1。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cont = <span class="hljs-comment">[3, 2, 0, 2]</span><br>输出：<span class="hljs-comment">[13, 4]</span><br>解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意<span class="hljs-comment">[26, 8]</span>, <span class="hljs-comment">[-13, -4]</span>都不是正确答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cont = <span class="hljs-comment">[0, 0, 3]</span><br>输出：<span class="hljs-comment">[3, 1]</span><br>解释：如果答案是整数，令分母为1即可。<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ol><li><code>cont[i] &gt;= 0</code></li><li><code>1 &lt;= cont的长度 &lt;= 10</code></li><li><code>cont</code>最后一个元素不等于 0</li><li>答案的<code>n, m</code>的取值都能被 32 位 int 整型存下（即不超过<code>2 ^ 31 - 1</code>）。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从最后开始取两项，将公式 1/ (a+(c/b))，只看分母部分，化简为(a*b+c)/b，分别存储每一步的分子分母到 prev 中，直到计算完整个式子返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">cont</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fraction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cont</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getNum = <span class="hljs-function">(<span class="hljs-params">[a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>]</span>) =&gt;</span> [+a * +b + +c, +b];<br>  <span class="hljs-keyword">let</span> prev = getNum([...cont.splice(-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">while</span> (cont.length) &#123;<br>    <span class="hljs-keyword">const</span> num = cont.splice(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    prev = getNum([...num, ...prev]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> prev;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月5日</title>
    <link href="/2021/06/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%885%E6%97%A5/"/>
    <url>/2021/06/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCP 01. 猜数字</p><span id="more"></span><h1 id="LCP-01-猜数字"><a href="#LCP-01-猜数字" class="headerlink" title="LCP 01. 猜数字"></a><a href="https://leetcode-cn.com/problems/guess-numbers/">LCP 01. 猜数字</a></h1><p>小 A 和 小 B 在玩猜数字。小 B 每次从 1, 2, 3 中随机选择一个，小 A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小 A 猜对了几次？<br>输入的<code>guess</code>数组为 小 A 每次的猜测，<code>answer</code>数组为 小 B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于 3。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：guess = <span class="hljs-comment">[1,2,3]</span>, answer = <span class="hljs-comment">[1,2,3]</span><br>输出：3<br>解释：小A 每次都猜对了。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：guess = <span class="hljs-comment">[2,2,3]</span>, answer = <span class="hljs-comment">[3,2,1]</span><br>输出：1<br>解释：小A 只猜对了第二次。<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ol><li><code>guess</code> 的长度 = 3</li><li><code>answer</code> 的长度 = 3</li><li><code>guess</code> 的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li><li><code>answer</code> 的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次只有三个数字，判断结果是否相等计数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">guess</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">answer</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> game = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">guess, answer</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    (guess[<span class="hljs-number">0</span>] === answer[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) +<br>    (guess[<span class="hljs-number">1</span>] === answer[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) +<br>    (guess[<span class="hljs-number">2</span>] === answer[<span class="hljs-number">2</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月4日</title>
    <link href="/2021/06/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%884%E6%97%A5/"/>
    <url>/2021/06/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1848. 到目标元素的最小距离</p><span id="more"></span><h1 id="1848-到目标元素的最小距离"><a href="#1848-到目标元素的最小距离" class="headerlink" title="1848. 到目标元素的最小距离"></a><a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/">1848. 到目标元素的最小距离</a></h1><p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 <code>i</code> ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code> <strong>最小化</strong> 。注意：<code>abs(x)</code> 表示 <code>x</code> 的绝对值。<br>返回 <code>abs(i - start)</code> 。<br>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。<br><strong>示例 1：</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>, start = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">1</span><br>解释：nums[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span> 是唯一一个等于 <span class="hljs-keyword">target</span> 的值，所以答案是 <span class="hljs-built_in">abs</span>(<span class="hljs-number">4</span> - <span class="hljs-number">3</span>) = <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">1</span>, start = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br>解释：nums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> 是唯一一个等于 <span class="hljs-keyword">target</span> 的值，所以答案是 <span class="hljs-built_in">abs</span>(<span class="hljs-number">0</span> - <span class="hljs-number">0</span>) = <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], target <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br>解释：nums 中的每个值都是 <span class="hljs-number">1</span> ，但 nums[<span class="hljs-number">0</span>] 使 <span class="hljs-built_in">abs</span>(i <span class="hljs-operator">-</span> <span class="hljs-keyword">start</span>) 的结果得以最小化，所以答案是 <span class="hljs-built_in">abs</span>(<span class="hljs-number">0</span> <span class="hljs-operator">-</span> <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 10</code></li><li><code>0 &lt;= start &lt; nums.length</code></li><li><code>target</code> 存在于 <code>nums</code> 中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从 start 向两边同时开始找起，如果两边任意一个值等于 target 返回 i 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">start</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getMinDistance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target, start</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> prev = start - i &gt;= <span class="hljs-number">0</span> ? start - i : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> next = start + i &lt; nums.length ? start + i : nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[prev] === target || nums[next] === target) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月3日</title>
    <link href="/2021/06/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%883%E6%97%A5/"/>
    <url>/2021/06/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1869. 哪种连续子字符串更长</p><span id="more"></span><h1 id="1869-哪种连续子字符串更长"><a href="#1869-哪种连续子字符串更长" class="headerlink" title="1869. 哪种连续子字符串更长"></a><a href="https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros/">1869. 哪种连续子字符串更长</a></h1><p>给你一个二进制字符串 <code>s</code> 。如果字符串中由 <code>1</code> 组成的 <strong>最长</strong> 连续子字符串 <strong>严格长于</strong> 由 <code>0</code> 组成的 <strong>最长</strong> 连续子字符串，返回 <code>true</code> ；否则，返回 <code>false</code>_ _。</p><ul><li>例如，<code>s = &quot;**11**01**000**10&quot;</code> 中，由 <code>1</code> 组成的最长连续子字符串的长度是 <code>2</code> ，由 <code>0</code> 组成的最长连续子字符串的长度是 <code>3</code> 。</li></ul><p>注意，如果字符串中不存在 <code>0</code> ，此时认为由 <code>0</code> 组成的最长连续子字符串的长度是 <code>0</code> 。字符串中不存在 <code>1</code> 的情况也适用此规则。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1101&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>由 <span class="hljs-number">1</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">2</span>：<span class="hljs-string">&quot;1101&quot;</span><br>由 <span class="hljs-number">0</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">1</span>：<span class="hljs-string">&quot;1101&quot;</span><br>由 <span class="hljs-number">1</span> 组成的子字符串更长，故返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;111000&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>由 <span class="hljs-number">1</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">3</span>：<span class="hljs-string">&quot;111000&quot;</span><br>由 <span class="hljs-number">0</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">3</span>：<span class="hljs-string">&quot;111000&quot;</span><br>由 <span class="hljs-number">1</span> 组成的子字符串不比由 <span class="hljs-number">0</span> 组成的子字符串长，故返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;110100010&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>由 <span class="hljs-number">1</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">2</span>：<span class="hljs-string">&quot;110100010&quot;</span><br>由 <span class="hljs-number">0</span> 组成的最长连续子字符串的长度是 <span class="hljs-number">3</span>：<span class="hljs-string">&quot;110100010&quot;</span><br>由 <span class="hljs-number">1</span> 组成的子字符串不比由 <span class="hljs-number">0</span> 组成的子字符串长，故返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> 不是 <code>&#39;0&#39;</code> 就是 <code>&#39;1&#39;</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用 count1，count0 记录连续的数，用 max1、max0 记录最大连续的数，prev 记录上一个数。遍历，计算连续的数的长度并更新 max0、max1。最后判断 max1 是否 max0 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkZeroOnes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count0 = <span class="hljs-number">0</span>,<br>    count1 = <span class="hljs-number">0</span>,<br>    prev = s[<span class="hljs-number">0</span>],<br>    max0 = -<span class="hljs-literal">Infinity</span>,<br>    max1 = -<span class="hljs-literal">Infinity</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (num === prev) &#123;<br>      <span class="hljs-keyword">if</span> (num === <span class="hljs-string">&quot;0&quot;</span>) count0++;<br>      <span class="hljs-keyword">else</span> count1++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (num === <span class="hljs-string">&quot;0&quot;</span>) count0 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> count1 = <span class="hljs-number">1</span>;<br>    &#125;<br>    max0 = <span class="hljs-built_in">Math</span>.max(max0, count0);<br>    max1 = <span class="hljs-built_in">Math</span>.max(max1, count1);<br>    prev = num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max1 &gt; max0;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月2日</title>
    <link href="/2021/06/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%882%E6%97%A5/"/>
    <url>/2021/06/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt476. 数字的补数</p><span id="more"></span><h1 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h1><p>给你一个 <strong>正</strong> 整数 <code>num</code> ，输出它的补数。补数是对该数的二进制表示取反。<br><strong>示例 1：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">5</span> 的二进制表示为 <span class="hljs-number">101</span>（没有前导零位），其补数为 <span class="hljs-number">010</span>。所以你需要输出 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-number">1</span> 的二进制表示为 <span class="hljs-number">1</span>（没有前导零位），其补数为 <span class="hljs-number">0</span>。所以你需要输出 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的整数 <code>num</code> 保证在 32 位带符号整数的范围内。</li><li><code>num &gt;= 1</code></li><li>你可以假定二进制数不包含前导零位。</li><li>本题与 1009 <a href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转为二进制以后，遍历取反返回再转为十进制。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findComplement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(<br>    num<br>      .toString(<span class="hljs-number">2</span>)<br>      .split(<span class="hljs-string">&quot;&quot;</span>)<br>      .map(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> +char ^ <span class="hljs-number">1</span>)<br>      .join(<span class="hljs-string">&quot;&quot;</span>),<br>    <span class="hljs-number">2</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年6月1日</title>
    <link href="/2021/06/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%881%E6%97%A5/"/>
    <url>/2021/06/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B46%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1876. 长度为三且各字符不同的子字符串</p><span id="more"></span><h1 id="1876-长度为三且各字符不同的子字符串"><a href="#1876-长度为三且各字符不同的子字符串" class="headerlink" title="1876. 长度为三且各字符不同的子字符串"></a><a href="https://leetcode-cn.com/problems/substrings-of-size-three-with-distinct-characters/">1876. 长度为三且各字符不同的子字符串</a></h1><p>如果一个字符串不含有任何重复字符，我们称这个字符串为 <strong>好</strong> 字符串。<br>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的 <strong>好子字符串</strong> 的数量。<br>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。<br><strong>子字符串</strong> 是一个字符串中连续的字符序列。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;xyzzaz&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：总共有 <span class="hljs-number">4</span> 个长度为 <span class="hljs-number">3</span> 的子字符串：<span class="hljs-string">&quot;xyz&quot;</span>，<span class="hljs-string">&quot;yzz&quot;</span>，<span class="hljs-string">&quot;zza&quot;</span> 和 <span class="hljs-string">&quot;zaz&quot;</span> 。<br>唯一的长度为 <span class="hljs-number">3</span> 的好子字符串是 <span class="hljs-string">&quot;xyz&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aababcabc&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：总共有 <span class="hljs-number">7</span> 个长度为 <span class="hljs-number">3</span> 的子字符串：<span class="hljs-string">&quot;aab&quot;</span>，<span class="hljs-string">&quot;aba&quot;</span>，<span class="hljs-string">&quot;bab&quot;</span>，<span class="hljs-string">&quot;abc&quot;</span>，<span class="hljs-string">&quot;bca&quot;</span>，<span class="hljs-string">&quot;cab&quot;</span> 和 <span class="hljs-string">&quot;abc&quot;</span> 。<br>好子字符串包括 <span class="hljs-string">&quot;abc&quot;</span>，<span class="hljs-string">&quot;bca&quot;</span>，<span class="hljs-string">&quot;cab&quot;</span> 和 <span class="hljs-string">&quot;abc&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历字符串，截取三位用 set 去重，判断 size 是否等于 3</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countGoodSubstrings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(s.slice(i, i + <span class="hljs-number">3</span>)).size === <span class="hljs-number">3</span>) res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月31日</title>
    <link href="/2021/05/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8831%E6%97%A5/"/>
    <url>/2021/05/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1678. 设计 Goal 解析器</p><span id="more"></span><h1 id="1678-设计-Goal-解析器"><a href="#1678-设计-Goal-解析器" class="headerlink" title="1678. 设计 Goal 解析器"></a><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/">1678. 设计 Goal 解析器</a></h1><p>请你设计一个可以解释字符串 <code>command</code> 的 <strong>Goal 解析器</strong> 。<code>command</code> 由 <code>&quot;G&quot;</code>、<code>&quot;()&quot;</code> 和/或 <code>&quot;(al)&quot;</code> 按某种顺序组成。Goal 解析器会将 <code>&quot;G&quot;</code> 解释为字符串 <code>&quot;G&quot;</code>、<code>&quot;()&quot;</code> 解释为字符串 <code>&quot;o&quot;</code> ，<code>&quot;(al)&quot;</code> 解释为字符串 <code>&quot;al&quot;</code> 。然后，按原顺序将经解释得到的字符串连接成一个字符串。<br>给你字符串 <code>command</code> ，返回_ <em>\</em>*Goal<em>\</em>* <strong>_解析器  **对_ _<code>command</code> 的解释结果。<br>**示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：command = <span class="hljs-string">&quot;G()(al)&quot;</span><br>输出：<span class="hljs-string">&quot;Goal&quot;</span><br>解释：Goal 解析器解释命令的步骤如下所示：<br>G -&gt; G<br><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> o<br><span class="hljs-function"><span class="hljs-params">(al)</span> -&gt;</span> al<br>最后连接得到的结果是 <span class="hljs-string">&quot;Goal&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">command</span> = <span class="hljs-string">&quot;G()()()()(al)&quot;</span><br>输出：<span class="hljs-string">&quot;Gooooal&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">command</span> = <span class="hljs-string">&quot;(al)G(al)()()G&quot;</span><br>输出：<span class="hljs-string">&quot;alGalooG&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= command.length &lt;= 100</code></li><li><code>command</code> 由 <code>&quot;G&quot;</code>、<code>&quot;()&quot;</code> 和/或 <code>&quot;(al)&quot;</code> 按某种顺序组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意遍历字符串，替换对应字符即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">command</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> interpret = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) </span>&#123;<br>  command = command.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; command.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> char = command[i],<br>      nextChar = command[i + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;G&quot;</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;(&quot;</span> &amp;&amp; nextChar === <span class="hljs-string">&quot;)&quot;</span>) &#123;<br>      command.splice(i, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;o&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      command.splice(i, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;al&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> command.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月30日</title>
    <link href="/2021/05/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8830%E6%97%A5/"/>
    <url>/2021/05/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1880. 检查某单词是否等于两单词之和</p><span id="more"></span><h1 id="1880-检查某单词是否等于两单词之和"><a href="#1880-检查某单词是否等于两单词之和" class="headerlink" title="1880. 检查某单词是否等于两单词之和"></a><a href="https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words/">1880. 检查某单词是否等于两单词之和</a></h1><p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>&#39;a&#39; -&gt; 0</code>、<code>&#39;b&#39; -&gt; 1</code>、<code>&#39;c&#39; -&gt; 2</code>，以此类推。<br>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p><ul><li>例如，<code>s = &quot;acb&quot;</code> ，依次连接每个字母的字母值可以得到 <code>&quot;021&quot;</code> ，转换为整数得到 <code>21</code> 。</li></ul><p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>&#39;a&#39;</code> 到 <code>&#39;j&#39;</code> （<strong>含  *<em><code>&#39;a&#39;</code> 和 <code>&#39;j&#39;</code>\</em>* **）的小写英文字母组成。<br>如果 <code>firstWord</code>_ <em>和</em> _<code>secondWord</code> 的 **数值之和</strong> 等于_ <em><code>targetWord</code></em> <em>的数值，返回 <code>true</code> ；否则，返回</em> <em><code>false</code></em> _。<br>*<em>示例 1：\</em>*</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入：firstWord = <span class="hljs-string">&quot;acb&quot;</span>, secondWord = <span class="hljs-string">&quot;cba&quot;</span>, targetWord = <span class="hljs-string">&quot;cdb&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：<br>firstWord 的数值为 <span class="hljs-string">&quot;acb&quot;</span> -&gt; <span class="hljs-string">&quot;021&quot;</span> -&gt; <span class="hljs-number">21</span><br>secondWord 的数值为 <span class="hljs-string">&quot;cba&quot;</span> -&gt; <span class="hljs-string">&quot;210&quot;</span> -&gt; <span class="hljs-number">210</span><br>targetWord 的数值为 <span class="hljs-string">&quot;cdb&quot;</span> -&gt; <span class="hljs-string">&quot;231&quot;</span> -&gt; <span class="hljs-number">231</span><br>由于 <span class="hljs-number">21</span> + <span class="hljs-number">210</span> == <span class="hljs-number">231</span> ，返回 <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入：firstWord = <span class="hljs-string">&quot;aaa&quot;</span>, secondWord = <span class="hljs-string">&quot;a&quot;</span>, targetWord = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-keyword">false</span><br>解释：<br>firstWord 的数值为 <span class="hljs-string">&quot;aaa&quot;</span> -&gt; <span class="hljs-string">&quot;000&quot;</span> -&gt; 0<br>secondWord 的数值为 <span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-string">&quot;0&quot;</span> -&gt; 0<br>targetWord 的数值为 <span class="hljs-string">&quot;aab&quot;</span> -&gt; <span class="hljs-string">&quot;001&quot;</span> -&gt; <span class="hljs-number">1</span><br>由于 0 + 0 != <span class="hljs-number">1</span> ，返回 <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入：firstWord = <span class="hljs-string">&quot;aaa&quot;</span>, secondWord = <span class="hljs-string">&quot;a&quot;</span>, targetWord = <span class="hljs-string">&quot;aaaa&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：<br>firstWord 的数值为 <span class="hljs-string">&quot;aaa&quot;</span> -&gt; <span class="hljs-string">&quot;000&quot;</span> -&gt; 0<br>secondWord 的数值为 <span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-string">&quot;0&quot;</span> -&gt; 0<br>targetWord 的数值为 <span class="hljs-string">&quot;aaaa&quot;</span> -&gt; <span class="hljs-string">&quot;0000&quot;</span> -&gt; 0<br>由于 0 + 0 == 0 ，返回 <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= firstWord.length, ``secondWord.length, ``targetWord.length &lt;= 8</code></li><li><code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> 仅由从 <code>&#39;a&#39;</code> 到 <code>&#39;j&#39;</code> （<strong>含  *<em><code>&#39;a&#39;</code> 和 <code>&#39;j&#39;</code>\</em>* **）的小写英文字母组成</strong>。**</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字母转为数字，再判断相加和是否与 target 相同</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">firstWord</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">secondWord</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">targetWord</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSumEqual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">firstWord, secondWord, targetWord</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getNum = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>      res += char.charCodeAt() - <span class="hljs-number">97</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> +res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> getNum(firstWord) + getNum(secondWord) === getNum(targetWord);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月29日</title>
    <link href="/2021/05/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8829%E6%97%A5/"/>
    <url>/2021/05/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1380. 矩阵中的幸运数</p><span id="more"></span><h1 id="1380-矩阵中的幸运数"><a href="#1380-矩阵中的幸运数" class="headerlink" title="1380. 矩阵中的幸运数"></a><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">1380. 矩阵中的幸运数</a></h1><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。<br>幸运数是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[3,7,8]</span>,<span class="hljs-comment">[9,11,13]</span>,<span class="hljs-comment">[15,16,17]</span>]</span><br>输出：<span class="hljs-comment">[15]</span><br>解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,10,4,2]</span>,<span class="hljs-comment">[9,3,8,7]</span>,<span class="hljs-comment">[15,16,17,12]</span>]</span><br>输出：<span class="hljs-comment">[12]</span><br>解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[7,8],[1,2]]</span><br>输出：[<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= n, m &lt;= 50</code></li><li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li><li>矩阵中的所有元素都是不同的</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找到当前行的最小值，再判断这个数字是不是所在列的最大值，是的话加入结果数组中，最后返回</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> luckyNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> min = <span class="hljs-literal">Infinity</span>;<br>    <span class="hljs-keyword">let</span> index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (matrix[i][j] &lt; min) &#123;<br>        index = j;<br>        min = matrix[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> check = matrix.every(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> matrix[i][index] &gt;= row[index];<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (check) res.push(matrix[i][index]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月28日</title>
    <link href="/2021/05/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/05/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt872. 叶子相似的树</p><span id="more"></span><h1 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h1><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 **叶值序列  **。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1622204029444-0b8b4398-5d78-42e7-88ea-3da33c254e38.png#align=left&display=inline&height=252&margin=%5Bobject%20Object%5D&originHeight=617&originWidth=735&size=0&status=done&style=none&width=300"><br>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。<br>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似  *的。<br>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1622204029201-172804ba-43f8-420c-9651-e03ab75c4624.jpeg#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=1122&size=0&status=done&style=none&width=750"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1622204029243-3bbb813c-8a0f-4cb7-be7b-874ea2f1cb36.jpeg#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=552&size=0&status=done&style=none&width=450"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的两棵树可能会有 <code>1</code> 到 <code>200</code> 个结点。</li><li>给定的两棵树上的值介于 <code>0</code> 到 <code>200</code> 之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>后序遍历得到叶子节点数组，逐一比较是否相同即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> totalMoney = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>];<br>  <span class="hljs-keyword">let</span> week = <span class="hljs-built_in">Math</span>.ceil(n / <span class="hljs-number">7</span>);<br>  <span class="hljs-keyword">const</span> day = n % <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">if</span> (day === <span class="hljs-number">0</span>) week++;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-number">28</span> * (week - <span class="hljs-number">1</span>) +<br>    ((week - <span class="hljs-number">1</span>) * (week - <span class="hljs-number">2</span>) * <span class="hljs-number">7</span>) / <span class="hljs-number">2</span> +<br>    (day &gt;= <span class="hljs-number">1</span> ? set[day - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) +<br>    day * (week - <span class="hljs-number">1</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月27日</title>
    <link href="/2021/05/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/05/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1716. 计算力扣银行的钱</p><span id="more"></span><h1 id="1716-计算力扣银行的钱"><a href="#1716-计算力扣银行的钱" class="headerlink" title="1716. 计算力扣银行的钱"></a><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">1716. 计算力扣银行的钱</a></h1><p>Hercy 想要为购买第一辆车存钱。他 <strong>每天</strong> 都往力扣银行里存钱。<br>最开始，他在周一的时候存入 <code>1</code> 块钱。从周二到周日，他每天都比前一天多存入 <code>1</code> 块钱。在接下来每一个周一，他都会比 <strong>前一个周一</strong> 多存入 <code>1</code> 块钱。<br>给你 <code>n</code> ，请你返回在第 <code>n</code> 天结束的时候他在力扣银行总共存了多少块钱。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：10<br>解释：第<span class="hljs-number"> 4 </span>天后，总额为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 10<br>输出：37<br>解释：第<span class="hljs-number"> 10 </span>天后，总额为 (1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+ 7) + (2 +<span class="hljs-number"> 3 </span>+ 4) =<span class="hljs-number"> 37 </span>。注意到第二个星期一，Hercy 存入<span class="hljs-number"> 2 </span>块钱。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 20<br>输出：96<br>解释：第<span class="hljs-number"> 20 </span>天后，总额为 (1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+ 7) + (2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 7 </span>+ 8) + (3 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 7 </span>+ 8) =<span class="hljs-number"> 96 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[6]</span><br>输出：<span class="hljs-comment">[6]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>推出公式：如 20，week = 2，day = 6，计算方法为，（28 + 0 + 28 + 7）+ 21 + 6 * 2。第一周 28 天，第二周 28+7 天，第三周 28+14 天，第 n 周 28+(n-1)*7 天，所以是一个首项为 21，公差为 7 的等差数列，求和公式为 28 _ (week - 1) + ((week - 1) _ (week - 2) _ 7) / 2。当 day===0 时，week 加一周，然后求完和之后，求剩余天的天数，先从 set 中拿到对应的原始元数，再根据当前是第几周，判断应该加上几元，如当前是第三周，需要加上 每天都需要 (3-1) 元，总共加了 6 _ 2 元。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> totalMoney = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>];<br>  <span class="hljs-keyword">let</span> week = <span class="hljs-built_in">Math</span>.ceil(n / <span class="hljs-number">7</span>);<br>  <span class="hljs-keyword">const</span> day = n % <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">if</span> (day === <span class="hljs-number">0</span>) week++;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-number">28</span> * (week - <span class="hljs-number">1</span>) +<br>    ((week - <span class="hljs-number">1</span>) * (week - <span class="hljs-number">2</span>) * <span class="hljs-number">7</span>) / <span class="hljs-number">2</span> +<br>    (day &gt;= <span class="hljs-number">1</span> ? set[day - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) +<br>    day * (week - <span class="hljs-number">1</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月26日</title>
    <link href="/2021/05/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/05/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1403. 非递增顺序的最小子序列</p><span id="more"></span><h1 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a><a href="https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order/">1403. 非递增顺序的最小子序列</a></h1><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。<br>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。<br>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。<br><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,3,10,9,8]</span><br>输出：<span class="hljs-comment">[10,9]</span><br>解释：子序列 <span class="hljs-comment">[10,9]</span> 和 <span class="hljs-comment">[10,8]</span> 是最小的、满足元素之和大于其他各元素之和的子序列。但是 <span class="hljs-comment">[10,9]</span> 的元素之和最大。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,4,7,6,7]</span><br>输出：<span class="hljs-comment">[7,7,6]</span><br>解释：子序列 <span class="hljs-comment">[7,7]</span> 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，<span class="hljs-comment">[7,6,7]</span> 是满足题意的最小子序列。注意，元素按非递增顺序返回。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[6]</span><br>输出：<span class="hljs-comment">[6]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按降序排序，求和，从最后一位开始计数，当当前比总和一半来得大的时候，截取当前下标到头的数组返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minSubsequence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<br>  <span class="hljs-keyword">const</span> sum = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    temp += nums[i];<br>    <span class="hljs-keyword">if</span> (temp &gt;= sum / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.splice(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月25日</title>
    <link href="/2021/05/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/05/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1779. 找到最近的有相同 X 或 Y 坐标的点</p><span id="more"></span><h1 id="1779-找到最近的有相同-X-或-Y-坐标的点"><a href="#1779-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="1779. 找到最近的有相同 X 或 Y 坐标的点"></a><a href="https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/">1779. 找到最近的有相同 X 或 Y 坐标的点</a></h1><p>给你两个整数 <code>x</code> 和 <code>y</code> ，表示你在一个笛卡尔坐标系下的 <code>(x, y)</code> 处。同时，在同一个坐标系下给你一个数组 <code>points</code> ，其中 <code>points[i] = [a, b]</code> 表示在 <code>(a, b)</code> 处有一个点。当一个点与你所在的位置有相同的 x 坐标或者相同的 y 坐标时，我们称这个点是 <strong>有效的</strong> 。<br>请返回距离你当前位置 <strong>曼哈顿距离</strong> 最近的 <strong>有效</strong> 点的下标（下标从 <strong>0</strong> 开始）。如果有多个最近的有效点，请返回下标 <strong>最小</strong> 的一个。如果没有有效点，请返回 <code>-1</code> 。<br>两个点 <code>(x, y)</code> 和 <code>(x, y)</code> 之间的 <strong>曼哈顿距离</strong> 为 <code>abs(x - x) + abs(y - y)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：x = 3, y = 4, points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,1]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[4,4]</span>]</span><br>输出：2<br>解释：所有点中，<span class="hljs-comment">[3,1]</span>，<span class="hljs-comment">[2,4]</span> 和 <span class="hljs-comment">[4,4]</span> 是有效点。有效点中，<span class="hljs-comment">[2,4]</span> 和 <span class="hljs-comment">[4,4]</span> 距离你当前位置的曼哈顿距离最小，都为 1 。<span class="hljs-comment">[2,4]</span> 的下标最小，所以返回 2 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：x = <span class="hljs-number">3</span>, y = <span class="hljs-number">4</span>, points = <span class="hljs-string">[[3,4]]</span><br>输出：<span class="hljs-number">0</span><br>提示：答案可以与你当前所在位置坐标相同。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：x = <span class="hljs-number">3</span>, y = <span class="hljs-number">4</span>, points = <span class="hljs-string">[[2,3]]</span><br>输出：<span class="hljs-number">-1</span><br>解释：没有有效点。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 10</code></li><li><code>points[i].length == 2</code></li><li><code>1 &lt;= x, y, a, b &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，用一个 min 记录最小曼哈顿距离，当当前为有效点切曼哈顿距离比最小距离小，则更新 res 为对应下标和最小距离。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">y</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">points</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nearestValidPoint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, points</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-literal">Infinity</span>,<br>    res = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; points.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> [x1, y1] = points[i];<br>    <span class="hljs-keyword">if</span> (x1 !== x &amp;&amp; y1 !== y) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.abs(x - x1) + <span class="hljs-built_in">Math</span>.abs(y - y1);<br>    <span class="hljs-keyword">if</span> (min &lt;= length) <span class="hljs-keyword">continue</span>;<br>    min = length;<br>    res = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月24日</title>
    <link href="/2021/05/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/05/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1800. 最大升序子数组和</p><span id="more"></span><h1 id="1800-最大升序子数组和"><a href="#1800-最大升序子数组和" class="headerlink" title="1800. 最大升序子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/">1800. 最大升序子数组和</a></h1><p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序  **子数组的最大可能元素和。<br>子数组是数组中的一个连续数字序列。<br>已知子数组 <code>[nums, nums, ..., nums, nums]</code> ，若对所有 <code>i</code>（<code>l &lt;= i &lt; r</code>），<code>nums&lt; nums</code> 都成立，则称这一子数组为 **升序</strong> 子数组。注意，大小为 <code>1</code> 的子数组也视作 <strong>升序</strong> 子数组。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,20,30,5,10,50]</span><br>输出：65<br>解释：<span class="hljs-comment">[5,10,50]</span> 是元素和最大的升序子数组，最大元素和为 65 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[10,20,30,40,50]</span><br>输出：<span class="hljs-number">150</span><br>解释：<span class="hljs-string">[10,20,30,40,50]</span> 是元素和最大的升序子数组，最大元素和为 <span class="hljs-number">150</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[12,17,15,13,10,11,12]</span><br>输出：33<br>解释：<span class="hljs-comment">[10,11,12]</span> 是元素和最大的升序子数组，最大元素和为 33 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">100,10,1</span>]<br>输出：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><p>将字符串和 0101 或 101010…进行比较，把每一位不同的计数记录下来，取小的那一个返回</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，用 prev 记录前一个数，判断当前是否还在一个升序子数组内，temp 记录当前子数组的和。遍历时当当前数字小于等于前一个数字时，更新最大的子数组和。最后返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxAscendingSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>,<br>    prev,<br>    temp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (prev) &#123;<br>      <span class="hljs-keyword">if</span> (num &lt;= prev) &#123;<br>        max = <span class="hljs-built_in">Math</span>.max(max, temp);<br>        temp = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>    prev = num;<br>    temp += num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(max, temp);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月23日</title>
    <link href="/2021/05/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/05/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1582. 二进制矩阵中的特殊位置</p><span id="more"></span><h1 id="1582-二进制矩阵中的特殊位置"><a href="#1582-二进制矩阵中的特殊位置" class="headerlink" title="1582. 二进制矩阵中的特殊位置"></a><a href="https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/">1582. 二进制矩阵中的特殊位置</a></h1><p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code>，请返回 <strong>矩阵 <em><code>mat</code></em> 中特殊位置的数目</strong> 。<br><strong>特殊位置</strong> 定义：如果 <code>mat[i][j] == 1</code> 并且第 <code>i</code> 行和第 <code>j</code> 列中的所有其他元素均为 <code>0</code>（行和列的下标均 <strong>从 0 开始</strong> ），则位置 <code>(i, j)</code> 被称为特殊位置。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat = <span class="hljs-comment">[<span class="hljs-comment">[1,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,0,1]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,0,0]</span>]</span><br>输出：1<br>解释：(1,2) 是一个特殊位置，因为 mat<span class="hljs-comment">[1]</span><span class="hljs-comment">[2]</span> == 1 且所处的行和列上所有其他元素都是 0<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：mat = <span class="hljs-string">[[1,0,0],</span><br><span class="hljs-string">            [0,1,0],</span><br><span class="hljs-string">            [0,0,1]]</span><br>输出：<span class="hljs-number">3</span><br>解释：(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) 和 (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) 都是特殊位置<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat = <span class="hljs-comment">[<span class="hljs-comment">[0,0,0,1]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,0,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,1,1,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,0,0,0]</span>]</span><br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat = <span class="hljs-comment">[<span class="hljs-comment">[0,0,0,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,0,0,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,1,0,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,0,1,0,0]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[0,0,0,1,1]</span>]</span><br>输出：3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == mat.length</code></li><li><code>cols == mat[i].length</code></li><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一次遍历统计每行每列 1 的个数，第二次遍历，判断当前行列 1 个数相加是否为 2 进行计数，大于 2 说明还有其他行或列有 1</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">mat</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> numSpecial = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mat</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arrRow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(mat.length).fill(<span class="hljs-number">0</span>),<br>    arrCol = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(mat[<span class="hljs-number">0</span>].length).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">const</span> item = mat[i][j];<br>      <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span>) &#123;<br>        arrRow[i] += item;<br>        arrCol[j] += item;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">const</span> item = mat[i][j];<br>      <span class="hljs-keyword">if</span> (item === <span class="hljs-number">1</span> &amp;&amp; arrRow[i] + arrCol[j] === <span class="hljs-number">2</span>) res++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月22日</title>
    <link href="/2021/05/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/05/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1758. 生成交替二进制字符串的最少操作数</p><span id="more"></span><h1 id="1758-生成交替二进制字符串的最少操作数"><a href="#1758-生成交替二进制字符串的最少操作数" class="headerlink" title="1758. 生成交替二进制字符串的最少操作数"></a><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">1758. 生成交替二进制字符串的最少操作数</a></h1><p>给你一个仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code> ，或者将 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code> 。<br><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code> 是交替字符串，而字符串 <code>&quot;0100&quot;</code> 不是。<br>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;0100&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：如果将最后一个字符变为 &#x27;1&#x27; ，s 就变成 <span class="hljs-string">&quot;0101&quot;</span> ，即符合交替字符串定义。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;10&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：s 已经是交替字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：需要 <span class="hljs-number">2</span> 步操作得到 <span class="hljs-string">&quot;0101&quot;</span> 或 <span class="hljs-string">&quot;1010&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字符串和 0101 或 101010…进行比较，把每一位不同的计数记录下来，取小的那一个返回</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minOperations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count1 = <span class="hljs-number">0</span>,<br>    count2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> char = s[i],<br>      char1 = i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>      char2 = i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>;<br>    <span class="hljs-keyword">if</span> (char === char1) count1++;<br>    <span class="hljs-keyword">if</span> (char === char2) count2++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(count1, count2);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月21日</title>
    <link href="/2021/05/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/05/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1812. 判断国际象棋棋盘中一个格子的颜色</p><span id="more"></span><h1 id="1812-判断国际象棋棋盘中一个格子的颜色"><a href="#1812-判断国际象棋棋盘中一个格子的颜色" class="headerlink" title="1812. 判断国际象棋棋盘中一个格子的颜色"></a><a href="https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square/">1812. 判断国际象棋棋盘中一个格子的颜色</a></h1><p>给你一个坐标 <code>coordinates</code> ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1621597007962-23f2ced9-69d7-4595-8b8f-b54f12b7c465.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=882&originWidth=890&size=0&status=done&style=none&width=400"><br>如果所给格子的颜色是白色，请你返回 <code>true</code>，如果是黑色，请返回 <code>false</code> 。<br>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coordinates</span> = <span class="hljs-string">&quot;a1&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：如上图棋盘所示，<span class="hljs-string">&quot;a1&quot;</span> 坐标的格子是黑色的，所以返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coordinates</span> = <span class="hljs-string">&quot;h3&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：如上图棋盘所示，<span class="hljs-string">&quot;h3&quot;</span> 坐标的格子是白色的，所以返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coordinates</span> = <span class="hljs-string">&quot;c7&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>coordinates.length == 2</code></li><li><code>&#39;a&#39; &lt;= coordinates[0] &lt;= &#39;h&#39;</code></li><li><code>&#39;1&#39; &lt;= coordinates[1] &lt;= &#39;8&#39;</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字母转为 asc 码，可以观察到规律，当两位一个为奇数一个为偶数时为白格，返回 true。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">coordinates</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> squareIsWhite = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">coordinates</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (coordinates[<span class="hljs-number">0</span>].charCodeAt() % <span class="hljs-number">2</span>) + (+coordinates[<span class="hljs-number">1</span>] % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月20日</title>
    <link href="/2021/05/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/05/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1863. 找出所有子集的异或总和再求和</p><span id="more"></span><h1 id="1863-找出所有子集的异或总和再求和"><a href="#1863-找出所有子集的异或总和再求和" class="headerlink" title="1863. 找出所有子集的异或总和再求和"></a><a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/">1863. 找出所有子集的异或总和再求和</a></h1><p>一个数组的**  异或总和** 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p><ul><li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li></ul><p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。<br><strong>注意：</strong>在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。<br>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3]<br>输出：6<br>解释：[1,3] 共有<span class="hljs-number"> 4 </span>个子集：<br>- 空子集的异或总和是<span class="hljs-number"> 0 </span>。<br>- [1] 的异或总和为<span class="hljs-number"> 1 </span>。<br>- [3] 的异或总和为<span class="hljs-number"> 3 </span>。<br>- [1,3] 的异或总和为<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 2 </span>。<br>0 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>= 6<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [5,1,6]<br>输出：28<br>解释：[5,1,6] 共有<span class="hljs-number"> 8 </span>个子集：<br>- 空子集的异或总和是<span class="hljs-number"> 0 </span>。<br>- [5] 的异或总和为<span class="hljs-number"> 5 </span>。<br>- [1] 的异或总和为<span class="hljs-number"> 1 </span>。<br>- [6] 的异或总和为<span class="hljs-number"> 6 </span>。<br>- [5,1] 的异或总和为<span class="hljs-number"> 5 </span>XOR<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>- [5,6] 的异或总和为<span class="hljs-number"> 5 </span>XOR<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 3 </span>。<br>- [1,6] 的异或总和为<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 7 </span>。<br>- [5,1,6] 的异或总和为<span class="hljs-number"> 5 </span>XOR<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 2 </span>。<br>0 +<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 2 </span>= 28<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,6,7,8]</span><br>输出：<span class="hljs-number">480</span><br>解释：每个子集的全部异或总和值之和为 <span class="hljs-number">480</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 12</code></li><li><code>1 &lt;= nums[i] &lt;= 20</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法求组合，求完每个组合后对 sum 进行已异或计算，同时 sum 累加，最后放回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subsetXORSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      temp.push(arr[i]);<br>      dfs(arr.slice(i + <span class="hljs-number">1</span>));<br>      sum += temp.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a ^ b);<br>      temp.pop();<br>    &#125;<br>  &#125;;<br>  dfs(nums);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月19日</title>
    <link href="/2021/05/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/05/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1859. 将句子排序</p><span id="more"></span><h1 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672. 最富有客户的资产总量"></a><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">1672. 最富有客户的资产总量</a></h1><p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。<br>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：accounts = [[1,2,3],[3,2,1]]<br>输出：6<br>解释：<br>第<span class="hljs-number"> 1 </span>位客户的资产总量 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>= 6<br>第<span class="hljs-number"> 2 </span>位客户的资产总量 =<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 6<br>两位客户都是最富有的，资产总量都是<span class="hljs-number"> 6 </span>，所以返回<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：accounts = <span class="hljs-string">[[1,5],[7,3],[3,5]]</span><br>输出：<span class="hljs-number">10</span><br>解释：<br>第 <span class="hljs-number">1</span> 位客户的资产总量 = <span class="hljs-number">6</span><br>第 <span class="hljs-number">2</span> 位客户的资产总量 = <span class="hljs-number">10</span><br>第 <span class="hljs-number">3</span> 位客户的资产总量 = <span class="hljs-number">8</span><br>第 <span class="hljs-number">2</span> 位客户是最富有的，资产总量是 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：accounts = <span class="hljs-string">[[2,8,7],[7,1,3],[1,9,5]]</span><br>输出：<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == accounts.length</code></li><li><code>n == accounts[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意遍历每行并求和更新 max，最后返回 max 即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">accounts</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximumWealth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accounts</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> account <span class="hljs-keyword">of</span> accounts) &#123;<br>    max = <span class="hljs-built_in">Math</span>.max(<br>      max,<br>      account.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b)<br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月18日</title>
    <link href="/2021/05/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/05/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1859. 将句子排序</p><span id="more"></span><h1 id="1859-将句子排序"><a href="#1859-将句子排序" class="headerlink" title="1859. 将句子排序"></a><a href="https://leetcode-cn.com/problems/sorting-the-sentence/">1859. 将句子排序</a></h1><p>一个 <strong>句子</strong> 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。<br>我们可以给一个句子添加 <strong>从 1 开始的单词位置索引  **，并且将句子中所有单词 **打乱顺序</strong> 。</p><ul><li>比方说，句子 <code>&quot;This is a sentence&quot;</code> 可以被打乱顺序得到 <code>&quot;sentence4 a3 is2 This1&quot;</code> 或者 <code>&quot;is2 sentence4 This1 a3&quot;</code> 。</li></ul><p>给你一个 <strong>打乱顺序</strong> 的句子 <code>s</code> ，它包含的单词不超过 <code>9</code> 个，请你重新构造并得到原本顺序的句子。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;is2 sentence4 This1 a3&quot;</span><br>输出：<span class="hljs-string">&quot;This is a sentence&quot;</span><br>解释：将 s 中的单词按照初始位置排序，得到 <span class="hljs-string">&quot;This1 is2 a3 sentence4&quot;</span> ，然后删除数字。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;Myself2 Me1 I4 and3&quot;</span><br>输出：<span class="hljs-string">&quot;Me Myself and I&quot;</span><br>解释：将 s 中的单词按照初始位置排序，得到 <span class="hljs-string">&quot;Me1 Myself2 and3 I4&quot;</span> ，然后删除数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 只包含小写和大写英文字母、空格以及从 <code>1</code> 到 <code>9</code> 的数字。</li><li><code>s</code> 中单词数目为 <code>1</code> 到 <code>9</code> 个。</li><li><code>s</code> 中的单词由单个空格分隔。</li><li><code>s</code> 不包含任何前导或者后缀空格。</li></ul><p>通过次数 3,162<br>提交次数 3,890</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意，按最后一位数排序，然后再遍历把每个单词最后一位删除即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortSentence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>  s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[a.length - <span class="hljs-number">1</span>] - b[b.length - <span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">return</span> s.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)).join(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月17日</title>
    <link href="/2021/05/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/05/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1773. 统计匹配检索规则的物品数量</p><span id="more"></span><h1 id="1773-统计匹配检索规则的物品数量"><a href="#1773-统计匹配检索规则的物品数量" class="headerlink" title="1773. 统计匹配检索规则的物品数量"></a><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/">1773. 统计匹配检索规则的物品数量</a></h1><p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [type, color, name]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。<br>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。<br>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 <strong>匹配</strong> ：</p><ul><li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == type</code> 。</li><li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == color</code> 。</li><li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == name</code> 。</li></ul><p>统计并返回 <strong>匹配检索规则的物品数量</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：items = [[<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;pixel&quot;</span>],[<span class="hljs-string">&quot;computer&quot;</span>,<span class="hljs-string">&quot;silver&quot;</span>,<span class="hljs-string">&quot;lenovo&quot;</span>],[<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;gold&quot;</span>,<span class="hljs-string">&quot;iphone&quot;</span>]], ruleKey = <span class="hljs-string">&quot;color&quot;</span>, ruleValue = <span class="hljs-string">&quot;silver&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：只有一件物品匹配检索规则，这件物品是 [<span class="hljs-string">&quot;computer&quot;</span>,<span class="hljs-string">&quot;silver&quot;</span>,<span class="hljs-string">&quot;lenovo&quot;</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：items = [[<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;pixel&quot;</span>],[<span class="hljs-string">&quot;computer&quot;</span>,<span class="hljs-string">&quot;silver&quot;</span>,<span class="hljs-string">&quot;phone&quot;</span>],[<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;gold&quot;</span>,<span class="hljs-string">&quot;iphone&quot;</span>]], ruleKey = <span class="hljs-string">&quot;type&quot;</span>, ruleValue = <span class="hljs-string">&quot;phone&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：只有两件物品匹配检索规则，这两件物品分别是 [<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;pixel&quot;</span>] 和 [<span class="hljs-string">&quot;phone&quot;</span>,<span class="hljs-string">&quot;gold&quot;</span>,<span class="hljs-string">&quot;iphone&quot;</span>] 。注意，[<span class="hljs-string">&quot;computer&quot;</span>,<span class="hljs-string">&quot;silver&quot;</span>,<span class="hljs-string">&quot;phone&quot;</span>] 未匹配检索规则。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= items.length &lt;= 10</code></li><li><code>1 &lt;= type.length, color.length, name.length, ruleValue.length &lt;= 10</code></li><li><code>ruleKey</code> 等于 <code>&quot;type&quot;</code>、<code>&quot;color&quot;</code> 或 <code>&quot;name&quot;</code></li><li>所有字符串仅由小写字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意，根据 ruleKey 决定下标值，然后遍历数组判断值是否相等计数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[][]&#125;</span> <span class="hljs-variable">items</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">ruleKey</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">ruleValue</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countMatches = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, ruleKey, ruleValue</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> index,<br>    res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (ruleKey === <span class="hljs-string">&quot;type&quot;</span>) index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ruleKey === <span class="hljs-string">&quot;color&quot;</span>) index = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> index = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> items) &#123;<br>    <span class="hljs-keyword">if</span> (item[index] === ruleValue) res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月16日</title>
    <link href="/2021/05/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/05/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1266. 访问所有点的最小时间</p><span id="more"></span><h1 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">1266. 访问所有点的最小时间</a></h1><p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [x, y]</code> 。请你计算访问所有这些点需要的 <strong>最小时间</strong>（以秒为单位）。<br>你需要按照下面的规则在平面上移动：</p><ul><li>每一秒内，你可以：<ul><li>沿水平方向移动一个单位长度，或者</li><li>沿竖直方向移动一个单位长度，或者</li><li>跨过对角线移动 <code>sqrt(2)</code> 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li></ul></li><li>必须按照数组中出现的顺序来访问这些点。</li><li>在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。</li></ul><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1621144796293-da955fbe-72eb-4e33-a75d-7f697d8b7fe3.png#align=left&display=inline&height=428&margin=%5Bobject%20Object%5D&originHeight=585&originWidth=684&size=0&status=done&style=none&width=500"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[-1,0]</span>]</span><br>输出：7<br>解释：一条最佳的访问路径是： <span class="hljs-comment">[1,1]</span> -&gt; <span class="hljs-comment">[2,2]</span> -&gt; <span class="hljs-comment">[3,3]</span> -&gt; <span class="hljs-comment">[3,4]</span> -&gt; <span class="hljs-comment">[2,3]</span> -&gt; <span class="hljs-comment">[1,2]</span> -&gt; <span class="hljs-comment">[0,1]</span> -&gt; <span class="hljs-comment">[-1,0]</span><br>从 <span class="hljs-comment">[1,1]</span> 到 <span class="hljs-comment">[3,4]</span> 需要 3 秒<br>从 <span class="hljs-comment">[3,4]</span> 到 <span class="hljs-comment">[-1,0]</span> 需要 4 秒<br>一共需要 7 秒<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[3,2],[-2,2]]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>points.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>points[i].length == 2</code></li><li><code>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为对角线移动的时间也为 1s，所以本题其实就是求两个点，x 或者 y 的绝对值的最大值。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">points</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minTimeToVisitAllPoints = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">points</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> [x1, y1] = points[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> [x2, y2] = points[i];<br>    sum += <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.abs(x1 - x2), <span class="hljs-built_in">Math</span>.abs(y1 - y2));<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月15日</title>
    <link href="/2021/05/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/05/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1608. 特殊数组的特征值</p><span id="more"></span><h1 id="1608-特殊数组的特征值"><a href="#1608-特殊数组的特征值" class="headerlink" title="1608. 特殊数组的特征值"></a><a href="https://leetcode-cn.com/problems/special-array-with-x-elements-greater-than-or-equal-x/">1608. 特殊数组的特征值</a></h1><p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 <strong>大于或者等于</strong> <code>x</code> ，那么就称 <code>nums</code> 是一个 <strong>特殊数组</strong> ，而 <code>x</code> 是该数组的 <strong>特征值</strong> 。<br>注意： <code>x</code> <strong>不必</strong> 是 <code>nums</code> 的中的元素。<br>如果数组 <code>nums</code> 是一个 <strong>特殊数组</strong> ，请返回它的特征值 <code>x</code> 。否则，返回_ _<code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 <strong>唯一的</strong> 。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,5]<br>输出：2<br>解释：有<span class="hljs-number"> 2 </span>个元素（3 和 5）大于或等于<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">-1</span><br>解释：没有满足题目要求的特殊数组，故而也不存在特征值 <span class="hljs-keyword">x</span> 。<br>如果 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>，应该有 <span class="hljs-number">0</span> 个元素 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>，但实际有 <span class="hljs-number">2</span> 个。<br>如果 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>，应该有 <span class="hljs-number">1</span> 个元素 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>，但实际有 <span class="hljs-number">0</span> 个。<br>如果 <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>，应该有 <span class="hljs-number">2</span> 个元素 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>，但实际有 <span class="hljs-number">0</span> 个。<br><span class="hljs-keyword">x</span> 不能取更大的值，因为 nums 中只有两个元素。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,4,3,0,4]<br>输出：3<br>解释：有<span class="hljs-number"> 3 </span>个元素大于或等于<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,6,7,7,0]</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>桶计数方法，倒序遍历，用 sum 计算大于当前数的个数之和，当 sum 和下标 i 相同时，说明刚好有 i 个元素大于或等于 i，返回当前 i。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> specialArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max(...nums);<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(max).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (arr[num]) arr[num]++;<br>    <span class="hljs-keyword">else</span> arr[num] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = max; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sum += arr[i];<br>    <span class="hljs-keyword">if</span> (sum === i) &#123;<br>      res = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月14日</title>
    <link href="/2021/05/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/05/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1260. 二维网格迁移</p><span id="more"></span><h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。<br>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1620997819515-ea6a48e4-467a-4244-867a-0f315748a7ad.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=654&size=0&status=done&style=none&width=400"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[9,1,2],[3,4,5],[6,7,8]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1620997819509-c15df726-32f9-4720-b495-939968d9a4a4.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=624&size=0&status=done&style=none&width=400"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[3,8,1,9]</span>,<span class="hljs-comment">[19,7,2,5]</span>,<span class="hljs-comment">[4,6,11,10]</span>,<span class="hljs-comment">[12,0,21,13]</span>]</span>, k = 4<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[12,0,21,13]</span>,<span class="hljs-comment">[3,8,1,9]</span>,<span class="hljs-comment">[19,7,2,5]</span>,<span class="hljs-comment">[4,6,11,10]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span>, k = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 50</code></li><li><code>1 &lt;= n &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>扁平化以后移动拼接数组，然后再重新划分</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> shiftGrid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid, k</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> rowNum = grid[<span class="hljs-number">0</span>].length;<br>  grid = grid.flat(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> num = k % grid.length;<br>  <span class="hljs-keyword">const</span> spliceArr = grid.splice(-num, num);<br>  grid = spliceArr.concat(grid);<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">while</span> (grid.length) &#123;<br>    temp.push(grid.splice(<span class="hljs-number">0</span>, rowNum));<br>  &#125;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月13日</title>
    <link href="/2021/05/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/05/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1304. 和为零的 N 个唯一整数</p><span id="more"></span><h1 id="1304-和为零的-N-个唯一整数"><a href="#1304-和为零的-N-个唯一整数" class="headerlink" title="1304. 和为零的 N 个唯一整数"></a><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/">1304. 和为零的 N 个唯一整数</a></h1><p>给你一个整数 <code>n</code>，请你返回 <strong>任意  **一个由 <code>n</code> 个 **各不相同  **的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。<br> **示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：n = 5<br>输出：[<span class="hljs-string">-7</span>,<span class="hljs-string">-1</span>,1,3,4]<br>解释：这些数组也是正确的 [<span class="hljs-string">-5</span>,<span class="hljs-string">-1</span>,1,2,3]，[<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,2,<span class="hljs-string">-2</span>,4]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前从 1 开始填充，同时用一个数字计算和，最后一位再加上前面所有数和的相反数即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumZero = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    res.push(i);<br>    sum += i;<br>  &#125;<br>  res.push(-sum);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月12日</title>
    <link href="/2021/05/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/05/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>LCP17. 速算机器人</p><span id="more"></span><h1 id="LCP-17-速算机器人"><a href="#LCP-17-速算机器人" class="headerlink" title="LCP 17. 速算机器人"></a><a href="https://leetcode-cn.com/problems/nGK0Fy/">LCP 17. 速算机器人</a></h1><p>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 <code>x</code> 和 <code>y</code>），请小扣说出计算指令：</p><ul><li><code>&quot;A&quot;</code> 运算：使 <code>x = 2 * x + y</code>；</li><li><code>&quot;B&quot;</code> 运算：使 <code>y = 2 * y + x</code>。</li></ul><p>在本次游戏中，店家说出的数字为 <code>x = 1</code> 和 <code>y = 0</code>，小扣说出的计算指令记作仅由大写字母 <code>A</code>、<code>B</code> 组成的字符串 <code>s</code>，字符串中字符的顺序表示计算顺序，请返回最终 <code>x</code> 与 <code>y</code> 的和为多少。<br><strong>示例 1：</strong></p><blockquote><p>输入：<code>s = &quot;AB&quot;</code><br>输出：<code>4</code><br>解释：<br>经过一次 A 运算后，x = 2, y = 0。<br>再经过一次 B 运算，x = 2, y = 2。<br>最终 x 与 y 之和为 4。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 10</code></li><li><code>s</code> 由 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code> 组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个字母按题意进行运算即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> calculate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>,<br>    y = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;A&quot;</span>) x = <span class="hljs-number">2</span> * x + y;<br>    <span class="hljs-keyword">else</span> y = <span class="hljs-number">2</span> * y + x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月11日</title>
    <link href="/2021/05/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/05/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1844. 将所有数字用字符替换</p><span id="more"></span><h1 id="1844-将所有数字用字符替换"><a href="#1844-将所有数字用字符替换" class="headerlink" title="1844. 将所有数字用字符替换"></a><a href="https://leetcode-cn.com/problems/replace-all-digits-with-characters/">1844. 将所有数字用字符替换</a></h1><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它的 <strong>偶数</strong> 下标处为小写英文字母，<strong>奇数</strong> 下标处为数字。<br>定义一个函数 <code>shift(c, x)</code> ，其中 <code>c</code> 是一个字符且 <code>x</code> 是一个数字，函数返回字母表中 <code>c</code> 后面第 <code>x</code> 个字符。</p><ul><li>比方说，<code>shift(&#39;a&#39;, 5) = &#39;f&#39;</code> 和 <code>shift(&#39;x&#39;, 0) = &#39;x&#39;</code> 。</li></ul><p>对于每个 <strong>奇数</strong> 下标 <code>i</code> ，你需要将数字 <code>s[i]</code> 用 <code>shift(s[i-1], s[i])</code> 替换。<br>请你替换所有数字以后，将字符串 <code>s</code> 返回。题目 <strong>保证</strong>_ _<code>shift(s[i-1], s[i])</code> 不会超过 <code>&#39;z&#39;</code> 。<br><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：s = <span class="hljs-string">&quot;a1c1e1&quot;</span><br>输出：<span class="hljs-string">&quot;abcdef&quot;</span><br>解释：数字被替换结果如下：<br>- <span class="hljs-function"><span class="hljs-title">s</span>[1] -&gt;</span> shift(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;b&#x27;</span><br>- <span class="hljs-function"><span class="hljs-title">s</span>[3] -&gt;</span> shift(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;d&#x27;</span><br>- <span class="hljs-function"><span class="hljs-title">s</span>[5] -&gt;</span> shift(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;f&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：s = <span class="hljs-string">&quot;a1b2c3d4e&quot;</span><br>输出：<span class="hljs-string">&quot;abbdcfdhe&quot;</span><br>解释：数字被替换结果如下：<br>- <span class="hljs-function"><span class="hljs-title">s</span>[1] -&gt;</span> shift(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;b&#x27;</span><br>- <span class="hljs-function"><span class="hljs-title">s</span>[3] -&gt;</span> shift(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;d&#x27;</span><br>- <span class="hljs-function"><span class="hljs-title">s</span>[5] -&gt;</span> shift(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>) = <span class="hljs-string">&#x27;f&#x27;</span><br>- <span class="hljs-function"><span class="hljs-title">s</span>[7] -&gt;</span> shift(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">4</span>) = <span class="hljs-string">&#x27;h&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写英文字母和数字。</li><li>对所有 <strong>奇数</strong> 下标处的 <code>i</code> ，满足 <code>shift(s[i-1], s[i]) &lt;= &#39;z&#39;</code> 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个数组，将当前数字替换为对应字母即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> replaceDigits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;<br>      s.splice(i, <span class="hljs-number">1</span>, <span class="hljs-built_in">String</span>.fromCharCode(s[i - <span class="hljs-number">1</span>].charCodeAt() + +s[i]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月10日</title>
    <link href="/2021/05/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/05/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1822. 数组元素积的符号</p><span id="more"></span><h1 id="1822-数组元素积的符号"><a href="#1822-数组元素积的符号" class="headerlink" title="1822. 数组元素积的符号"></a><a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">1822. 数组元素积的符号</a></h1><p>已知函数 <code>signFunc(x)</code> 将会根据 <code>x</code> 的正负返回特定值：</p><ul><li>如果 <code>x</code> 是正数，返回 <code>1</code> 。</li><li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li><li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。</li></ul><p>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。<br>返回 <code>signFunc(product)</code> 。<br><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>,3,2,1]<br>输出：1<br>解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,5,0,2,-3]</span><br>输出：<span class="hljs-number">0</span><br>解释：数组中所有值的乘积是 <span class="hljs-number">0</span> ，且 signFunc(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,1,<span class="hljs-string">-1</span>,1,<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br>解释：数组中所有值的乘积是 <span class="hljs-string">-1</span> ，且 signFunc(<span class="hljs-string">-1</span>) = <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，如果为 0 直接返回 0，如果为负数，改变符号</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arraySign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>      res = -res;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月9日</title>
    <link href="/2021/05/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%889%E6%97%A5/"/>
    <url>/2021/05/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt884. 两句话中的不常见单词</p><span id="more"></span><h1 id="884-两句话中的不常见单词"><a href="#884-两句话中的不常见单词" class="headerlink" title="884. 两句话中的不常见单词"></a><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/">884. 两句话中的不常见单词</a></h1><p>给定两个句子 <code>A</code> 和 <code>B</code> 。 （<em>句子</em>是一串由空格分隔的单词。每个<em>单词</em>仅由小写字母组成。）<br>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是<em>不常见的</em>。<br>返回所有不常用单词的列表。<br>您可以按任何顺序返回列表。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = <span class="hljs-string">&quot;this apple is sweet&quot;</span>, <span class="hljs-attr">B</span> = <span class="hljs-string">&quot;this apple is sour&quot;</span><br>输出：[<span class="hljs-string">&quot;sweet&quot;</span>,<span class="hljs-string">&quot;sour&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例  2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = <span class="hljs-string">&quot;apple apple&quot;</span>, <span class="hljs-attr">B</span> = <span class="hljs-string">&quot;banana&quot;</span><br>输出：[<span class="hljs-string">&quot;banana&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 200</code></li><li><code>0 &lt;= B.length &lt;= 200</code></li><li><code>A</code> 和 <code>B</code> 都只包含空格和小写字母。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转为数组后，拼接起来后，用哈希表统计次数，之后遍历哈希表，频次为 1 加入结果数组</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">B</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uncommonFromSentences = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, B</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> A.split(<span class="hljs-string">&quot; &quot;</span>).concat(B.split(<span class="hljs-string">&quot; &quot;</span>)))<br>    map.set(word, map.has(word) ? map.get(word) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [word, times] <span class="hljs-keyword">of</span> map) &#123;<br>    <span class="hljs-keyword">if</span> (times === <span class="hljs-number">1</span>) res.push(word);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月8日</title>
    <link href="/2021/05/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%888%E6%97%A5/"/>
    <url>/2021/05/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt888. 公平的糖果棒交换</p><span id="more"></span><h1 id="888-公平的糖果棒交换"><a href="#888-公平的糖果棒交换" class="headerlink" title="888. 公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></h1><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。<br>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em><br>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。<br>如果有多个答案，你可以返回其中任何一个。保证答案存在。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,1]</span>, B = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,2]</span>, B = <span class="hljs-comment">[2,3]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[2]</span>, B = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,2,5]</span>, B = <span class="hljs-comment">[2,4]</span><br>输出：<span class="hljs-comment">[5,4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= B.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li><li><code>1 &lt;= B[i] &lt;= 100000</code></li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设交换结果为[x,y]，有 sumA + y - x = sumB + x - y，化简得 (sumA - sumB) / 2 = x - y = target。将 A 放入集合，遍历 B，x = target + y，所以只要在遍历 B 时判断当前数加上 target 后的结果在集合 A 中是否存在，存在的话说明交换这两个数可以让总和相等，返回结果。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">B</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fairCandySwap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, B</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> target =<br>    (A.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a + +b, <span class="hljs-number">0</span>) - B.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a + +b, <span class="hljs-number">0</span>)) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> numSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(A);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> B) &#123;<br>    <span class="hljs-keyword">if</span> (numSet.has(num + target)) &#123;<br>      <span class="hljs-keyword">return</span> [num + target, num];<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月7日</title>
    <link href="/2021/05/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%887%E6%97%A5/"/>
    <url>/2021/05/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1309. 解码字母到整数映射</p><span id="more"></span><h1 id="1309-解码字母到整数映射"><a href="#1309-解码字母到整数映射" class="headerlink" title="1309. 解码字母到整数映射"></a><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/">1309. 解码字母到整数映射</a></h1><p>给你一个字符串 <code>s</code>，它由数字（<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 组成。我们希望按下述规则将 <code>s</code> 映射为一些小写英文字符：</p><ul><li>字符（<code>&#39;a&#39;</code> - <code>&#39;i&#39;</code>）分别用（<code>&#39;1&#39;</code> - <code>&#39;9&#39;</code>）表示。</li><li>字符（<code>&#39;j&#39;</code> - <code>&#39;z&#39;</code>）分别用（<code>&#39;10#&#39;</code> - <code>&#39;26#&#39;</code>）表示。</li></ul><p>返回映射之后形成的新字符串。<br>题目数据保证映射始终唯一。<br><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;10#11#12&quot;</span><br>输出：<span class="hljs-string">&quot;jkab&quot;</span><br>解释：<span class="hljs-string">&quot;j&quot;</span> -&gt; <span class="hljs-string">&quot;10#&quot;</span> , <span class="hljs-string">&quot;k&quot;</span> -&gt; <span class="hljs-string">&quot;11#&quot;</span> , <span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-string">&quot;1&quot;</span> , <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-string">&quot;2&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1326#&quot;</span><br>输出：<span class="hljs-string">&quot;acz&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;25#&quot;</span><br>输出：<span class="hljs-string">&quot;y&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：s = &quot;<span class="hljs-number">12345678910</span>#<span class="hljs-number">11#12#13#14</span>#<span class="hljs-number">15#16#17#18</span>#<span class="hljs-number">19#20#21#22</span>#<span class="hljs-number">23#24#25#26</span>#&quot;<br>输出：&quot;abcdefghijklmnopqrstuvwxyz&quot;<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 只包含数字（<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 字符。</li><li><code>s</code> 是映射始终存在的有效字符串。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意，遍历每一位，判断之后第二位是不是#，是的话将当前的两位转为对应字母加入结果字符串中，同时下标+2，判断下一位。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> freqAlphabets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> shouldEncode = s[i + <span class="hljs-number">2</span>] === <span class="hljs-string">&quot;#&quot;</span>;<br>    <span class="hljs-keyword">let</span> code;<br>    <span class="hljs-keyword">if</span> (shouldEncode) &#123;<br>      code = s.slice(i, i + <span class="hljs-number">2</span>);<br>      i += <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] !== <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>      code = s[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (code) res += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">96</span> + +code);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月6日</title>
    <link href="/2021/05/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%886%E6%97%A5/"/>
    <url>/2021/05/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1816. 截断句子</p><span id="more"></span><h1 id="1816-截断句子"><a href="#1816-截断句子" class="headerlink" title="1816. 截断句子"></a><a href="https://leetcode-cn.com/problems/truncate-sentence/">1816. 截断句子</a></h1><p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><ul><li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code> 都是句子。</li></ul><p>给你一个句子 <code>s</code> 和一个整数 <code>k</code> ，请你将 <code>s</code> <strong>截断</strong> ，使截断后的句子仅含 <strong>前</strong> <code>k</code> 个单词。返回 <strong>截断</strong> <code>s</code>_ <em>后得到的句子</em>。_<br><strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;Hello how are you Contestant&quot;</span>, k = <span class="hljs-number">4</span><br>输出：<span class="hljs-comment">&quot;Hello how are you&quot;</span><br>解释：<br>s 中的单词为 [<span class="hljs-comment">&quot;Hello&quot;</span>, <span class="hljs-comment">&quot;how&quot;</span> <span class="hljs-comment">&quot;are&quot;</span>, <span class="hljs-comment">&quot;you&quot;</span>, <span class="hljs-comment">&quot;Contestant&quot;</span>]<br>前 <span class="hljs-number">4</span> 个单词为 [<span class="hljs-comment">&quot;Hello&quot;</span>, <span class="hljs-comment">&quot;how&quot;</span>, <span class="hljs-comment">&quot;are&quot;</span>, <span class="hljs-comment">&quot;you&quot;</span>]<br>因此，应当返回 <span class="hljs-comment">&quot;Hello how are you&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;What is the solution to this problem&quot;</span>, k = <span class="hljs-number">4</span><br>输出：<span class="hljs-comment">&quot;What is the solution&quot;</span><br>解释：<br>s 中的单词为 [<span class="hljs-comment">&quot;What&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span> <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;solution&quot;</span>, <span class="hljs-comment">&quot;to&quot;</span>, <span class="hljs-comment">&quot;this&quot;</span>, <span class="hljs-comment">&quot;problem&quot;</span>]<br>前 <span class="hljs-number">4</span> 个单词为 [<span class="hljs-comment">&quot;What&quot;</span>, <span class="hljs-comment">&quot;is&quot;</span>, <span class="hljs-comment">&quot;the&quot;</span>, <span class="hljs-comment">&quot;solution&quot;</span>]<br>因此，应当返回 <span class="hljs-comment">&quot;What is the solution&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;chopper is not a tanuki&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">&quot;chopper is not a tanuki&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>k</code> 的取值范围是 <code>[1, s 中单词的数目]</code></li><li><code>s</code> 仅由大小写英文字母和空格组成</li><li><code>s</code> 中的单词之间由单个空格隔开</li><li>不存在前导或尾随空格</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意分隔截取再转换会字符串即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> truncateSentence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, k</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> s.split(<span class="hljs-string">&quot; &quot;</span>).slice(<span class="hljs-number">0</span>, k).join(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月5日</title>
    <link href="/2021/05/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%885%E6%97%A5/"/>
    <url>/2021/05/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1051. 高度检查器</p><span id="more"></span><h1 id="709-转换成小写字母"><a href="#709-转换成小写字母" class="headerlink" title="709. 转换成小写字母"></a><a href="https://leetcode-cn.com/problems/to-lower-case/">709. 转换成小写字母</a></h1><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;Hello&quot;</span><br>输出: <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;here&quot;</span><br>输出: <span class="hljs-string">&quot;here&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例  3：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;LOVELY&quot;</span><br>输出: <span class="hljs-string">&quot;lovely&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个字母转 asc 后，使用位运算转换为小写对应的字符。逻辑如下：或，小写转小写，大写转小写；与，大写转大写，小写转大写；异或，大小写互换。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">str</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> toLowerCase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str<br>    .split(<span class="hljs-string">&quot;&quot;</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> <span class="hljs-built_in">String</span>.fromCharCode(char.charCodeAt() | <span class="hljs-number">32</span>))<br>    .join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月4日</title>
    <link href="/2021/05/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%884%E6%97%A5/"/>
    <url>/2021/05/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1051. 高度检查器</p><span id="more"></span><h1 id="1051-高度检查器"><a href="#1051-高度检查器" class="headerlink" title="1051. 高度检查器"></a><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></h1><p>学校在拍年度纪念照时，一般要求学生按照 <strong>非递减</strong> 的高度顺序排列。<br>请你返回能让所有学生以 <strong>非递减</strong> 高度排列的最小必要移动人数。<br>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。<br><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：heights = [1,1,4,2,1,3]<br>输出：3<br>解释：<br>当前数组：[1,1,4,2,1,3]<br>目标数组：[1,1,1,2,3,4]<br>在下标<span class="hljs-number"> 2 </span>处（从<span class="hljs-number"> 0 </span>开始计数）出现<span class="hljs-number"> 4 </span>vs<span class="hljs-number"> 1 </span>，所以我们必须移动这名学生。<br>在下标<span class="hljs-number"> 4 </span>处（从<span class="hljs-number"> 0 </span>开始计数）出现<span class="hljs-number"> 1 </span>vs<span class="hljs-number"> 3 </span>，所以我们必须移动这名学生。<br>在下标<span class="hljs-number"> 5 </span>处（从<span class="hljs-number"> 0 </span>开始计数）出现<span class="hljs-number"> 3 </span>vs<span class="hljs-number"> 4 </span>，所以我们必须移动这名学生。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[5,1,2,3,4]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 100</code></li><li><code>1 &lt;= heights[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意就是排序后，输出奇数位置的数的和</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">heights</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> heightChecker = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">heights</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> temp = heights.slice().sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a - +b);<br>  <span class="hljs-keyword">return</span> heights.reduce(<span class="hljs-function">(<span class="hljs-params">a, b, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> a + (heights[index] !== temp[index] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月3日</title>
    <link href="/2021/05/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%883%E6%97%A5/"/>
    <url>/2021/05/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt561. 数组拆分 I</p><span id="more"></span><h1 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></h1><p>给定长度为 <code>2n</code>** <strong>的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code></strong> <strong>对, 例如 <code>(a, b), (a, b), ..., (a, b)</code> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(a, b)</code> 总和最大。<br>返回该 **最大总和</strong> 。<br>*<em>示例 1：\</em>*</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：所有可能的分法（忽略元素顺序）为：<br><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span>, <span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) + min(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-number">2.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span>, <span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) + min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-number">3.</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>, <span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) + min(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span><br>所以最大总和为 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">9</span><br>解释：最优的分法为 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>). <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-operator">+</span> <span class="hljs-built_in">min</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-number">6</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10</code></li><li><code>nums.length == 2 * n</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意就是排序后，输出奇数位置的数的和</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arrayPairSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a - +b);<br>  <span class="hljs-keyword">return</span> nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b, index</span>) =&gt;</span> a + (index % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : b), <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月2日</title>
    <link href="/2021/05/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%882%E6%97%A5/"/>
    <url>/2021/05/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1486. 数组异或操作</p><span id="more"></span><h1 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></h1><p>给你两个整数，<code>n</code> 和 <code>start</code> 。<br>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。<br>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 5, start = 0<br>输出：8<br>解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^<span class="hljs-number"> 2 </span>^<span class="hljs-number"> 4 </span>^<span class="hljs-number"> 6 </span>^ 8) =<span class="hljs-number"> 8 </span>。<br>     &quot;^&quot; 为按位异或 XOR 运算符。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">4</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">8</span><br>解释：数组 nums 为 [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]，其中 (<span class="hljs-number">3</span> ^ <span class="hljs-number">5</span> ^ <span class="hljs-number">7</span> ^ <span class="hljs-number">9</span>) = <span class="hljs-number">8</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>n == nums.length</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个变量记录前一个数，一个变量记录异或后的数，循环后，返回结果即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">start</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> xorOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, start</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prev = start,<br>    res = start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">const</span> num = start + <span class="hljs-number">2</span> * i;<br>    prev = num;<br>    res ^= prev;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年5月1日</title>
    <link href="/2021/05/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%881%E6%97%A5/"/>
    <url>/2021/05/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B45%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1720. 解码异或后的数组</p><span id="more"></span><h1 id="1720-解码异或后的数组"><a href="#1720-解码异或后的数组" class="headerlink" title="1720. 解码异或后的数组"></a><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></h1><p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。<br>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。<br>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。<br>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：encoded = <span class="hljs-comment">[1,2,3]</span>, first = 1<br>输出：<span class="hljs-comment">[1,0,2,1]</span><br>解释：若 arr = <span class="hljs-comment">[1,0,2,1]</span> ，那么 first = 1 且 encoded = <span class="hljs-comment">[1 XOR 0, 0 XOR 2, 2 XOR 1]</span> = <span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：encoded = [<span class="hljs-number">6,2,7,3</span>], first = <span class="hljs-number">4</span><br>输出：[<span class="hljs-number">4,2,0,7</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>encoded.length == n - 1</code></li><li><code>0 &lt;= encoded[i] &lt;= 10</code></li><li><code>0 &lt;= first &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意循环取得异或数放入结果数组中即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">encoded</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">first</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">encoded, first</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [first];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; encoded.length; i++) &#123;<br>    res.push(res[i] ^ encoded[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月30日</title>
    <link href="/2021/04/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8830%E6%97%A5/"/>
    <url>/2021/04/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1837. K 进制表示下的各位数字总和</p><span id="more"></span><h1 id="1837-K-进制表示下的各位数字总和"><a href="#1837-K-进制表示下的各位数字总和" class="headerlink" title="1837. K 进制表示下的各位数字总和"></a><a href="https://leetcode-cn.com/problems/sum-of-digits-in-base-k/">1837. K 进制表示下的各位数字总和</a></h1><p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 <strong>总和</strong> 。<br>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code> 进制表示返回。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 34, k = 6<br>输出：9<br>解释：34 (10 进制) 在<span class="hljs-number"> 6 </span>进制下表示为<span class="hljs-number"> 54 </span>。5 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 9 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 10, k = 10<br>输出：1<br>解释：n 本身就是<span class="hljs-number"> 10 </span>进制。<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转化为指定进制后划分为数组，求各个位数和即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumBase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, k</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n<br>    .toString(k)<br>    .split(<span class="hljs-string">&quot;&quot;</span>)<br>    .reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a + +b, <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月29日</title>
    <link href="/2021/04/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8829%E6%97%A5/"/>
    <url>/2021/04/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1832. 判断句子是否为全字母句</p><span id="more"></span><h1 id="1572-矩阵对角线元素的和"><a href="#1572-矩阵对角线元素的和" class="headerlink" title="1572. 矩阵对角线元素的和"></a><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/">1572. 矩阵对角线元素的和</a></h1><p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。<br>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。<br><strong>示例   1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1619699426094-14054855-daf1-4f12-809a-6efe3bf7c05b.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&originHeight=232&originWidth=448&size=0&status=done&style=none&width=336"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[4,5,6]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[7,8,9]</span>]</span><br>输出：25<br>解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25<br>请注意，元素 mat<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> = 5 只会被计算一次。<br></code></pre></td></tr></table></figure><p><strong>示例   2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat = <span class="hljs-comment">[<span class="hljs-comment">[1,1,1,1]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,1,1,1]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,1,1,1]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[1,1,1,1]</span>]</span><br>输出：8<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：mat = <span class="hljs-string">[[5]]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == mat.length == mat[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= mat[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个数组记录出现的情况，遍历句子得到每个字符对应的 asc 码，减去 97 以后把对应数组下标设为 0。遍历完后，如果数组内都为 0，说明每一个英文字母都出现过，返回 true。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">mat</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> diagonalSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mat</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; mat.length; row++) &#123;<br>    <span class="hljs-keyword">if</span> (row === <span class="hljs-built_in">Math</span>.abs(mat.length - row - <span class="hljs-number">1</span>)) res += mat[row][row];<br>    <span class="hljs-keyword">else</span> res += mat[row][row] + mat[row][<span class="hljs-built_in">Math</span>.abs(mat.length - row - <span class="hljs-number">1</span>)];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月28日</title>
    <link href="/2021/04/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/04/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1832. 判断句子是否为全字母句</p><span id="more"></span><h1 id="1832-判断句子是否为全字母句"><a href="#1832-判断句子是否为全字母句" class="headerlink" title="1832. 判断句子是否为全字母句"></a><a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">1832. 判断句子是否为全字母句</a></h1><p><strong>全字母句</strong> 指包含英语字母表中每个字母至少一次的句子。<br>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 <strong>全字母句</strong> 。<br>如果是，返回_ <em><code>true</code> ；否则，返回</em> _<code>false</code> 。<br><strong>示例 1：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">sentence</span> = <span class="hljs-string">&quot;thequickbrownfoxjumpsoverthelazydog&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-keyword">sentence</span> 包含英语字母表中每个字母至少一次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">sentence</span> = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li><code>sentence</code> 由小写英语字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个数组记录出现的情况，遍历句子得到每个字符对应的 asc 码，减去 97 以后把对应数组下标设为 0。遍历完后，如果数组内都为 0，说明每一个英文字母都出现过，返回 true。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">sentence</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkIfPangram = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sentence</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> sentence) &#123;<br>    <span class="hljs-keyword">const</span> code = char.charCodeAt() - <span class="hljs-number">97</span>;<br>    arr[code] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.every(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> char === <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月27日</title>
    <link href="/2021/04/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/04/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1475. 商品折扣后的最终价格</p><span id="more"></span><h1 id="1475-商品折扣后的最终价格"><a href="#1475-商品折扣后的最终价格" class="headerlink" title="1475. 商品折扣后的最终价格"></a><a href="https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/">1475. 商品折扣后的最终价格</a></h1><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。<br>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。<br>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [8,4,6,2,3]<br>输出：[4,2,4,2,3]<br>解释：<br>商品<span class="hljs-number"> 0 </span>的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>。<br>商品<span class="hljs-number"> 1 </span>的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 2 </span>。<br>商品<span class="hljs-number"> 2 </span>的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 4 </span>。<br>商品<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 4 </span>都没有折扣。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br>解释：在这个例子中，所有商品都没有折扣。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：prices = [<span class="hljs-number">10,1,1,6</span>]<br>输出：[<span class="hljs-number">9,0,1,6</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 500</code></li><li><code>1 &lt;= prices[i] &lt;= 10^3</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很显然一个双重遍历就可以实现。</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>维护一个单调递增栈，存储的是对应值的索引。遍历数组，如果栈里没有元素，则直接将当前元素的索引值加入栈中。有元素且栈顶元素比当前值大时，说明当前值就是这个下标对应的打折折扣，给结果数组对应下标赋值，并出栈，继续判断栈顶元素是否符合要求，直到栈空或者当前值比栈顶元素大。遍历完成后，剩下的都是无法打折的，直接放回原位即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> finalPrices = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prices.map(<span class="hljs-function">(<span class="hljs-params">price, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> target = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; prices.length; j++) &#123;<br>      <span class="hljs-keyword">const</span> element = prices[j];<br>      <span class="hljs-keyword">if</span> (element &lt;= price) &#123;<br>        target = element;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> price - (target ? target : <span class="hljs-number">0</span>);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> finalPrices = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> price = prices[i];<br>    <span class="hljs-keyword">let</span> pop = prices[stack[stack.length - <span class="hljs-number">1</span>]];<br>    <span class="hljs-keyword">while</span> (stack.length &amp;&amp; pop &gt;= price) &#123;<br>      pop = prices[stack[stack.length - <span class="hljs-number">1</span>]];<br>      <span class="hljs-keyword">if</span> (pop &gt;= price) &#123;<br>        <span class="hljs-keyword">const</span> index = stack.pop();<br>        res[index] = pop - price &gt; <span class="hljs-number">0</span> ? pop - price : <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>    stack.push(i);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (stack.length) &#123;<br>    <span class="hljs-keyword">const</span> index = stack.pop();<br>    res[index] = prices[index];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月26日</title>
    <link href="/2021/04/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/04/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1827. 最少操作使数组递增</p><span id="more"></span><h1 id="1827-最少操作使数组递增"><a href="#1827-最少操作使数组递增" class="headerlink" title="1827. 最少操作使数组递增"></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing/">1827. 最少操作使数组递增</a></h1><p>给你一个整数数组 <code>nums</code> （<strong>下标从 0 开始</strong>）。每一次操作中，你可以选择数组中一个元素，并将它增加 <code>1</code> 。</p><ul><li>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,**3**,3]</code> 。</li></ul><p>请你返回使 <code>nums</code> <strong>严格递增</strong> 的 <strong>最少</strong> 操作次数。<br>我们称数组 <code>nums</code> 是 <strong>严格递增的</strong> ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 <code>1</code> 的数组是严格递增的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,1]</span><br>输出：3<br>解释：你可以进行如下操作：<br>1) 增加 nums<span class="hljs-comment">[2]</span> ，数组变为 <span class="hljs-comment">[1,1,2]</span> 。<br>2) 增加 nums<span class="hljs-comment">[1]</span> ，数组变为 <span class="hljs-comment">[1,2,2]</span> 。<br>3) 增加 nums<span class="hljs-comment">[2]</span> ，数组变为 <span class="hljs-comment">[1,2,3]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,5,2,4,1]</span><br>输出：<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [8]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>1 &lt;= nums[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每一个，用一个 prev 记录前一个数，如果当前数比前一个数小，就给 res 累加上他们的差加 1，prev = prev + 1，比当前数大就更新 prev = num 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minOperations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prev = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> num = nums[i];<br>    <span class="hljs-keyword">if</span> (num &lt;= prev) &#123;<br>      res += prev - num + <span class="hljs-number">1</span>;<br>      prev = prev + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      prev = num;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月25日</title>
    <link href="/2021/04/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/04/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1071. 字符串的最大公因子</p><span id="more"></span><h1 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></h1><p>对于字符串 <code>S</code> 和 <code>T</code>，只有在 <code>S = T + ... + T</code>（<code>T</code> 自身连接 1 次或多次）时，我们才认定  “<code>T</code> 能除尽 <code>S</code>”。<br>返回最长字符串 <code>X</code>，要求满足 <code>X</code> 能除尽 <code>str1</code> 且 <code>X</code> 能除尽 <code>str2</code>。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">str1</span> = <span class="hljs-string">&quot;ABCABC&quot;</span>, <span class="hljs-attr">str2</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;ABC&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">str1</span> = <span class="hljs-string">&quot;ABABAB&quot;</span>, <span class="hljs-attr">str2</span> = <span class="hljs-string">&quot;ABAB&quot;</span><br>输出：<span class="hljs-string">&quot;AB&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">str1</span> = <span class="hljs-string">&quot;LEET&quot;</span>, <span class="hljs-attr">str2</span> = <span class="hljs-string">&quot;CODE&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= str1.length &lt;= 1000</code></li><li><code>1 &lt;= str2.length &lt;= 1000</code></li><li><code>str1[i]</code> 和 <code>str2[i]</code> 为大写英文字母</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从短的字符串开始，求每一个子串是否都能将 str1str2 完全分隔成全为空的数组，可以的话更新 res。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">str1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">str2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> gcdOfStrings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str1, str2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> str = str1.length &gt; str2.length ? str1 : str2;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> str) &#123;<br>    temp += char;<br>    <span class="hljs-keyword">const</span> arr1 = str1.split(temp);<br>    <span class="hljs-keyword">const</span> arr2 = str2.split(temp);<br>    <span class="hljs-keyword">if</span> (arr1.every(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e === <span class="hljs-string">&quot;&quot;</span>) &amp;&amp; arr2.every(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e === <span class="hljs-string">&quot;&quot;</span>)) res = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月24日</title>
    <link href="/2021/04/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/04/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt700. 二叉搜索树中的搜索</p><span id="more"></span><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。<br>例如，<br>给定二叉搜索树:</p><p>4<br>       / <br>      2   7<br>     / <br>    1   3</p><p>和值: 2</p><p>你应该返回如下子树:<br>      2     <br>     / \   <br>    1   3</p><p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意进行搜索即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (root) &#123;<br>    <span class="hljs-keyword">if</span> (root.val === val) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; val) root = root.left;<br>    <span class="hljs-keyword">else</span> root = root.right;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月23日</title>
    <link href="/2021/04/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/04/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt728. 自除数</p><span id="more"></span><h1 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">728. 自除数</a></h1><p><em>自除数  *是指可以被它包含的每一位数除尽的数。<br>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。<br>还有，自除数不允许包含 0 。<br>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。<br>*</em>示例 1：**</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：<br>上边界<span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>, 下边界<span class="hljs-built_in">right</span> = <span class="hljs-number">22</span><br>输出： [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>]<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意双重遍历即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">left</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">right</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> selfDividingNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;<br>    <span class="hljs-keyword">const</span> arr = (i + <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (arr.every(<span class="hljs-function">(<span class="hljs-params">digit</span>) =&gt;</span> i % digit === <span class="hljs-number">0</span>)) res.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月22日</title>
    <link href="/2021/04/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/04/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt412. Fizz Buzz</p><span id="more"></span><h1 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a><a href="https://leetcode-cn.com/problems/fizz-buzz/">412. Fizz Buzz</a></h1><p>写一个程序，输出从 1 到 <em>n</em> 数字的字符串表示。</p><ol><li>如果 *n *是 3 的倍数，输出“Fizz”；</li><li>如果 <em>n *是 5 的倍数，输出“Buzz”； 3.如果 *n *同时是 3 和 5 的倍数，输出 “FizzBuzz”。<br>*</em>示例：**</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile">n = 15,<br><span class="hljs-section">返回:</span><br>[<br>    <span class="hljs-string">&quot;1&quot;</span>,<br>    <span class="hljs-string">&quot;2&quot;</span>,<br>    <span class="hljs-string">&quot;Fizz&quot;</span>,<br>    <span class="hljs-string">&quot;4&quot;</span>,<br>    <span class="hljs-string">&quot;Buzz&quot;</span>,<br>    <span class="hljs-string">&quot;Fizz&quot;</span>,<br>    <span class="hljs-string">&quot;7&quot;</span>,<br>    <span class="hljs-string">&quot;8&quot;</span>,<br>    <span class="hljs-string">&quot;Fizz&quot;</span>,<br>    <span class="hljs-string">&quot;Buzz&quot;</span>,<br>    <span class="hljs-string">&quot;11&quot;</span>,<br>    <span class="hljs-string">&quot;Fizz&quot;</span>,<br>    <span class="hljs-string">&quot;13&quot;</span>,<br>    <span class="hljs-string">&quot;14&quot;</span>,<br>    <span class="hljs-string">&quot;FizzBuzz&quot;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意遍历即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fizzBuzz = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">const</span> num = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span> &amp;&amp; num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) res[i] = <span class="hljs-string">&quot;FizzBuzz&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) res[i] = <span class="hljs-string">&quot;Fizz&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) res[i] = <span class="hljs-string">&quot;Buzz&quot;</span>;<br>    <span class="hljs-keyword">else</span> res[i] = num + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月21日</title>
    <link href="/2021/04/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/04/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 02.06. 回文链表</p><span id="more"></span><h1 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/">面试题 02.06. 回文链表</a></h1><p>编写一个函数，检查输入的链表是否是回文的。<br><strong>示例 1：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入： <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span><br>输出： <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入： <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span><br>输出： <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针找到中点，将后满指针后半部分反转，变成从尾部指向中点的链表，分别从首尾开始比较值是否相同即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> slow = head,<br>    fast = head;<br>  <span class="hljs-keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast.next) &#123;<br>    slow = slow.next;<br>    fast = fast.next.next;<br>  &#125;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (slow) &#123;<br>    <span class="hljs-keyword">const</span> temp = slow.next;<br>    slow.next = prev;<br>    prev = slow;<br>    slow = temp;<br>  &#125;<br>  <span class="hljs-keyword">let</span> tail = prev;<br>  <span class="hljs-keyword">while</span> (head &amp;&amp; tail) &#123;<br>    <span class="hljs-keyword">if</span> (head.val !== tail.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    head = head.next;<br>    tail = tail.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月20日</title>
    <link href="/2021/04/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/04/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 16.17. 连续数列</p><span id="more"></span><h1 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a><a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/">面试题 16.17. 连续数列</a></h1><p>给定一个整数数组，找出总和最大的连续数列，并返回总和。<br><strong>示例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入： [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出： 6<br>解释： 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p><strong>进阶：</strong><br>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基础动态规划题，当前数的最大连续子数组和只和上一个数的最大连续子数组和有关：例如，第一二个元素，当前这两个元素的最大连续子数组和为 nums[0] + nums[1]或者 nums[1]中的一个，更新 max，然后将其看为一个整体，接下来的每一个数都是如此的关系。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pre = nums[<span class="hljs-number">0</span>],<br>    max = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    pre = <span class="hljs-built_in">Math</span>.max(pre + nums[i], nums[i]);<br>    max = <span class="hljs-built_in">Math</span>.max(max, pre);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月19日</title>
    <link href="/2021/04/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/04/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt717. 1 比特与 2 比特字符</p><span id="more"></span><h1 id="717-1-比特与-2-比特字符"><a href="#717-1-比特与-2-比特字符" class="headerlink" title="717. 1 比特与 2 比特字符"></a><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">717. 1 比特与 2 比特字符</a></h1><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。<br>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由 0 结束。<br><strong>示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>bits = [1, 0, 0]<br><span class="hljs-section">输出: True</span><br><span class="hljs-section">解释:</span><br>唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>bits = [1, 1, 1, 0]<br><span class="hljs-section">输出: False</span><br><span class="hljs-section">解释:</span><br>唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li><li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从 0 的最后一位开始计算连续 1 的数量是否为偶数即可：如果是偶数必定被分成 11、11…的形式，保留最后一个为 0，符合要求；如果是奇数则必定要和最后一个 0 成组，不满足要求。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">bits</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isOneBitCharacter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bits</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bits.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> num = bits[i];<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) count++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月18日</title>
    <link href="/2021/04/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/04/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 16.05. 阶乘尾数</p><span id="more"></span><h1 id="面试题-16-05-阶乘尾数"><a href="#面试题-16-05-阶乘尾数" class="headerlink" title="面试题 16.05. 阶乘尾数"></a><a href="https://leetcode-cn.com/problems/factorial-zeros-lcci/">面试题 16.05. 阶乘尾数</a></h1><p>设计一个算法，算出 n 阶乘有多少个尾随零。<br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 3</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 3! = 6, 尾数中没有零。</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 5</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 5! = 120, 尾数中有 1 个零.</span><br><span class="hljs-section">说明: 你算法的时间复杂度应为 O(log n) 。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求 0 尾数，即看能有多少个因子能 2 和 5 组成 10，除 0 外所有的偶数都含有因子 2，所以 2 的数量是比 5 多得多的，所以只需要计算 5 的数量。<br>第一步直接除以 5，得到 5 的数量加入结果中。<br>假设数无限大，我们可以知道，25 = 5 _ 5，所以每隔 25 个缺少了一个 5。<br>125 = 5 _ 5 * 5，所以每隔 125 个又缺少了一个 5。<br>以此类推，所有缺少的 5 都要加上。<br>所以 count = n / 5 + n / 25 + n / 125 …<br>优化一下 count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 …<br>当 n&lt;5 时，得到为 0，终止循环。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> trailingZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">5</span>) &#123;<br>    n = <span class="hljs-built_in">parseInt</span>(n / <span class="hljs-number">5</span>);<br>    count += n;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月17日</title>
    <link href="/2021/04/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/04/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 16.15. 珠玑妙算</p><span id="more"></span><h1 id="面试题-16-15-珠玑妙算"><a href="#面试题-16-15-珠玑妙算" class="headerlink" title="面试题 16.15. 珠玑妙算"></a><a href="https://leetcode-cn.com/problems/master-mind-lcci/">面试题 16.15. 珠玑妙算</a></h1><p>珠玑妙算游戏（the game of master mind）的玩法如下。<br>计算机有 4 个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有 RGGB 4 种（槽 1 为红色，槽 2、3 为绿色，槽 4 为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜 YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。<br>给定一种颜色组合<code>solution</code>和一个猜测<code>guess</code>，编写一个方法，返回猜中和伪猜中的次数<code>answer</code>，其中<code>answer[0]</code>为猜中的次数，<code>answer[1]</code>为伪猜中的次数。<br><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入： solution=<span class="hljs-string">&quot;RGBY&quot;</span>,guess=<span class="hljs-string">&quot;GGRR&quot;</span><br>输出： [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释： 猜中<span class="hljs-number">1</span>次，伪猜中<span class="hljs-number">1</span>次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>len(solution) = len(guess) = 4</code></li><li><code>solution</code>和<code>guess</code>仅包含<code>&quot;R&quot;</code>,<code>&quot;G&quot;</code>,<code>&quot;B&quot;</code>,<code>&quot;Y&quot;</code>这 4 种字符</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先遍历两个字符比较有没有完全猜中的，直接计数并删掉对应字符，源字符串中不相同的加入 map 中，再遍历一次剩余的猜测字符，如果在 map 中有则伪猜中次数加一，map 删去对应的次数。返回结果。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">solution</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">guess</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> masterMind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">solution, guess</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res1 = <span class="hljs-number">0</span>,<br>    res2 = <span class="hljs-number">0</span>;<br>  b;<br>  guess = guess.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; solution.length; i++, j++) &#123;<br>    <span class="hljs-keyword">const</span> char = solution[i];<br>    <span class="hljs-keyword">if</span> (map.has(char)) map.set(char, map.get(char) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> map.set(char, +<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (guess[j] === solution[i]) &#123;<br>      res1++;<br>      <span class="hljs-keyword">if</span> (map.get(char) === <span class="hljs-number">1</span>) map.delete(char);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(char) &gt; <span class="hljs-number">1</span>) map.set(char, map.get(char) - <span class="hljs-number">1</span>);<br>      guess.splice(j, <span class="hljs-number">1</span>);<br>      j--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; guess.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> char = guess[i];<br>    <span class="hljs-keyword">if</span> (map.has(char)) res2++;<br>    <span class="hljs-keyword">if</span> (map.get(char) === <span class="hljs-number">1</span>) map.delete(char);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(char) &gt; <span class="hljs-number">1</span>) map.set(char, map.get(char) - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> [res1, res2];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月16日</title>
    <link href="/2021/04/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/04/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1646. 获取生成数组中的最大值</p><span id="more"></span><h1 id="1646-获取生成数组中的最大值"><a href="#1646-获取生成数组中的最大值" class="headerlink" title="1646. 获取生成数组中的最大值"></a><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></h1><p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p><ul><li><code>nums[0] = 0</code></li><li><code>nums[1] = 1</code></li><li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li><li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li></ul><p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 7<br>输出：3<br>解释：根据规则：<br>  nums<span class="hljs-comment">[0]</span> = 0<br>  nums<span class="hljs-comment">[1]</span> = 1<br>  nums<span class="hljs-comment">[(1 * 2) = 2]</span> = nums<span class="hljs-comment">[1]</span> = 1<br>  nums<span class="hljs-comment">[(1 * 2) + 1 = 3]</span> = nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = 1 + 1 = 2<br>  nums<span class="hljs-comment">[(2 * 2) = 4]</span> = nums<span class="hljs-comment">[2]</span> = 1<br>  nums<span class="hljs-comment">[(2 * 2) + 1 = 5]</span> = nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[3]</span> = 1 + 2 = 3<br>  nums<span class="hljs-comment">[(3 * 2) = 6]</span> = nums<span class="hljs-comment">[3]</span> = 2<br>  nums<span class="hljs-comment">[(3 * 2) + 1 = 7]</span> = nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = 2 + 1 = 3<br>因此，nums = <span class="hljs-comment">[0,1,1,2,1,3,2,3]</span>，最大值 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 2<br>输出：1<br>解释：根据规则，nums<span class="hljs-comment">[0]</span>、nums<span class="hljs-comment">[1]</span> 和 nums<span class="hljs-comment">[2]</span> 之中的最大值是 1<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 3<br>输出：2<br>解释：根据规则，nums<span class="hljs-comment">[0]</span>、nums<span class="hljs-comment">[1]</span>、nums<span class="hljs-comment">[2]</span> 和 nums<span class="hljs-comment">[3]</span> 之中的最大值是 2<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意生成对应的数组，并实时更新最大值即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getMaximumGenerated = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> max = -<span class="hljs-literal">Infinity</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      arr[i] = arr[i / <span class="hljs-number">2</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      num = <span class="hljs-built_in">Math</span>.floor(i / <span class="hljs-number">2</span>);<br>      arr[i] = arr[num] + arr[num + <span class="hljs-number">1</span>];<br>    &#125;<br>    max = <span class="hljs-built_in">Math</span>.max(arr[i], max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月15日</title>
    <link href="/2021/04/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/04/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1576. 替换所有的问号</p><span id="more"></span><h1 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h1><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。<br>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。<br>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。<br>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;?zs&quot;</span><br>输出：<span class="hljs-string">&quot;azs&quot;</span><br>解释：该示例共有 <span class="hljs-number">25</span> 种解决方案，从 <span class="hljs-string">&quot;azs&quot;</span> 到 <span class="hljs-string">&quot;yzs&quot;</span> 都是符合题目要求的。只有 <span class="hljs-string">&quot;z&quot;</span> 是无效的修改，因为字符串 <span class="hljs-string">&quot;zzs&quot;</span> 中有连续重复的两个 &#x27;z&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ubv?w&quot;</span><br>输出：<span class="hljs-string">&quot;ubvaw&quot;</span><br>解释：该示例共有 <span class="hljs-number">24</span> 种解决方案，只有替换成 <span class="hljs-string">&quot;v&quot;</span> 和 <span class="hljs-string">&quot;w&quot;</span> 不符合题目要求。因为 <span class="hljs-string">&quot;ubvvw&quot;</span> 和 <span class="hljs-string">&quot;ubvww&quot;</span> 都包含连续重复的字符。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;j?qg??b&quot;</span><br>输出：<span class="hljs-string">&quot;jaqgacb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;??yw?ipkj?&quot;</span><br>输出：<span class="hljs-string">&quot;acywaipkja&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= s.length &lt;= 100</code></p></li><li><p><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历循环每个字符，再循环从 a 开始到 z 判断是否和前后字符相同，找到都不同的字符修改即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> modifyString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> [prev, cur, next] = [s[i - <span class="hljs-number">1</span>], s[i], s[i + <span class="hljs-number">1</span>]];<br>    <span class="hljs-keyword">if</span> (cur === <span class="hljs-string">&quot;?&quot;</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> char = <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span> + j);<br>        <span class="hljs-keyword">if</span> (char !== prev &amp;&amp; char !== next) &#123;<br>          s[i] = char;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月14日</title>
    <link href="/2021/04/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/04/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt326. 3 的幂</p><span id="more"></span><h1 id="326-3-的幂"><a href="#326-3-的幂" class="headerlink" title="326. 3 的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3 的幂</a></h1><p>给定一个整数，写一个函数来判断它是否是 3  的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3</code><br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">27</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">9</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">45</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-2 &lt;= n &lt;= 2 - 1</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能不使用循环或者递归来完成本题吗？</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>循环得到。</p><h4 id="非循环"><a href="#非循环" class="headerlink" title="非循环"></a>非循环</h4><p>10 的幂分别是 1、10、100、1000…2 的幂对应的是 1、2（10）、4（100）、8（1000）…所以 3 的幂对应的也是 10、100、1000。所以把这个数组转化成对应的 3 进制字符，然后用正则判断是否符合规则即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPowerOfThree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    n /= <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="非循环-1"><a href="#非循环-1" class="headerlink" title="非循环"></a>非循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPowerOfThree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^10*$/</span>.test(n.toString(<span class="hljs-number">3</span>));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月13日</title>
    <link href="/2021/04/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/04/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1796. 字符串中第二大的数字</p><span id="more"></span><h1 id="1796-字符串中第二大的数字"><a href="#1796-字符串中第二大的数字" class="headerlink" title="1796. 字符串中第二大的数字"></a><a href="https://leetcode-cn.com/problems/second-largest-digit-in-a-string/">1796. 字符串中第二大的数字</a></h1><p>给你一个混合字符串 <code>s</code> ，请你返回 <code>s</code> 中 <strong>第二大  **的数字，如果不存在第二大的数字，请你返回 <code>-1</code> 。<br>**混合字符串  **由小写英文字母和数字组成。<br> **示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;dfa12321afd&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：出现在 s 中的数字包括 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] 。第二大的数字是 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc1111&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：出现在 s 中的数字只包含 [<span class="hljs-number">1</span>] 。没有第二大的数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母和（或）数字。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>正则取得数字部分，使用 set 去重，排序返回第 2 个元素，不存在则返回-1</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> secondHighest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [...new <span class="hljs-built_in">Set</span>(s.replace(<span class="hljs-regexp">/[^0-9]/g</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>)).values()].sort(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a<br>  )[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> res ? res : -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月12日</title>
    <link href="/2021/04/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/04/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt594. 最长和谐子序列</p><span id="more"></span><h1 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h1><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。<br>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。<br>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。<br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,3,2,2</span>,<span class="hljs-number">5,2,3,7</span>]<br>输出：<span class="hljs-number">5</span><br>解释：最长的和谐子序列是 [<span class="hljs-number">3,2,2,2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先用 map 存储对应的数及出现次数，用 max 记录最长的元素数量。遍历每一个元素，将当前数加上 1 或减去 1 得到两个目标值 target，判断 map 中是否存在 target，取大的那一个 target 元素出现次数加上当前元素出现次数，更新 max。最后返回 max。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findLHS = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) map.set(num, map.has(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> arr = [...map.entries()];<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> [number, times] = arr[i];<br>    <span class="hljs-keyword">const</span> [targetNumberA, targetNumberB] = [number + <span class="hljs-number">1</span>, number - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> [targetTimesA, targetTimesB] = [<br>      map.get(targetNumberA),<br>      map.get(targetNumberB),<br>    ];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (targetTimesA || targetTimesB) &#123;<br>      res = <span class="hljs-built_in">Math</span>.max(<br>        times + (<span class="hljs-built_in">Number</span>.isInteger(targetTimesA) ? targetTimesA : <span class="hljs-number">0</span>),<br>        times + (<span class="hljs-built_in">Number</span>.isInteger(targetTimesB) ? targetTimesB : <span class="hljs-number">0</span>)<br>      );<br>    &#125;<br>    max = <span class="hljs-built_in">Math</span>.max(res, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月11日</title>
    <link href="/2021/04/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/04/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 05.06. 整数转换、Lt461. 汉明距离</p><span id="more"></span><h1 id="面试题-05-06-整数转换"><a href="#面试题-05-06-整数转换" class="headerlink" title="面试题 05.06. 整数转换"></a><a href="https://leetcode-cn.com/problems/convert-integer-lcci/">面试题 05.06. 整数转换</a></h1><p>整数转换。编写一个函数，确定需要改变几个位才能将整数 A 转成整数 B。<br>示例 1:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：A = <span class="hljs-number">29</span> （或者<span class="hljs-number">0b11101</span>）, B = <span class="hljs-number">15</span>（或者<span class="hljs-number">0b01111</span>）<br> 输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = <span class="hljs-number">1</span>，<span class="hljs-attr">B</span> = <span class="hljs-number">2</span><br> 输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示:</p><ol><li>A，B 范围在[-2147483648, 2147483647]之间</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>同<a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a>：</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602658653874-fe336707-5e06-45ea-b588-2ec2483b833e.png#align=left&display=inline&height=516&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=1674&size=0&status=done&style=none&width=1674"></h4><blockquote><p>计算 <code>A</code> 和 <code>B</code> 之间的汉明距离，可以先计算 <code>A XOR B</code>，然后统计结果中等于 1 的位数。</p></blockquote><p>先求 A^B，再对结果的 1 计数即为汉明距离，res &amp;= res - 1 会把最右边不同的一位变成 0，其他不变，用 count 进行 1 的计数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">B</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> convertInteger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, B</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = A ^ B;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (res) &#123;<br>    count++;<br>    res &amp;= res - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月10日</title>
    <link href="/2021/04/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/04/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1544. 整理字符串</p><span id="more"></span><h1 id="1544-整理字符串"><a href="#1544-整理字符串" class="headerlink" title="1544. 整理字符串"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/">1544. 整理字符串</a></h1><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。<br>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0&lt;= i &lt;= s.length-2</code> ，要满足如下条件:</p><ul><li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li><li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li></ul><p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。<br>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leEeetcode&quot;</span><br>输出：<span class="hljs-string">&quot;leetcode&quot;</span><br>解释：无论你第一次选的是 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> 还是 <span class="hljs-attr">i</span> = <span class="hljs-number">2</span>，都会使 <span class="hljs-string">&quot;leEeetcode&quot;</span> 缩减为 <span class="hljs-string">&quot;leetcode&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;abBAcC&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：<br><span class="hljs-string">&quot;abBAcC&quot;</span> --&gt; <span class="hljs-string">&quot;aAcC&quot;</span> --&gt; <span class="hljs-string">&quot;cC&quot;</span> --&gt; <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&quot;abBAcC&quot;</span> --&gt; <span class="hljs-string">&quot;abBA&quot;</span> --&gt; <span class="hljs-string">&quot;aA&quot;</span> --&gt; <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;s&quot;</span><br>输出：<span class="hljs-string">&quot;s&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历字符串，如果当前字符和上一个字符互为大小写字符就删除这两个字符，同时下标往前移动两位。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> makeGood = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> code = s[i].charCodeAt();<br>    <span class="hljs-keyword">const</span> targetChar =<br>      code &lt; <span class="hljs-number">97</span><br>        ? <span class="hljs-built_in">String</span>.fromCharCode(code + <span class="hljs-number">32</span>)<br>        : <span class="hljs-built_in">String</span>.fromCharCode(code - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">const</span> preCode = s[i - <span class="hljs-number">1</span>].charCodeAt();<br>    <span class="hljs-keyword">const</span> preTargetChar =<br>      preCode &lt; <span class="hljs-number">97</span><br>        ? <span class="hljs-built_in">String</span>.fromCharCode(preCode + <span class="hljs-number">32</span>)<br>        : <span class="hljs-built_in">String</span>.fromCharCode(preCode - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">if</span> (<br>      s[i].toLowerCase() === s[i - <span class="hljs-number">1</span>].toLowerCase() &amp;&amp;<br>      targetChar !== preTargetChar<br>    ) &#123;<br>      s.splice(i - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>      i = i &gt;= <span class="hljs-number">2</span> ? i - <span class="hljs-number">2</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月9日</title>
    <link href="/2021/04/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%889%E6%97%A5/"/>
    <url>/2021/04/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt796. 旋转字符串</p><span id="more"></span><h1 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796. 旋转字符串"></a><a href="https://leetcode-cn.com/problems/rotate-string/">796. 旋转字符串</a></h1><p>给定两个字符串, <code>A</code> 和 <code>B</code>。<br><code>A</code> 的旋转操作就是将 <code>A</code> 最左边的字符移动到最右边。  例如, 若 <code>A = &#39;abcde&#39;</code>，在移动一次之后结果就是<code>&#39;bcdea&#39;</code> 。如果在若干次旋转操作之后，<code>A</code> 能变成<code>B</code>，那么返回<code>True</code>。<br><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: A = <span class="hljs-string">&#x27;abcde&#x27;</span>, B = <span class="hljs-string">&#x27;cdeab&#x27;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: A = <span class="hljs-string">&#x27;abcde&#x27;</span>, B = <span class="hljs-string">&#x27;abced&#x27;</span><br>输出: <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>注意：<br>• A 和 B 长度不超过 100。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断两个字符串是否相同，如果 B 可以通过 A 旋转得到，必定能在两个 A 拼起来的字符串中找到。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">B</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotateString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, B</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> A.length === B.length &amp;&amp; (A + A).includes(B);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月8日</title>
    <link href="/2021/04/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%888%E6%97%A5/"/>
    <url>/2021/04/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1763. 最长的美好子字符串</p><span id="more"></span><h1 id="1763-最长的美好子字符串"><a href="#1763-最长的美好子字符串" class="headerlink" title="1763. 最长的美好子字符串"></a><a href="https://leetcode-cn.com/problems/longest-nice-substring/">1763. 最长的美好子字符串</a></h1><p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 <strong>同时</strong> 出现在 <code>s</code> 中，就称这个字符串 <code>s</code> 是 <strong>美好</strong> 字符串。比方说，<code>&quot;abABB&quot;</code> 是美好字符串，因为 <code>&#39;A&#39;</code> 和 <code>&#39;a&#39;</code> 同时出现了，且 <code>&#39;B&#39;</code> 和 <code>&#39;b&#39;</code> 也同时出现了。然而，<code>&quot;abA&quot;</code> 不是美好字符串因为 <code>&#39;b&#39;</code> 出现了，而 <code>&#39;B&#39;</code> 没有出现。<br>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 最长的 <strong>美好子字符串</strong> 。如果有多个答案，请你返回 <strong>最早</strong> 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">输入：s = <span class="hljs-string">&quot;YazaAay&quot;</span><br>输出：<span class="hljs-string">&quot;aAa&quot;</span><br>解释：<span class="hljs-string">&quot;aAa&quot;</span> 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 <span class="hljs-comment">&#x27;a&#x27; 和大写形式 &#x27;A&#x27; 也同时出现了。</span><br><span class="hljs-string">&quot;aAa&quot;</span> 是最长的美好子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;Bb&quot;</span><br>输出：<span class="hljs-string">&quot;Bb&quot;</span><br>解释：<span class="hljs-string">&quot;Bb&quot;</span> 是美好字符串，因为 &#x27;B&#x27;和 &#x27;b&#x27; 都出现了。整个字符串也是原字符串的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;c&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：没有美好子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;dDzeE&quot;</span><br>输出：<span class="hljs-string">&quot;dD&quot;</span><br>解释：<span class="hljs-string">&quot;dD&quot;</span> 和 <span class="hljs-string">&quot;eE&quot;</span> 都是最长美好子字符串。<br>由于有多个美好子字符串，返回 <span class="hljs-string">&quot;dD&quot;</span> ，因为它出现得最早。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含大写和小写英文字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力解。通过 set 来判断这个子串是不是美好字符串，得到 asc 码，计算出对应的大写或者小写字符，判断 set 中是否有这个元素，没有的话返回 false，有的话删除两个元素后继续判断。外层中，遍历每一个子串，如果当前子串长度比最大子串小，直接剪枝。比当前子串大且是美好子串就更新最大子串，最后返回最大子串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestNiceSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">const</span> isNice = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (str.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(str.split(<span class="hljs-string">&quot;&quot;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> set.values()) &#123;<br>      <span class="hljs-keyword">const</span> code = char.charCodeAt();<br>      <span class="hljs-keyword">const</span> targetChar =<br>        code &lt; <span class="hljs-number">97</span><br>          ? <span class="hljs-built_in">String</span>.fromCharCode(code + <span class="hljs-number">32</span>)<br>          : <span class="hljs-built_in">String</span>.fromCharCode(code - <span class="hljs-number">32</span>);<br>      <span class="hljs-keyword">if</span> (!set.has(targetChar)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">else</span> &#123;<br>        set.delete(char);<br>        set.delete(targetChar);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt;= s.length; j++) &#123;<br>      <span class="hljs-keyword">const</span> str = s.slice(i, j);<br>      <span class="hljs-keyword">if</span> (str.length &gt; max.length &amp;&amp; isNice(str)) &#123;<br>        max = str;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月7日</title>
    <link href="/2021/04/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%887%E6%97%A5/"/>
    <url>/2021/04/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1455. 检查单词是否为句中其他单词的前缀</p><span id="more"></span><h1 id="1455-检查单词是否为句中其他单词的前缀"><a href="#1455-检查单词是否为句中其他单词的前缀" class="headerlink" title="1455. 检查单词是否为句中其他单词的前缀"></a><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/">1455. 检查单词是否为句中其他单词的前缀</a></h1><p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。<br>请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p><ul><li>如果 <code>searchWord</code> 是某一个单词的前缀，则返回句子 <code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。</li><li>如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。</li><li>如果 <code>searchWord</code> 不是任何单词的前缀，则返回 **-1 **。</li></ul><p>字符串 <code>S</code> 的 <strong>前缀</strong> 是 <code>S</code> 的任何前导连续子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">sentence</span> = <span class="hljs-string">&quot;i love eating burger&quot;</span>, <span class="hljs-attr">searchWord</span> = <span class="hljs-string">&quot;burg&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-string">&quot;burg&quot;</span> 是 <span class="hljs-string">&quot;burger&quot;</span> 的前缀，而 <span class="hljs-string">&quot;burger&quot;</span> 是句子中第 <span class="hljs-number">4</span> 个单词。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">sentence</span> = <span class="hljs-string">&quot;this problem is an easy problem&quot;</span>, <span class="hljs-attr">searchWord</span> = <span class="hljs-string">&quot;pro&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;pro&quot;</span> 是 <span class="hljs-string">&quot;problem&quot;</span> 的前缀，而 <span class="hljs-string">&quot;problem&quot;</span> 是句子中第 <span class="hljs-number">2</span> 个也是第 <span class="hljs-number">6</span> 个单词，但是应该返回最小下标 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">sentence</span> = <span class="hljs-string">&quot;i am tired&quot;</span>, <span class="hljs-attr">searchWord</span> = <span class="hljs-string">&quot;you&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;you&quot;</span> 不是句子中任何单词的前缀。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">sentence</span> = <span class="hljs-string">&quot;i use triple pillow&quot;</span>, <span class="hljs-attr">searchWord</span> = <span class="hljs-string">&quot;pill&quot;</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">sentence</span> = <span class="hljs-string">&quot;hello from the other side&quot;</span>, <span class="hljs-attr">searchWord</span> = <span class="hljs-string">&quot;they&quot;</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence.length &lt;= 100</code></li><li><code>1 &lt;= searchWord.length &lt;= 10</code></li><li><code>sentence</code> 由小写英文字母和空格组成。</li><li><code>searchWord</code> 由小写英文字母组成。</li><li>前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 <a href="https://baike.baidu.com/item/%E5%89%8D%E7%BC%80">前缀_百度百科</a> ）</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按空格分割以后，在 word 中用 indexof 查找，如果查出的 index 不为 0，则不是前缀，如果是返回对应下标，都不存在返回-1.</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">sentence</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">searchWord</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPrefixOfWord = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sentence, searchWord</span>) </span>&#123;<br>  sentence = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sentence.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> word = sentence[i];<br>    <span class="hljs-keyword">if</span> (word.indexOf(searchWord) === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月6日</title>
    <link href="/2021/04/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%886%E6%97%A5/"/>
    <url>/2021/04/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1189. “气球” 的最大数量</p><span id="more"></span><h1 id="1189-“气球”-的最大数量"><a href="#1189-“气球”-的最大数量" class="headerlink" title="1189. “气球” 的最大数量"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/">1189. “气球” 的最大数量</a></h1><p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。<br>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”**。<br>**示例 1：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1617696053234-52f53e8b-3a17-4807-9da5-db347b0faaa6.jpeg#align=left&display=inline&height=35&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=277&size=0&status=done&style=none&width=154"></strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;nlaebolko&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1617696053219-1c50f135-bc9a-4753-a9c9-b0e5c5cbe77c.jpeg#align=left&display=inline&height=35&margin=%5Bobject%20Object%5D&originHeight=72&originWidth=480&size=0&status=done&style=none&width=233"></strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;loonbalxballpoon&quot;</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text.length &lt;= 10^4</code></li><li><code>text</code> 全部由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先用一个 map 记录出现的元素及其个数，用一个 set 记录 map 需要出现的 key 值 balon 五个，当 map 有这五个 key 值时，遍历 balloon 删除 map 中对应的个数再生成字符串进行计数，直到不能再生成时返回计数。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>其实就是求 balon 每个元素个数的最小值，其中 l、o 需要除以二。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxNumberOfBalloons = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> text) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(char)) map.set(char, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> map.set(char, map.get(char) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&quot;balloon&quot;</span>.split(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ([...charSet.values()].every(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> map.has(e))) &#123;<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;balloon&quot;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!map.has(char)) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span> (map.get(char) === <span class="hljs-number">1</span>) map.delete(char);<br>      <span class="hljs-keyword">else</span> map.set(char, map.get(char) - <span class="hljs-number">1</span>);<br>      temp += char;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (temp === <span class="hljs-string">&quot;balloon&quot;</span>) res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxNumberOfBalloons = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> text) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(char)) map.set(char, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> map.set(char, map.get(char) + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;balon&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(char)) map.set(char, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(<br>    map.get(<span class="hljs-string">&quot;b&quot;</span>),<br>    map.get(<span class="hljs-string">&quot;a&quot;</span>),<br>    <span class="hljs-built_in">parseInt</span>(map.get(<span class="hljs-string">&quot;l&quot;</span>) / <span class="hljs-number">2</span>),<br>    <span class="hljs-built_in">parseInt</span>(map.get(<span class="hljs-string">&quot;o&quot;</span>) / <span class="hljs-number">2</span>),<br>    map.get(<span class="hljs-string">&quot;n&quot;</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月5日</title>
    <link href="/2021/04/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%885%E6%97%A5/"/>
    <url>/2021/04/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1184. 公交站间的距离</p><span id="more"></span><h1 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184. 公交站间的距离"></a><a href="https://leetcode-cn.com/problems/distance-between-bus-stops/">1184. 公交站间的距离</a></h1><p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。<br>环线上的公交车都可以按顺时针和逆时针的方向行驶。<br>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。<br> <strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1617556989695-43728692-d716-4ae9-bd4c-2c73d9efafad.jpeg#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=388&size=0&status=done&style=none&width=388"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">distance</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">start</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">destination</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：公交站 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 之间的距离是 <span class="hljs-number">1</span> 或 <span class="hljs-number">9</span>，最小值是 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1617556989757-8dc73506-994a-4b54-99cb-912262cde55c.jpeg#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=388&size=0&status=done&style=none&width=388"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">distance</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">start</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">destination</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：公交站 <span class="hljs-number">0</span> 和 <span class="hljs-number">2</span> 之间的距离是 <span class="hljs-number">3</span> 或 <span class="hljs-number">7</span>，最小值是 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1617556989795-569bae96-767d-479b-ac02-b59400843ced.jpeg#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=388&size=0&status=done&style=none&width=388"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">distance</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">start</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">destination</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：公交站 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 之间的距离是 <span class="hljs-number">6</span> 或 <span class="hljs-number">4</span>，最小值是 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>distance.length == n</code></li><li><code>0 &lt;= start, destination &lt; n</code></li><li><code>0 &lt;= distance[i] &lt;= 10^4</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先保证 start 一定小于 destination，遍历数组，其实题目就转换成了求一个数组分成三段后，再比较中间一段的长度和两边两段长度之和，取较短的那一方即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">distance</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">start</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">destination</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> distanceBetweenBusStops = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">distance, start, destination</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> distance1 = <span class="hljs-number">0</span>,<br>    distance2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (start &gt; destination) [start, destination] = [destination, start];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; distance.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= start &amp;&amp; i &lt; destination) &#123;<br>      distance1 += distance[i];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      distance2 += distance[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(distance1, distance2);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月4日</title>
    <link href="/2021/04/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%884%E6%97%A5/"/>
    <url>/2021/04/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 10.05. 稀疏数组搜索</p><span id="more"></span><h1 id="面试题-10-05-稀疏数组搜索"><a href="#面试题-10-05-稀疏数组搜索" class="headerlink" title="面试题 10.05. 稀疏数组搜索"></a><a href="https://leetcode-cn.com/problems/sparse-array-search-lcci/">面试题 10.05. 稀疏数组搜索</a></h1><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。<br><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">words</span> = [<span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ball&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;car&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>], <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ta&quot;</span><br> 输出：-<span class="hljs-number">1</span><br> 说明: 不存在返回-<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">words</span> = [<span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ball&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;car&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>], <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ball&quot;</span><br> 输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>words 的长度在[1, 1000000]之间</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为数组是有序的，使用二分查找，每次循环内求中求中点，然后用一个 temp 记录这个中点，向左边开始线性查找第一个非空元素，查到以后和 s 进行比较，如果相等返回该下标，如果比 s 大，说明要找的元素在 left 到当前元素中间。如果比 s 小，说明这个值在临时记录的 temp 到 right 之间。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words, s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = words.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">Math</span>.ceil((left + right) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> temp = middle;<br>    <span class="hljs-keyword">while</span> (!words[middle] &amp;&amp; middle &gt; left) &#123;<br>      middle--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (words[middle] === s) <span class="hljs-keyword">return</span> middle;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (words[middle] &gt; s) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = temp + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月3日</title>
    <link href="/2021/04/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%883%E6%97%A5/"/>
    <url>/2021/04/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt953. 验证外星语词典</p><span id="more"></span><h1 id="953-验证外星语词典"><a href="#953-验证外星语词典" class="headerlink" title="953. 验证外星语词典"></a><a href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/">953. 验证外星语词典</a></h1><p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。<br>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">输入：words = [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], <span class="hljs-keyword">order</span> = <span class="hljs-string">&quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：在该语言的字母表中，<span class="hljs-string">&#x27;h&#x27;</span> 位于 <span class="hljs-string">&#x27;l&#x27;</span> 之前，所以单词序列是按字典序排列的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;word&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;row&quot;</span>], order = <span class="hljs-string">&quot;worldabcefghijkmnpqstuvxyz&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：在该语言的字母表中，<span class="hljs-string">&#x27;d&#x27;</span> 位于 <span class="hljs-string">&#x27;l&#x27;</span> 之后，那么 <span class="hljs-keyword">words</span>[<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">words</span>[<span class="hljs-number">1</span>]，因此单词序列不是按字典序排列的。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">输入：words = [<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;app&quot;</span>], <span class="hljs-keyword">order</span> = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：当前三个字符 <span class="hljs-string">&quot;app&quot;</span> 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 <span class="hljs-string">&quot;apple&quot;</span> &gt; <span class="hljs-string">&quot;app&quot;</span>，因为 <span class="hljs-string">&#x27;l&#x27;</span> &gt; <span class="hljs-string">&#x27;∅&#x27;</span>，其中 <span class="hljs-string">&#x27;∅&#x27;</span> 是空白字符，定义为比任何其他字符都小（更多信息）。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>order.length == 26</code></li><li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先用哈希表记录下单词序，然后将原来的单词根据哈希表中对应的下标翻译成正常单词序的单词，再使用 reduce 判断数组中所有元素是否都符合单词序排序。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">order</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isAlienSorted = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words, order</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; order.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> char = order[i];<br>    map.set(char, i);<br>  &#125;<br>  <span class="hljs-keyword">const</span> translatedWords = words.map(<span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span><br>    word<br>      .split(<span class="hljs-string">&quot;&quot;</span>)<br>      .map(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span> + map.get(char)))<br>      .join(<span class="hljs-string">&quot;&quot;</span>)<br>  );<br>  <span class="hljs-keyword">return</span> translatedWords.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a &lt;= b);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月2日</title>
    <link href="/2021/04/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%882%E6%97%A5/"/>
    <url>/2021/04/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt929. 独特的电子邮件地址</p><span id="more"></span><h1 id="929-独特的电子邮件地址"><a href="#929-独特的电子邮件地址" class="headerlink" title="929. 独特的电子邮件地址"></a><a href="https://leetcode-cn.com/problems/unique-email-addresses/">929. 独特的电子邮件地址</a></h1><p>每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。<br>例如，在 <code>alice@leetcode.com</code>中， <code>alice</code> 是本地名称，而 <code>leetcode.com</code> 是域名。<br>除了小写字母，这些电子邮件还可能包含 <code>&#39;.&#39;</code> 或 <code>&#39;+&#39;</code>。<br>如果在电子邮件地址的<strong>本地名称</strong>部分中的某些字符之间添加句点（<code>&#39;.&#39;</code>），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，<code>&quot;alice.z@leetcode.com”</code> 和 <code>“alicez@leetcode.com”</code> 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）<br>如果在<strong>本地名称</strong>中添加加号（<code>&#39;+&#39;</code>），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 <code>m.y+name@email.com</code> 将转发到 <code>my@email.com</code>。 （同样，此规则不适用于域名。）<br>可以同时使用这两个规则。<br>给定电子邮件列表 <code>emails</code>，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？<br> <strong>示例：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：[<span class="hljs-string">&quot;test.email+alex@leetcode.com&quot;</span>,<span class="hljs-string">&quot;test.e.mail+bob.cathy@leetcode.com&quot;</span>,<span class="hljs-string">&quot;testemail+david@lee.tcode.com&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：实际收到邮件的是 <span class="hljs-string">&quot;testemail@leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;testemail@lee.tcode.com&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= emails[i].length &lt;= 100</code></li><li><code>1 &lt;= emails.length &lt;= 100</code></li><li>每封 <code>emails[i]</code> 都包含有且仅有一个 <code>&#39;@&#39;</code> 字符。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用 set 记录不重复的最终邮箱字符串，先分别得到名称和域名，名称将所有“.”替换，再去掉 t 之后的所有字符串，再组成最终邮箱字符串加入 set 中。最后返回 set 的 size。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">emails</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numUniqueEmails = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">emails</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> email <span class="hljs-keyword">of</span> emails) &#123;<br>    <span class="hljs-keyword">let</span> [name, domain] = email.split(<span class="hljs-string">&quot;@&quot;</span>);<br>    name = name.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    name = name.split(<span class="hljs-string">&quot;+&quot;</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>@<span class="hljs-subst">$&#123;domain&#125;</span>`</span>;<br>    set.add(res);<br>  &#125;<br>  <span class="hljs-keyword">return</span> set.size;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年4月1日</title>
    <link href="/2021/04/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%881%E6%97%A5/"/>
    <url>/2021/04/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B44%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1399. 统计最大组的数目</p><span id="more"></span><h1 id="1399-统计最大组的数目"><a href="#1399-统计最大组的数目" class="headerlink" title="1399. 统计最大组的数目"></a><a href="https://leetcode-cn.com/problems/count-largest-group/">1399. 统计最大组的数目</a></h1><p>给你一个整数 <code>n</code> 。请你先求出从 <code>1</code> 到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。<br>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 13<br>输出：4<br>解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：<br><span class="hljs-comment">[1,10]</span>，<span class="hljs-comment">[2,11]</span>，<span class="hljs-comment">[3,12]</span>，<span class="hljs-comment">[4,13]</span>，<span class="hljs-comment">[5]</span>，<span class="hljs-comment">[6]</span>，<span class="hljs-comment">[7]</span>，<span class="hljs-comment">[8]</span>，<span class="hljs-comment">[9]</span>。总共有 4 个组拥有的数字并列最多。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 2<br>输出：2<br>解释：总共有 2 个大小为 1 的组 <span class="hljs-comment">[1]</span>，<span class="hljs-comment">[2]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">15</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">24</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先生成数组，借助 map，记录每一个数位和相同的数字组成的数组，按照数组的长度降序排序，开始计数，直到当前数组长度不等于上一个数组长度，返回 count。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countLargestGroup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-string">&quot;&quot;</span>).map(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> index + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">const</span> sum =<br>      (num + <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) + <span class="hljs-built_in">Number</span>(b)) + <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (map.has(sum)) map.set(sum, [...map.get(sum), num]);<br>    <span class="hljs-keyword">else</span> map.set(sum, [num]);<br>  &#125;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>    prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> e <span class="hljs-keyword">of</span> [...map.values()].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.length - a.length)) &#123;<br>    <span class="hljs-keyword">if</span> (!prev) prev = e.length;<br>    <span class="hljs-keyword">if</span> (prev !== e.length) <span class="hljs-keyword">return</span> count;<br>    count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月31日</title>
    <link href="/2021/03/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8831%E6%97%A5/"/>
    <url>/2021/03/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1518. 换酒问题</p><span id="more"></span><h1 id="1518-换酒问题"><a href="#1518-换酒问题" class="headerlink" title="1518. 换酒问题"></a><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></h1><p>小区便利店正在促销，用 <code>numExchange</code> 个空酒瓶可以兑换一瓶新酒。你购入了 <code>numBottles</code> 瓶酒。<br>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。<br>请你计算 <strong>最多</strong> 能喝到多少瓶酒。</p><p><strong>示例 1：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1617198591725-5091ca2d-09bd-4e5b-a7ae-325b04f7e95c.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=314&originWidth=640&size=0&status=done&style=none&width=480"></strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numBottles = 9, numExchange = 3<br>输出：13<br>解释：你可以用<span class="hljs-number"> 3 </span>个空酒瓶兑换<span class="hljs-number"> 1 </span>瓶酒。<br>所以最多能喝到<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 13 </span>瓶酒。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1617198591683-9d219da7-7d0e-4b7a-aef9-4f6ccab80a30.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&originHeight=386&originWidth=1053&size=0&status=done&style=none&width=790"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numBottles = 15, numExchange = 4<br>输出：19<br>解释：你可以用<span class="hljs-number"> 4 </span>个空酒瓶兑换<span class="hljs-number"> 1 </span>瓶酒。<br>所以最多能喝到<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 19 </span>瓶酒。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numBottles</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">numExchange</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numBottles</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">numExchange</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 rest 记录剩余的瓶盖个数，当剩余瓶子数和瓶盖数的和小于需交换数时结束循环。循环内，结果瓶数累加上当前剩余瓶子数，瓶盖数加上剩余瓶子数。当前瓶子除以需要交换的数后，整数部分为之后剩余的瓶子数，余数部分为兑换后剩余的瓶盖数。结束循环之后，最后还要加上剩余的瓶子数返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">numBottles</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">numExchange</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numWaterBottles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numBottles, numExchange</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>,<br>    rest = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (numBottles + rest &gt;= numExchange) &#123;<br>    res += numBottles;<br>    rest += numBottles;<br>    numBottles = <span class="hljs-built_in">Math</span>.floor(rest / numExchange);<br>    rest -= numBottles * numExchange;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res + numBottles;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月30日</title>
    <link href="/2021/03/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8830%E6%97%A5/"/>
    <url>/2021/03/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1752. 检查数组是否经排序和轮转得到</p><span id="more"></span><h1 id="1752-检查数组是否经排序和轮转得到"><a href="#1752-检查数组是否经排序和轮转得到" class="headerlink" title="1752. 检查数组是否经排序和轮转得到"></a><a href="https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated/">1752. 检查数组是否经排序和轮转得到</a></h1><p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。<br>如果 <code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code>_ _；否则，返回 <code>false</code> 。<br>源数组中可能存在 <strong>重复项</strong> 。<br><strong>注意：</strong>我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 <code>%</code> 为取余运算。<br><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：true<br>解释：<span class="hljs-string">[1,2,3,4,5]</span> 为有序的源数组。<br>可以轮转 x = <span class="hljs-number">3</span> 个位置，使新数组从值为 <span class="hljs-number">3</span> 的元素开始：<span class="hljs-string">[3,4,5,1,2]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：源数组无法经轮转得到 nums 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 为有序的源数组。<br>可以轮转 <span class="hljs-attr">x</span> = <span class="hljs-number">0</span> 个位置（即不轮转）得到 nums 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,1]</span><br>输出：true<br>解释：<span class="hljs-comment">[1,1,1]</span> 为有序的源数组。<br>轮转任意个位置都可以得到 nums 。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1]</span><br>输出：true<br>解释：<span class="hljs-comment">[1,2]</span> 为有序的源数组。<br>可以轮转 x = 5 个位置，使新数组从值为 2 的元素开始：<span class="hljs-comment">[2,1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>类似一个字符串能否通过轮转得到另外一个字符串。这里只要将两个数组首位拼接起来，再判断是否包含一个该数组升序排序的数组即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> check = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums<br>    .concat(nums)<br>    .join(<span class="hljs-string">&quot;,&quot;</span>)<br>    .includes(nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b).join(<span class="hljs-string">&quot;,&quot;</span>));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月29日</title>
    <link href="/2021/03/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8829%E6%97%A5/"/>
    <url>/2021/03/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1710. 卡车上的最大单元数</p><span id="more"></span><h1 id="1710-卡车上的最大单元数"><a href="#1710-卡车上的最大单元数" class="headerlink" title="1710. 卡车上的最大单元数"></a><a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">1710. 卡车上的最大单元数</a></h1><p>请你将一些箱子装在 <strong>一辆卡车</strong> 上。给你一个二维数组 <code>boxTypes</code> ，其中 <code>boxTypes[i] = [numberOfBoxes, numberOfUnitsPerBox]</code> ：</p><ul><li><code>numberOfBoxes</code> 是类型 <code>i</code> 的箱子的数量。</li><li><code>numberOfUnitsPerBox</code>是类型 <code>i</code> 每个箱子可以装载的单元数量。</li></ul><p>整数 <code>truckSize</code> 表示卡车上可以装载 <strong>箱子</strong> 的 <strong>最大数量</strong> 。只要箱子数量不超过 <code>truckSize</code> ，你就可以选择任意箱子装到卡车上。<br>返回卡车可以装载 <strong>单元</strong> 的 <strong>最大</strong> 总数<em>。</em><br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4<br>输出：8<br>解释：箱子的情况如下：<br>-<span class="hljs-number"> 1 </span>个第一类的箱子，里面含<span class="hljs-number"> 3 </span>个单元。<br>-<span class="hljs-number"> 2 </span>个第二类的箱子，每个里面含<span class="hljs-number"> 2 </span>个单元。<br>-<span class="hljs-number"> 3 </span>个第三类的箱子，每个里面含<span class="hljs-number"> 1 </span>个单元。<br>可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。<br>单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：boxTypes = <span class="hljs-comment">[<span class="hljs-comment">[5,10]</span>,<span class="hljs-comment">[2,5]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[3,9]</span>]</span>, truckSize = 10<br>输出：91<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= boxTypes.length &lt;= 1000</code></li><li><code>1 &lt;= numberOfBoxes, numberOfUnitsPerBox &lt;= 1000</code></li><li><code>1 &lt;= truckSize &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>贪心，先优先取 size 大的，按 size 降序排序。一直取到个数上线，求和即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">boxTypes</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">truckSize</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximumUnits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">boxTypes, truckSize</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>,<br>    rest = truckSize;<br>  boxTypes.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">while</span> (rest &gt; <span class="hljs-number">0</span> &amp;&amp; boxTypes.length) &#123;<br>    <span class="hljs-keyword">const</span> maxBox = boxTypes[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> [num, size] = maxBox;<br>    <span class="hljs-keyword">const</span> countNum = rest &gt;= num ? num : rest;<br>    rest -= countNum;<br>    res += countNum * size;<br>    boxTypes.shift();<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月28日</title>
    <link href="/2021/03/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/03/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1790. 仅执行一次字符串交换能否使两个字符串相等</p><span id="more"></span><h1 id="1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="1790. 仅执行一次字符串交换能否使两个字符串相等"></a><a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal/">1790. 仅执行一次字符串交换能否使两个字符串相等</a></h1><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次**  字符串交换  <strong>操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。<br>如果对 **其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;bank&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kanb&quot;</span><br>输出：true<br>解释：例如，交换 <span class="hljs-built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="hljs-string">&quot;bank&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">&quot;attack&quot;</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">&quot;defend&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：一次字符串交换无法使两个字符串相等<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">&quot;kelb&quot;</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">&quot;kelb&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：两个字符串已经相等，所以不需要进行字符串交换<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">&quot;dcba&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>s1.length == s2.length</code></li><li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先剪枝，如果字符串相等直接返回 true，通过排序和转为 json 判断两个数组内元素是否完全一样，不一样的话直接返回 false。然后遍历字符串，统计两个字符串不同的位数，若刚好为 2，则可以通过一次交换得到两个一样的字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> areAlmostEqual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (s1 === s2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> arr1 = s1.split(<span class="hljs-string">&quot;&quot;</span>).sort(),<br>    arr2 = s2.split(<span class="hljs-string">&quot;&quot;</span>).sort();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">JSON</span>.stringify(arr1) !== <span class="hljs-built_in">JSON</span>.stringify(arr2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; count &lt;= <span class="hljs-number">2</span> &amp;&amp; i &lt; s1.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (s1[i] !== s2[i]) count++;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月27日</title>
    <link href="/2021/03/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/03/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1523. 在区间范围内统计奇数数目</p><span id="more"></span><h1 id="1523-在区间范围内统计奇数数目"><a href="#1523-在区间范围内统计奇数数目" class="headerlink" title="1523. 在区间范围内统计奇数数目"></a><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range/">1523. 在区间范围内统计奇数数目</a></h1><p>给你两个非负整数 <code>low</code> 和 <code>high</code> 。请你返回_ <em><code>low</code></em> <em>和</em> <em><code>high</code></em> _之间（包括二者）奇数的数目。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">low</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 到 <span class="hljs-number">7</span> 之间奇数数字为 [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">low</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">8</span> 到 <span class="hljs-number">10</span> 之间奇数数字为 [<span class="hljs-number">9</span>] 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路用高位的奇数个数，减去低位的奇数个数。然后共有 hight-low+1 个数，所以按 hight+1，或者 low-1 来计算。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">low</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">high</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countOdds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">low, high</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> ((high + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) - (low &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月26日</title>
    <link href="/2021/03/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/03/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt867. 转置矩阵</p><span id="more"></span><h1 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a><a href="https://leetcode-cn.com/problems/transpose-matrix/">867. 转置矩阵</a></h1><p>给你一个二维整数数组 <code>matrix</code>，  返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。<br>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1616763392171-5a94c800-1970-48ce-a2af-a77e8d11c583.png#align=left&display=inline&height=197&margin=%5Bobject%20Object%5D&originHeight=1045&originWidth=3184&size=0&status=done&style=none&width=600"><br><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[1,4,7],[2,5,8],[3,6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-string">[[1,4],[2,5],[3,6]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>1 &lt;= m * n &lt;= 10</code></li><li><code>-10 &lt;= matrix[i][j] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简历结果矩阵，双重遍历赋值即可，注意构建矩阵时长度的问题，可能不是正方形。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> transpose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [...Array(matrix[<span class="hljs-number">0</span>].length)].map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span><br>    <span class="hljs-built_in">Array</span>(matrix.length).fill(<span class="hljs-number">0</span>)<br>  );<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].length; j++) &#123;<br>      res[j][i] = matrix[i][j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月25日</title>
    <link href="/2021/03/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/03/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1725. 可以形成最大正方形的矩形数目</p><span id="more"></span><h1 id="1725-可以形成最大正方形的矩形数目"><a href="#1725-可以形成最大正方形的矩形数目" class="headerlink" title="1725. 可以形成最大正方形的矩形数目"></a><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">1725. 可以形成最大正方形的矩形数目</a></h1><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [l, w]</code> 表示第 <code>i</code> 个矩形的长度为 <code>l</code> 、宽度为 <code>w</code> 。<br>如果存在 <code>k</code> 同时满足 <code>k &lt;= l</code> 和 <code>k &lt;= w</code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。<br>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。<br>返回可以切出边长为_ _<code>maxLen</code> 的正方形的矩形 <strong>数目</strong> 。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rectangles = <span class="hljs-comment">[<span class="hljs-comment">[5,8]</span>,<span class="hljs-comment">[3,9]</span>,<span class="hljs-comment">[5,12]</span>,<span class="hljs-comment">[16,5]</span>]</span><br>输出：3<br>解释：能从每个矩形中切出的最大正方形边长分别是 <span class="hljs-comment">[5,3,5,5]</span> 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rectangles = <span class="hljs-comment">[<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,7]</span>,<span class="hljs-comment">[4,3]</span>,<span class="hljs-comment">[3,7]</span>]</span><br>输出：3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rectangles.length &lt;= 1000</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= l, w &lt;= 10</code></li><li><code>l != w</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每一个正方形求得每个能求得的最大正方形，同时记录能得到的最大正方形，然后统计等于最大正方形数量相等的正方形数量返回即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">rectangles</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countGoodRectangles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rectangles</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = -<span class="hljs-literal">Infinity</span>;<br>  <span class="hljs-keyword">const</span> arr = rectangles.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Math</span>.min(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]);<br>    max = <span class="hljs-built_in">Math</span>.max(res, max);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e === max).length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月24日</title>
    <link href="/2021/03/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/03/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1460. 通过翻转子数组使两个数组相等</p><span id="more"></span><h1 id="1460-通过翻转子数组使两个数组相等"><a href="#1460-通过翻转子数组使两个数组相等" class="headerlink" title="1460. 通过翻转子数组使两个数组相等"></a><a href="https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/">1460. 通过翻转子数组使两个数组相等</a></h1><p>给你两个长度相同的整数数组 <code>target</code> 和 <code>arr</code> 。<br>每一步中，你可以选择 <code>arr</code> 的任意 <strong>非空子数组</strong> 并将它翻转。你可以执行此过程任意次。<br>如果你能让 <code>arr</code> 变得与 <code>target</code> 相同，返回 True；否则，返回 False 。<br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = <span class="hljs-comment">[1,2,3,4]</span>, arr = <span class="hljs-comment">[2,4,1,3]</span><br>输出：true<br>解释：你可以按照如下步骤使 arr 变成 target：<br>1- 翻转子数组 <span class="hljs-comment">[2,4,1]</span> ，arr 变成 <span class="hljs-comment">[1,4,2,3]</span><br>2- 翻转子数组 <span class="hljs-comment">[4,2]</span> ，arr 变成 <span class="hljs-comment">[1,2,4,3]</span><br>3- 翻转子数组 <span class="hljs-comment">[4,3]</span> ，arr 变成 <span class="hljs-comment">[1,2,3,4]</span><br>上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = [<span class="hljs-number">7</span>], arr = [<span class="hljs-number">7</span>]<br>输出：<span class="hljs-keyword">true</span><br>解释：arr 不需要做任何翻转已经与 <span class="hljs-keyword">target</span> 相等。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">target</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">12</span>], <span class="hljs-attr">arr</span> = [<span class="hljs-number">12</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>], arr = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>]<br>输出：<span class="hljs-keyword">false</span><br>解释：arr 没有数字 <span class="hljs-number">9</span> ，所以无论如何也无法变成 <span class="hljs-keyword">target</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">target</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>target.length == arr.length</code></li><li><code>1 &lt;= target.length &lt;= 1000</code></li><li><code>1 &lt;= target[i] &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为可以转动无限次，其实只是验证两个数组是否完全相同，如果相同就一定可以保证一样。用哈希表进行计数和删除，判断两个数组是否完全相同。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canBeEqual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(num)) map.set(num, map.get(num) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> map.set(num, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> target) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(num)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(num) === <span class="hljs-number">1</span>) map.delete(num);<br>    <span class="hljs-keyword">else</span> map.set(num, map.get(num) - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月23日</title>
    <link href="/2021/03/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/03/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1614. 括号的最大嵌套深度</p><span id="more"></span><h1 id="1614-括号的最大嵌套深度"><a href="#1614-括号的最大嵌套深度" class="headerlink" title="1614. 括号的最大嵌套深度"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">1614. 括号的最大嵌套深度</a></h1><p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串 <code>&quot;&quot;</code>，或者是一个不为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code> 的单字符。</li><li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li><li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li></ul><p>类似地，可以定义任何有效括号字符串 <code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>&quot;(&quot;</code> 或者 <code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li><li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>&quot;)(&quot;</code> 、<code>&quot;(()&quot;</code> 都不是 <strong>有效括号字符串</strong> 。<br>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的_ _<code>s</code> <strong>嵌套深度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(1+(2*3)+((8)/4))+1&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：数字 <span class="hljs-number">8</span> 在嵌套的 <span class="hljs-number">3</span> 层括号中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(1)+((2))+(((3)))&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1+(2*3)/(2-1)&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 组成</li><li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为是有效括号，所以不需要判断，当为右括号时，栈的 size 即为嵌套最深的深度，用一个 max 来记录即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;)&quot;</span>) &#123;<br>      max = <span class="hljs-built_in">Math</span>.max(stack.length, max);<br>      stack.pop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;(&quot;</span>) &#123;<br>      stack.push(char);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月22日</title>
    <link href="/2021/03/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/03/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt806. 写字符串需要的行数</p><span id="more"></span><h1 id="806-写字符串需要的行数"><a href="#806-写字符串需要的行数" class="headerlink" title="806. 写字符串需要的行数"></a><a href="https://leetcode-cn.com/problems/number-of-lines-to-write-string/">806. 写字符串需要的行数</a></h1><p>我们要把给定的字符串 <code>S</code> 从左到右写到每一行上，每一行的最大宽度为 100 个单位，如果我们在写某个字母的时候会使这行超过了 100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 <code>widths</code> ，这个数组  widths[0] 代表 ‘a’ 需要的单位， widths[1] 代表 ‘b’ 需要的单位，…， widths[25] 代表 ‘z’ 需要的单位。<br>现在回答两个问题：至少多少行能放下<code>S</code>，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为 2 的整数列表返回。<br><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入:<br>widths = [<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10,10,10,10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]<br>S = &quot;abcdefghijklmnopqrstuvwxyz&quot;<br>输出: [<span class="hljs-number">3</span>, <span class="hljs-number">60</span>]<br>解释:<br>所有的字符拥有相同的占用单位<span class="hljs-number">10</span>。所以书写所有的<span class="hljs-number">26</span>个字母，<br>我们需要<span class="hljs-number">2</span>个整行和占用<span class="hljs-number">60</span>个单位的一行。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]<br>S = <span class="hljs-string">&quot;bbbcccdddaaa&quot;</span><br><span class="hljs-section">输出: [2, 4]</span><br><span class="hljs-section">解释:</span><br>除去字母&#x27;a&#x27;所有的字符都是相同的单位10，并且字符串 <span class="hljs-string">&quot;bbbcccdddaa&quot;</span> 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.<br>最后一个字母 &#x27;a&#x27; 将会被写到第二行，因为第一行只剩下2个单位了。<br>所以，这个答案是2行，第二行有4个单位宽度。<br></code></pre></td></tr></table></figure><p><strong>注:</strong></p><ul><li>字符串 <code>S</code> 的长度在  [1, 1000] 的范围。</li><li><code>S</code> 只包含小写字母。</li><li><code>widths</code> 是长度为 <code>26</code>的数组。</li><li><code>widths[i]</code> 值的范围在 <code>[2, 10]</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每一个字符，通过 asc 码得到字符对应的宽度，用一个变量记录当前行剩余的宽度，如果为 0，则重置为 100，且行计数变量 count++，判断结束后当前行宽度减去当前字符宽度。最后返回行计数和最后一行使用的宽度 100-row。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">widths</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numberOfLines = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">widths, s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">const</span> width = widths[char.charCodeAt() - <span class="hljs-number">97</span>];<br>    <span class="hljs-keyword">if</span> (row &lt; width) &#123;<br>      count++;<br>      row = <span class="hljs-number">100</span>;<br>    &#125;<br>    row -= width;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [count, <span class="hljs-number">100</span> - row];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月21日</title>
    <link href="/2021/03/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/03/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1374. 生成每种字符都是奇数个的字符串</p><span id="more"></span><h1 id="1374-生成每种字符都是奇数个的字符串"><a href="#1374-生成每种字符都是奇数个的字符串" class="headerlink" title="1374. 生成每种字符都是奇数个的字符串"></a><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/">1374. 生成每种字符都是奇数个的字符串</a></h1><p>给你一个整数 <code>n</code>，请你返回一个含* <code>n</code> *个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> <em><strong>。</strong></em><br>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">4</span><br>输出：<span class="hljs-string">&quot;pppz&quot;</span><br>解释：<span class="hljs-string">&quot;pppz&quot;</span> 是一个满足题目要求的字符串，因为 &#x27;p&#x27; 出现 <span class="hljs-number">3</span> 次，且 &#x27;z&#x27; 出现 <span class="hljs-number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="hljs-string">&quot;ohhh&quot;</span> 和 <span class="hljs-string">&quot;love&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;xy&quot;</span><br>解释：<span class="hljs-string">&quot;xy&quot;</span> 是一个满足题目要求的字符串，因为 &#x27;x&#x27; 和 &#x27;y&#x27; 各出现 <span class="hljs-number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="hljs-string">&quot;ag&quot;</span> 和 <span class="hljs-string">&quot;ur&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-string">&quot;holasss&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 500</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断是奇数还是偶数，偶数就截取一个为 a，剩下的为 b。如果是奇数就截取两个为 ab 剩下的为 c 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> generateTheString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span>;<br>  <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>    ? <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n - <span class="hljs-number">1</span>).fill(<span class="hljs-string">&quot;b&quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>)<br>    : <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n - <span class="hljs-number">2</span>).fill(<span class="hljs-string">&quot;c&quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月20日</title>
    <link href="/2021/03/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/03/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1768. 交替合并字符串</p><span id="more"></span><h1 id="1768-交替合并字符串"><a href="#1768-交替合并字符串" class="headerlink" title="1768. 交替合并字符串"></a><a href="https://leetcode-cn.com/problems/merge-strings-alternately/">1768. 交替合并字符串</a></h1><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。<br>返回 <strong>合并后的字符串</strong> 。<br><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abc&quot;</span>, word2 = <span class="hljs-string">&quot;pqr&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcr&quot;</span><br>解释：字符串合并情况如下所示：<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c r<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;ab&quot;</span>, word2 = <span class="hljs-string">&quot;pqrs&quot;</span><br>输出：<span class="hljs-string">&quot;apbqrs&quot;</span><br>解释：注意，word2 比 word1 长，<span class="hljs-string">&quot;rs&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span><br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r   s<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span>   r   s<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abcd&quot;</span>, word2 = <span class="hljs-string">&quot;pq&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcd&quot;</span><br>解释：注意，word1 比 word2 长，<span class="hljs-string">&quot;cd&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c   d<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span><br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c   d<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 100</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，轮流按要求加入结果字符串，直到一个字符串为空，将还有剩余长度的字符串的剩余部分加入结果字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeAlternately = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word1, word2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; word1.length &amp;&amp; i &lt; word2.length; i++) &#123;<br>    res += word1[i] + word2[i];<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i &lt; word1.length) res += word1.slice(i);<br>  <span class="hljs-keyword">if</span> (i &lt; word2.length) res += word2.slice(i);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月19日</title>
    <link href="/2021/03/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/03/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1464. 数组中两元素的最大乘积</p><span id="more"></span><h1 id="1464-数组中两元素的最大乘积"><a href="#1464-数组中两元素的最大乘积" class="headerlink" title="1464. 数组中两元素的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/">1464. 数组中两元素的最大乘积</a></h1><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。<br>请你计算并返回该式的最大值。<br> <strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,4,5,2]<br>输出：12<br>解释：如果选择下标 <span class="hljs-attribute">i</span>=1 和 <span class="hljs-attribute">j</span>=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3<span class="hljs-number">*4</span> = 12 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [1,5,4,5]<br>输出：16<br>解释：选择下标 <span class="hljs-attribute">i</span>=1 和 <span class="hljs-attribute">j</span>=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,7]</span><br><span class="hljs-string">输出：12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>即为求数组中的两个最大值，降序排序后，返回前两个元素-1 的积即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProduct = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<br>  <span class="hljs-keyword">return</span> (nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>) * (nums[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月18日</title>
    <link href="/2021/03/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/03/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1337. 矩阵中战斗力最弱的 K 行</p><span id="more"></span><h1 id="1337-矩阵中战斗力最弱的-K-行"><a href="#1337-矩阵中战斗力最弱的-K-行" class="headerlink" title="1337. 矩阵中战斗力最弱的 K 行"></a><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">1337. 矩阵中战斗力最弱的 K 行</a></h1><p>给你一个大小为 <code>m * n</code> 的矩阵 <code>mat</code>，矩阵由若干军人和平民组成，分别用 1 和 0 表示。<br>请你返回矩阵中战斗力最弱的 <code>k</code> 行的索引，按从最弱到最强排序。<br>如果第 <em><strong>i</strong></em> 行的军人数量少于第 <em><strong>j</strong></em> 行，或者两行军人数量相同但*** i*** 小于 _<strong>j</strong>_，那么我们认为第*** i <strong><em>行的战斗力比第</em></strong> j *<strong>行弱。<br>军人 **总是</strong> 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat =<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,1,1,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,0,0,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,0,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,1,1,1]</span>]</span>,<br>k = 3<br>输出：<span class="hljs-comment">[2,0,3]</span><br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 2<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 2<br>行 4 -&gt; 5<br>从最弱到最强对这些行排序后得到 <span class="hljs-comment">[2,0,3,1,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：mat =<br><span class="hljs-comment">[<span class="hljs-comment">[1,0,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,1,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,0,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,0,0,0]</span>]</span>,<br>k = 2<br>输出：<span class="hljs-comment">[0,2]</span><br>解释：<br>每行中的军人数目：<br>行 0 -&gt; 1<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 1<br>从最弱到最强对这些行排序后得到 <span class="hljs-comment">[0,2,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>2 &lt;= n, m &lt;= 100</code></li><li><code>1 &lt;= k &lt;= m</code></li><li><code>matrix[i][j]</code> 不是 0 就是 1</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每一行，再遍历每一个人，计数，直到遍历到平民，返回计数以及下标。按照士兵计数进行排序，然后再截取 k 个元素，再用 map 返回下标组成的数组。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">mat</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kWeakestRows = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mat, k</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> mat<br>    .map(<span class="hljs-function">(<span class="hljs-params">row, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> row) &#123;<br>        <span class="hljs-keyword">if</span> (arr === <span class="hljs-number">1</span>) sum++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123; sum, index &#125;;<br>    &#125;)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.sum - b.sum)<br>    .slice(<span class="hljs-number">0</span>, k)<br>    .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.index);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月17日</title>
    <link href="/2021/03/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/03/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt228. 汇总区间</p><span id="more"></span><h1 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode-cn.com/problems/summary-ranges/">228. 汇总区间</a></h1><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。<br>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。<br>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-string">&quot;0-&gt;2&quot;</span>,<span class="hljs-string">&quot;4-&gt;5&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]<br>解释：区间范围是：<br>[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] --&gt; <span class="hljs-string">&quot;0-&gt;2&quot;</span><br>[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] --&gt; <span class="hljs-string">&quot;4-&gt;5&quot;</span><br>[<span class="hljs-number">7</span>,<span class="hljs-number">7</span>] --&gt; <span class="hljs-string">&quot;7&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;2-&gt;4&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;8-&gt;9&quot;</span>]<br>解释：区间范围是：<br>[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">&quot;0&quot;</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] --&gt; <span class="hljs-string">&quot;2-&gt;4&quot;</span><br>[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>] --&gt; <span class="hljs-string">&quot;6&quot;</span><br>[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] --&gt; <span class="hljs-string">&quot;8-&gt;9&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">-1</span>]<br>输出：[<span class="hljs-string">&quot;-1&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-string">&quot;0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 20</code></li><li><code>-2 &lt;= nums[i] &lt;= 2 - 1</code></li><li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li><li><code>nums</code> 按升序排列</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 prev 记录区间开始，遍历数组如果下一个数不等于当前数+1，那么就在结果数组中插入数组，判断区间范围是不是 1，如果大于等于 2，按照题意修改为对应格式。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> summaryRanges = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> prev = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums === nums.length - <span class="hljs-number">1</span>)<br>      res.push(prev === nums[i] ? [prev] : [prev, nums[i]]);<br>    <span class="hljs-keyword">if</span> (nums[i + <span class="hljs-number">1</span>] !== nums[i] + <span class="hljs-number">1</span>) &#123;<br>      res.push(prev === nums[i] ? [prev] : [prev, nums[i]]);<br>      prev = nums[i + <span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> (e.length === <span class="hljs-number">2</span> ? e.join(<span class="hljs-string">&quot;-&gt;&quot;</span>) : e[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;&quot;</span>));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月16日</title>
    <link href="/2021/03/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/03/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1684. 统计一致字符串的数目</p><span id="more"></span><h1 id="1684-统计一致字符串的数目"><a href="#1684-统计一致字符串的数目" class="headerlink" title="1684. 统计一致字符串的数目"></a><a href="https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/">1684. 统计一致字符串的数目</a></h1><p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串  **。<br>请你返回 <code>words</code> 数组中 **一致字符串</strong> 的数目。<br><strong>示例 1：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：allowed = <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;aaab&quot;</span>,<span class="hljs-string">&quot;baa&quot;</span>,<span class="hljs-string">&quot;badab&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：字符串 <span class="hljs-string">&quot;aaab&quot;</span> 和 <span class="hljs-string">&quot;baa&quot;</span> 都是一致字符串，因为它们只包含字符 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">allowed</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>]<br>输出：<span class="hljs-number">7</span><br>解释：所有字符串都是一致的。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">allowed</span> = <span class="hljs-string">&quot;cad&quot;</span>, <span class="hljs-attr">words</span> = [<span class="hljs-string">&quot;cc&quot;</span>,<span class="hljs-string">&quot;acd&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bad&quot;</span>,<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br>输出：<span class="hljs-number">4</span><br>解释：字符串 <span class="hljs-string">&quot;cc&quot;</span>，<span class="hljs-string">&quot;acd&quot;</span>，<span class="hljs-string">&quot;ac&quot;</span> 和 <span class="hljs-string">&quot;d&quot;</span> 是一致字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10</code></li><li><code>1 &lt;= allowed.length &lt;=26</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li><li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 set 记录 allowed 中的字符，遍历每一个单词，再遍历每一个单词中的字符，如果都在 set 中就计数加一。最后返回符合要求的字符数量。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">allowed</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countConsistentStrings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allowed, words</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> allowedSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(allowed.split(<span class="hljs-string">&quot;&quot;</span>));<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> word) &#123;<br>      <span class="hljs-keyword">if</span> (!allowedSet.has(char)) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月15日</title>
    <link href="/2021/03/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/03/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1022. 从根到叶的二进制数之和</p><span id="more"></span><h1 id="1022-从根到叶的二进制数之和"><a href="#1022-从根到叶的二进制数之和" class="headerlink" title="1022. 从根到叶的二进制数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></h1><p>给出一棵二叉树，其上每个结点的值都是 <code>0</code> 或 <code>1</code> 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数 <code>01101</code>，也就是 <code>13</code> 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。<br>返回这些数字之和。题目数据保证答案是一个 <strong>32 位  **整数。<br>**示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">22</span><br>解释：<span class="hljs-comment">(100)</span> + <span class="hljs-comment">(101)</span> + <span class="hljs-comment">(110)</span> + <span class="hljs-comment">(111)</span> = <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：root </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：root </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：root </span>=<span class="hljs-string"> [1,1]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的结点数介于 <code>1</code> 和 <code>1000</code> 之间。</li><li><code>Node.val</code> 为 <code>0</code> 或 <code>1</code> 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个 res 存放结果，当到根节点时将 res 转为字符串再转为 10 进制的值累加上，然后回溯出栈，直到遍历完所有路径。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumRootToLeaf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    res.push(node.val);<br>    <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;<br>      sum += <span class="hljs-built_in">parseInt</span>(res.slice().join(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-number">2</span>);<br>    &#125;<br>    visit(node.left);<br>    visit(node.right);<br>    res.pop();<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月14日</title>
    <link href="/2021/03/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/03/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1742. 盒子中小球的最大数量</p><span id="more"></span><h1 id="1742-盒子中小球的最大数量"><a href="#1742-盒子中小球的最大数量" class="headerlink" title="1742. 盒子中小球的最大数量"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-balls-in-a-box/">1742. 盒子中小球的最大数量</a></h1><p>你在一家生产小球的玩具厂工作，有 <code>n</code> 个小球，编号从 <code>lowLimit</code> 开始，到 <code>highLimit</code> 结束（包括 <code>lowLimit</code> 和 <code>highLimit</code> ，即 <code>n == highLimit - lowLimit + 1</code>）。另有无限数量的盒子，编号从 <code>1</code> 到 <code>infinity</code> 。<br>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 <code>321</code> 的小球应当放入编号 <code>3 + 2 + 1 = 6</code> 的盒子，而编号 <code>10</code> 的小球应当放入编号 <code>1 + 0 = 1</code> 的盒子。<br>给你两个整数 <code>lowLimit</code> 和 <code>highLimit</code> ，返回放有最多小球的盒子中的小球数量<em>。</em>如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：lowLimit = 1, highLimit = 10<br>输出：2<br>解释：<br>盒子编号：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 ...<br>小球数量：2<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span> ...<br>编号<span class="hljs-number"> 1 </span>的盒子放有最多小球，小球数量为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：lowLimit = 5, highLimit = 15<br>输出：2<br>解释：<br>盒子编号：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11 ...<br>小球数量：1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span> ...<br>编号<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 6 </span>的盒子放有最多小球，每个盒子中的小球数量都是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：lowLimit = 19, highLimit = 28<br>输出：2<br>解释：<br>盒子编号：1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11<span class="hljs-number"> 12 </span>...<br>小球数量：0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span> ...<br>编号<span class="hljs-number"> 10 </span>的盒子放有最多小球，小球数量为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= lowLimit &lt;= highLimit &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从 lowLimit 开始遍历某个数，求他应该放的箱子，用数组记录箱子内小球数量，记录完后 max 更新最大的小球数量，返回 max。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">lowLimit</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">highLimit</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countBalls = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">lowLimit, highLimit</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = lowLimit; i &lt;= highLimit; i++) &#123;<br>    <span class="hljs-keyword">let</span> num = (i + <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) + <span class="hljs-built_in">Number</span>(b));<br>    <span class="hljs-keyword">if</span> (res[num]) res[num]++;<br>    <span class="hljs-keyword">else</span> res[num] = <span class="hljs-number">1</span>;<br>    max = <span class="hljs-built_in">Math</span>.max(max, res[num]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月13日</title>
    <link href="/2021/03/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/03/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt566. 重塑矩阵</p><span id="more"></span><h1 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h1><p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。<br>如果具有给定参数的<code>reshape</code>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。<br><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入:<br>nums =<br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>r = <span class="hljs-number">1</span>, c = <span class="hljs-number">4</span><br>输出:<br><span class="hljs-string">[[1,2,3,4]]</span><br>解释:<br>行遍历nums的结果是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。新的矩阵是 <span class="hljs-number">1</span> * <span class="hljs-number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入:<br>nums =<br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>r = <span class="hljs-number">2</span>, c = <span class="hljs-number">4</span><br>输出:<br><span class="hljs-string">[[1,2],</span><br><span class="hljs-string"> [3,4]]</span><br>解释:<br>没有办法将 <span class="hljs-number">2</span> * <span class="hljs-number">2</span> 矩阵转化为 <span class="hljs-number">2</span> * <span class="hljs-number">4</span> 矩阵。 所以输出原矩阵。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>给定矩阵的宽和高范围在 [1, 100]。</li><li>给定的 r 和 c 都是正数。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先扁平化数组，计算需求矩阵的大小，如果大于原有的直接返回原数组。如果不是，用 splice 截取每行的个数，放入结果数组中，直到临时数组全部重新分配完，返回结果数组。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">r</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">c</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> matrixReshape = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, r, c</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> temp = nums.flat();<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">if</span> (r * c &gt; temp.length) <span class="hljs-keyword">return</span> nums;<br>  <span class="hljs-keyword">while</span> (temp.length) &#123;<br>    res.push(temp.splice(<span class="hljs-number">0</span>, c));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月12日</title>
    <link href="/2021/03/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/03/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt942. 增减字符串匹配</p><span id="more"></span><h1 id="942-增减字符串匹配"><a href="#942-增减字符串匹配" class="headerlink" title="942. 增减字符串匹配"></a><a href="https://leetcode-cn.com/problems/di-string-match/">942. 增减字符串匹配</a></h1><p>给定只含 <code>&quot;I&quot;</code>（增大）或 <code>&quot;D&quot;</code>（减小）的字符串 <code>S</code> ，令 <code>N = S.length</code>。<br>返回 <code>[0, 1, ..., N]</code> 的任意排列 <code>A</code> 使得对于所有 <code>i = 0, ..., N-1</code>，都有：</p><ul><li>如果 <code>S[i] == &quot;I&quot;</code>，那么 <code>A[i] &lt; A[i+1]</code></li><li>如果 <code>S[i] == &quot;D&quot;</code>，那么 <code>A[i] &gt; A[i+1]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;IDID&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;III&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;DDI&quot;</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= S.length &lt;= 10000</code></li><li><code>S</code> 只包含字符 <code>&quot;I&quot;</code> 或 <code>&quot;D&quot;</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置 min=0，max=S.length，如果当前字符是 I 就设为 min，然后 min++，是 D 就设为 max，然后 max–。最后返回结果数组。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> diStringMatch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>,<br>    max = S.length,<br>    i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (min &lt;= max) &#123;<br>    <span class="hljs-keyword">if</span> (S[i] === <span class="hljs-string">&quot;I&quot;</span>) res[i] = min++;<br>    <span class="hljs-keyword">else</span> res[i] = max--;<br>    i++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月11日</title>
    <link href="/2021/03/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/03/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt944. 删列造序</p><span id="more"></span><h1 id="944-删列造序"><a href="#944-删列造序" class="headerlink" title="944. 删列造序"></a><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted/">944. 删列造序</a></h1><p>给你由 <code>n</code> 个小写字母字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。<br>这些字符串可以每个一行，排成一个网格。例如，<code>strs = [&quot;abc&quot;, &quot;bce&quot;, &quot;cae&quot;]</code> 可以排列为：<br>abc<br>bce<br>cae<br>你需要找出并删除 <strong>不是按字典序升序排列的</strong> 列。在上面的例子（下标从 0 开始）中，列 0（<code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>）和列 2（<code>&#39;c&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;e&#39;</code>）都是按升序排列的，而列 1（<code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, <code>&#39;a&#39;</code>）不是，所以要删除列 1 。<br>返回你需要删除的列数。<br><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;cba&quot;</span>,<span class="hljs-string">&quot;daf&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>]<br>输出：<span class="hljs-number">1</span><br>解释：网格示意如下：<br>  cba<br>  daf<br>  ghi<br>列 <span class="hljs-number">0</span> 和列 <span class="hljs-number">2</span> 按升序排列，但列 <span class="hljs-number">1</span> 不是，所以只需要删除列 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：strs = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]</span><br>输出：<span class="hljs-number">0</span><br>解释：网格示意如下：<br>  <span class="hljs-selector-tag">a</span><br>  <span class="hljs-selector-tag">b</span><br>只有列 <span class="hljs-number">0</span> 这一列，且已经按升序排列，所以不用删除任何列。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;zyx&quot;</span>,<span class="hljs-string">&quot;wvu&quot;</span>,<span class="hljs-string">&quot;tsr&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：网格示意如下：<br>  zyx<br>  wvu<br>  tsr<br>所有 <span class="hljs-number">3</span> 列都是非升序排列的，所以都要删除。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == strs.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= strs[i].length &lt;= 1000</code></li><li><code>strs[i]</code> 由小写英文字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双重循环，将字符串看成数组，比较每列的英文字母是否是升序即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minDeletionSize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> length = strs[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">let</span> prev = strs[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>      <span class="hljs-keyword">const</span> cur = strs[j][i];<br>      <span class="hljs-keyword">if</span> (cur &lt; prev) &#123;<br>        res++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      prev = cur;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月10日</title>
    <link href="/2021/03/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/03/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1732. 找到最高海拔</p><span id="more"></span><h1 id="1732-找到最高海拔"><a href="#1732-找到最高海拔" class="headerlink" title="1732. 找到最高海拔"></a><a href="https://leetcode-cn.com/problems/find-the-highest-altitude/">1732. 找到最高海拔</a></h1><p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code> 个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code> 开始骑行。<br>给你一个长度为 <code>n</code> 的整数数组 <code>gain</code> ，其中 <code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code> 的 <strong>净海拔高度差</strong>（<code>0 &lt;= i &lt; n</code>）。请你返回 <strong>最高点的海拔</strong> 。<br><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：gain = [<span class="hljs-string">-5</span>,1,5,0,<span class="hljs-string">-7</span>]<br>输出：1<br>解释：海拔高度依次为 [0,<span class="hljs-string">-5</span>,<span class="hljs-string">-4</span>,1,1,<span class="hljs-string">-6</span>] 。最高海拔为 1 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：gain = [<span class="hljs-string">-4</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,4,3,2]<br>输出：0<br>解释：海拔高度依次为 [0,<span class="hljs-string">-4</span>,<span class="hljs-string">-7</span>,<span class="hljs-string">-9</span>,<span class="hljs-string">-10</span>,<span class="hljs-string">-6</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>] 。最高海拔为 0 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == gain.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= gain[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次计算实时位置，更新 res 即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">gain</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> largestAltitude = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gain</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>,<br>    cur = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; gain.length; i++) &#123;<br>    cur += gain[i];<br>    res = <span class="hljs-built_in">Math</span>.max(cur, res);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月9日</title>
    <link href="/2021/03/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%889%E6%97%A5/"/>
    <url>/2021/03/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt893. 特殊等价字符串组</p><span id="more"></span><h1 id="893-特殊等价字符串组"><a href="#893-特殊等价字符串组" class="headerlink" title="893. 特殊等价字符串组"></a><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/">893. 特殊等价字符串组</a></h1><p>你将得到一个字符串数组 <code>A</code>。<br>每次移动都可以交换 S 的任意两个偶数下标的字符或任意两个奇数下标的字符。<br>如果经过任意次数的移动，S == T，那么两个字符串 <code>S</code> 和 <code>T</code> 是 <strong>特殊等价  **的。<br>例如，<code>S = &quot;zzxy&quot;</code> 和 <code>T = &quot;xyzz&quot;</code> 是一对特殊等价字符串，因为可以先交换 <code>S[0]</code> 和 <code>S[2]</code>，然后交换 <code>S[1]</code> 和 <code>S[3]</code>，使得 <code>&quot;zzxy&quot; -&gt; &quot;xzzy&quot; -&gt; &quot;xyzz&quot;</code> 。<br>现在规定，</strong><code>A</code> **的 **一组特殊等价字符串  **就是 <code>A</code> 的一个同时满足下述条件的非空子集：</p><ol><li>该组中的每一对字符串都是**  特殊等价  **的</li><li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li></ol><p>返回 <code>A</code> 中特殊等价字符串组的数量。<br><strong>示例 1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：[<span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;cdab&quot;</span>,<span class="hljs-string">&quot;cbad&quot;</span>,<span class="hljs-string">&quot;xyzz&quot;</span>,<span class="hljs-string">&quot;zzxy&quot;</span>,<span class="hljs-string">&quot;zzyx&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<br>其中一组为 [<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;cdab&quot;</span>, <span class="hljs-string">&quot;cbad&quot;</span>]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。<br>另外两组分别是 [<span class="hljs-string">&quot;xyzz&quot;</span>, <span class="hljs-string">&quot;zzxy&quot;</span>] 和 [<span class="hljs-string">&quot;zzyx&quot;</span>]。特别需要注意的是，<span class="hljs-string">&quot;zzxy&quot;</span> 不与 <span class="hljs-string">&quot;zzyx&quot;</span> 特殊等价。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 组 [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]，[<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>]，[<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 1000</code></li><li><code>1 &lt;= A[i].length &lt;= 20</code></li><li>所有 <code>A[i]</code> 都具有相同的长度。</li><li>所有 <code>A[i]</code> 都只由小写字母组成。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个字符，将这个字符分隔开成奇数位数的数组和偶数位数的数组，因为可以无限交换所以再将两个数组排序以后拼接生成字符串加入集合中，最后返回集合的 size 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numSpecialEquivGroups = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> str <span class="hljs-keyword">of</span> A) &#123;<br>    <span class="hljs-keyword">const</span> odd = [],<br>      even = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) even.push(str[i]);<br>      <span class="hljs-keyword">else</span> odd.push(str[i]);<br>    &#125;<br>    even.sort();<br>    odd.sort();<br>    res.add(odd + even);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.size;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月8日</title>
    <link href="/2021/03/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%888%E6%97%A5/"/>
    <url>/2021/03/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt893. 特殊等价字符串组</p><span id="more"></span><h1 id="893-特殊等价字符串组"><a href="#893-特殊等价字符串组" class="headerlink" title="893. 特殊等价字符串组"></a><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/">893. 特殊等价字符串组</a></h1><p>你将得到一个字符串数组 <code>A</code>。<br>每次移动都可以交换 S 的任意两个偶数下标的字符或任意两个奇数下标的字符。<br>如果经过任意次数的移动，S == T，那么两个字符串 <code>S</code> 和 <code>T</code> 是 <strong>特殊等价  **的。<br>例如，<code>S = &quot;zzxy&quot;</code> 和 <code>T = &quot;xyzz&quot;</code> 是一对特殊等价字符串，因为可以先交换 <code>S[0]</code> 和 <code>S[2]</code>，然后交换 <code>S[1]</code> 和 <code>S[3]</code>，使得 <code>&quot;zzxy&quot; -&gt; &quot;xzzy&quot; -&gt; &quot;xyzz&quot;</code> 。<br>现在规定，</strong><code>A</code> **的 **一组特殊等价字符串  **就是 <code>A</code> 的一个同时满足下述条件的非空子集：</p><ol><li>该组中的每一对字符串都是**  特殊等价  **的</li><li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li></ol><p>返回 <code>A</code> 中特殊等价字符串组的数量。<br><strong>示例 1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：[<span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;cdab&quot;</span>,<span class="hljs-string">&quot;cbad&quot;</span>,<span class="hljs-string">&quot;xyzz&quot;</span>,<span class="hljs-string">&quot;zzxy&quot;</span>,<span class="hljs-string">&quot;zzyx&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<br>其中一组为 [<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;cdab&quot;</span>, <span class="hljs-string">&quot;cbad&quot;</span>]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。<br>另外两组分别是 [<span class="hljs-string">&quot;xyzz&quot;</span>, <span class="hljs-string">&quot;zzxy&quot;</span>] 和 [<span class="hljs-string">&quot;zzyx&quot;</span>]。特别需要注意的是，<span class="hljs-string">&quot;zzxy&quot;</span> 不与 <span class="hljs-string">&quot;zzyx&quot;</span> 特殊等价。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 组 [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]，[<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>]，[<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 1000</code></li><li><code>1 &lt;= A[i].length &lt;= 20</code></li><li>所有 <code>A[i]</code> 都具有相同的长度。</li><li>所有 <code>A[i]</code> 都只由小写字母组成。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个字符，将这个字符分隔开成奇数位数的数组和偶数位数的数组，因为可以无限交换所以再将两个数组排序以后拼接生成字符串加入集合中，最后返回集合的 size 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numSpecialEquivGroups = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> str <span class="hljs-keyword">of</span> A) &#123;<br>    <span class="hljs-keyword">const</span> odd = [],<br>      even = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) even.push(str[i]);<br>      <span class="hljs-keyword">else</span> odd.push(str[i]);<br>    &#125;<br>    even.sort();<br>    odd.sort();<br>    res.add(odd + even);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.size;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月7日</title>
    <link href="/2021/03/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%887%E6%97%A5/"/>
    <url>/2021/03/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt.896. 单调数列</p><span id="more"></span><h1 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896. 单调数列"></a><a href="https://leetcode-cn.com/problems/monotonic-array/">896. 单调数列</a></h1><p>如果数组是单调递增或单调递减的，那么它是<em>单调的</em>。<br>如果对于所有 <code>i &lt;= j</code>，<code>A[i] &lt;= A[j]</code>，那么数组 <code>A</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>A[i]&gt; = A[j]</code>，那么数组 <code>A</code> 是单调递减的。<br>当给定的数组 <code>A</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。<br><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例  5：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 50000</code></li><li><code>-100000 &lt;= A[i] &lt;= 100000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有数，直到当前数和上一个数不同，这时候判断是递增还是递减，之后的数如果不符合要求则直接返回 false。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>用两个状态记录是否有出现递增或递减状态，如果都有的话，返回 false。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isMonotonic = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (A.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> isIncrease = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; A.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (isIncrease === <span class="hljs-literal">null</span> &amp;&amp; A[i] !== A[i - <span class="hljs-number">1</span>]) &#123;<br>      isIncrease = A[i] &gt; A[i - <span class="hljs-number">1</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (isIncrease &amp;&amp; A[i] &lt; A[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIncrease &amp;&amp; A[i] &gt; A[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isMonotonic = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (A.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> isIncrease = <span class="hljs-literal">false</span>,<br>    isDecrease = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (A[i] &lt; A[i + <span class="hljs-number">1</span>]) isIncrease = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (A[i] &gt; A[i + <span class="hljs-number">1</span>]) isDecrease = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (isIncrease &amp;&amp; isDecrease) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月6日</title>
    <link href="/2021/03/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%886%E6%97%A5/"/>
    <url>/2021/03/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 16.11. 跳水板</p><span id="more"></span><h1 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a><a href="https://leetcode-cn.com/problems/diving-board-lcci/">面试题 16.11. 跳水板</a></h1><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要从小到大排列。<br><strong>示例 1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：<br>shorter = 1<br>longer = 2<br>k = 3<br>输出： [3,4,5,6]<br>解释：<br>可以使用<span class="hljs-number"> 3 </span>次 shorter，得到结果 3；使用<span class="hljs-number"> 2 </span>次 shorter 和<span class="hljs-number"> 1 </span>次 longer，得到结果<span class="hljs-number"> 4 </span>。以此类推，得到最终结果。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt; shorter &lt;= longer</li><li>0 &lt;= k &lt;= 100000</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先优先取短的木板，长的为 k-i 个木板，计算长度，加入数组中。注意处理 k=0 和 shorter===longer 的情况即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">shorter</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">longer</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> divingBoard = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">shorter, longer, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">if</span> (shorter === longer) <span class="hljs-keyword">return</span> [k];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> longerNum = k - i;<br>    res.push(shorter * i + longer * longerNum);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月5日</title>
    <link href="/2021/03/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%885%E6%97%A5/"/>
    <url>/2021/03/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1232. 缀点成线</p><span id="more"></span><h1 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h1><p>在一个  XY 坐标系中有一些点，我们用数组 <code>coordinates</code> 来分别记录它们的坐标，其中 <code>coordinates[i] = [x, y]</code> 表示横坐标为 <code>x</code>、纵坐标为 <code>y</code> 的点。<br>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回 <code>false</code>。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1614955716340-79c81613-e94a-451d-a413-5ccee9698efc.jpeg#align=left&display=inline&height=336&margin=%5Bobject%20Object%5D&originHeight=336&originWidth=336&size=0&status=done&style=none&width=336"><br><strong>输入：</strong>coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1614955716475-a61aa65a-df7f-4766-9808-9dd5d36997d3.jpeg#align=left&display=inline&height=336&margin=%5Bobject%20Object%5D&originHeight=336&originWidth=348&size=0&status=done&style=none&width=348"></strong><br><strong>输入：</strong>coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br><strong>输出：</strong>false<br><strong>提示：</strong></p><ul><li><code>2 &lt;= coordinates.length &lt;= 1000</code></li><li><code>coordinates[i].length == 2</code></li><li><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></li><li><code>coordinates</code> 中不含重复的点</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解构赋值取得点的值，从第二个点开始计算每个点和下一个的斜率是否都等于第一个点和第二个点的斜率，用乘法防止除数为 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">coordinates</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkStraightLine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">coordinates</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [[x1, y1], [x2, y2]] = coordinates;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; coordinates.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> [[x3, y3], [x4, y4]] = [coordinates[i], coordinates[i + <span class="hljs-number">1</span>]];<br>    <span class="hljs-keyword">if</span> ((y2 - y1) * (x4 - x3) !== (y4 - y3) * (x2 - x1)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月4日</title>
    <link href="/2021/03/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%884%E6%97%A5/"/>
    <url>/2021/03/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt997. 找到小镇的法官</p><span id="more"></span><h1 id="997-找到小镇的法官"><a href="#997-找到小镇的法官" class="headerlink" title="997. 找到小镇的法官"></a><a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></h1><p>在一个小镇里，按从 <code>1</code> 到 <code>N</code> 标记了 <code>N</code> 个人。传言称，这些人中有一个是小镇上的秘密法官。<br>如果小镇的法官真的存在，那么：</p><ol><li>小镇的法官不相信任何人。</li><li>每个人（除了小镇法官外）都信任小镇的法官。</li><li>只有一个人同时满足属性 1 和属性 2 。</li></ol><p>给定数组 <code>trust</code>，该数组由信任对 <code>trust[i] = [a, b]</code> 组成，表示标记为 <code>a</code> 的人信任标记为 <code>b</code> 的人。<br>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：N = <span class="hljs-number">2</span>, trust = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：N = <span class="hljs-number">3</span>, trust = <span class="hljs-string">[[1,3],[2,3]]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：N = <span class="hljs-number">3</span>, trust = <span class="hljs-string">[[1,3],[2,3],[3,1]]</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：N = <span class="hljs-number">3</span>, trust = <span class="hljs-string">[[1,2],[2,3]]</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：N = 4, trust = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[4,3]</span>]</span><br>输出：3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 1000</code></li><li><code>trust.length &lt;= 10000</code></li><li><code>trust[i]</code> 是完全不同的</li><li><code>trust[i][0] != trust[i][1]</code></li><li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用两个哈希表分别存储被信赖和信赖的计数次数，筛选出被所有人信赖且自己不信赖任何人的那个人，如果不存在则返回-1</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">N</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">trust</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findJudge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">N, trust</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (N === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> trustMap = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> e <span class="hljs-keyword">of</span> trust) &#123;<br>    [a, b] = e;<br>    <span class="hljs-keyword">if</span> (map[b]) map[b]++;<br>    <span class="hljs-keyword">else</span> map[b] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (trustMap[a]) trustMap[a]++;<br>    <span class="hljs-keyword">else</span> trustMap[a] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> res = [...Object.entries(map)]<br>    .filter(<span class="hljs-function">(<span class="hljs-params">[a, b]</span>) =&gt;</span> b === N - <span class="hljs-number">1</span>)<br>    .flat()[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">return</span> res ? (trustMap[res] ? -<span class="hljs-number">1</span> : res) : -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月3日</title>
    <link href="/2021/03/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%883%E6%97%A5/"/>
    <url>/2021/03/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1137. 第 N 个泰波那契数</p><span id="more"></span><h1 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h1><p>泰波那契序列  T 定义如下： <br>T = 0, T = 1, T = 1, 且在 n &gt;= 0  的条件下 T = T + T + T<br>给你整数 <code>n</code>，请返回第 n 个泰波那契数  T 的值。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：4<br>解释：<br>T_3 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 2<br>T_4 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">25</span><br>输出：<span class="hljs-number">1389537</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>同斐波那契数列动态规划思路，只需要记录三个数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> tribonacci = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> first = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> middle = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    [first, middle, last] = [middle, last, first + middle + last];<br>  &#125;<br>  <span class="hljs-keyword">return</span> last;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月2日</title>
    <link href="/2021/03/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%882%E6%97%A5/"/>
    <url>/2021/03/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1422. 分割字符串的最大得分</p><span id="more"></span><h1 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422. 分割字符串的最大得分"></a><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/">1422. 分割字符串的最大得分</a></h1><p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即 <strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。<br>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;011101&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br>将字符串 s 划分为两个非空子字符串的可行方案有：<br>左子字符串 = <span class="hljs-string">&quot;0&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;11101&quot;</span>，得分 = <span class="hljs-number">1</span> + <span class="hljs-number">4</span> = <span class="hljs-number">5</span><br>左子字符串 = <span class="hljs-string">&quot;01&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;1101&quot;</span>，得分 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span><br>左子字符串 = <span class="hljs-string">&quot;011&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;101&quot;</span>，得分 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br>左子字符串 = <span class="hljs-string">&quot;0111&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;01&quot;</span>，得分 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span><br>左子字符串 = <span class="hljs-string">&quot;01110&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;1&quot;</span>，得分 = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;00111&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：当 左子字符串 = <span class="hljs-string">&quot;00&quot;</span> 且 右子字符串 = <span class="hljs-string">&quot;111&quot;</span> 时，我们得到最大得分 = <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= s.length &lt;= 500</code></li><li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用两个数记录当前分隔的左边的 0 数量，右边 1 的数量。<br>遍历字符串，相当于开始分隔字符，如果当前是 0，说明一个 0 被分到左边了，则左边的计数加 1；如果是 1 则右边计数减 1，说明一个 1 被分到左边了。之后更新最大的得分，遍历后返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxScore = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> lastZero = s[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;0&quot;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,<br>    lastOne = s.slice(<span class="hljs-number">1</span>).replace(<span class="hljs-regexp">/0/g</span>, <span class="hljs-string">&quot;&quot;</span>).length;<br>  <span class="hljs-keyword">let</span> max = lastZero + lastOne;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; s.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>      lastZero++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastOne--;<br>    &#125;<br>    max = <span class="hljs-built_in">Math</span>.max(max, lastZero + lastOne);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年3月1日</title>
    <link href="/2021/03/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%881%E6%97%A5/"/>
    <url>/2021/03/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B43%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt680. 验证回文字符串 Ⅱ</p><span id="more"></span><h1 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h1><p>难度简单 324 收藏分享切换为英文接收动态反馈<br>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。<br><strong>示例 1:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;aba&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abca&quot;</span><br><span class="hljs-section">输出: True</span><br><span class="hljs-section">解释: 你可以删除c字符。</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串只包含从 a-z 的小写字母。字符串的最大长度是 50000。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用双指针求字符串是否是回文字符串，当两个指针指向的字符不同了，可以知道，两个指针以外的字符已经可以构成回文字符串，只需要知道删除了左指针或者右指针指向的那个字符以后，中间的字符串是否也能构成回文字符。所以只需要再对第（i+1，j）（意味着删除左指针的那个字符）或者（i，j-1）（意味着删除右指针的那个字符）下标间的字符串进行判断是否其任意一个是不是回文字符串，是的话就可以删除一个字符得到一个回文字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> validPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> isValid = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>      <span class="hljs-keyword">if</span> (s[i++] !== s[j--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,<br>    j = s.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] !== s[j]) <span class="hljs-keyword">return</span> isValid(i + <span class="hljs-number">1</span>, j) || isValid(i, j - <span class="hljs-number">1</span>);<br>    i++;<br>    j--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月28日</title>
    <link href="/2021/02/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/02/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1496. 判断路径是否相交</p><span id="more"></span><h1 id="1496-判断路径是否相交"><a href="#1496-判断路径是否相交" class="headerlink" title="1496. 判断路径是否相交"></a><a href="https://leetcode-cn.com/problems/path-crossing/">1496. 判断路径是否相交</a></h1><p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code> 的值可以是 <code>&#39;N&#39;</code>、<code>&#39;S&#39;</code>、<code>&#39;E&#39;</code> 或者 <code>&#39;W&#39;</code>，分别表示向北、向南、向东、向西移动一个单位。<br>机器人从二维平面上的原点 <code>(0, 0)</code> 处开始出发，按 <code>path</code> 所指示的路径行走。<br>如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 <code>True</code> ；否则，返回 <code>False</code> 。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1614498905297-74a7a6b1-0a64-4f33-9b71-c7e6ff512e52.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=656&originWidth=732&size=0&status=done&style=none&width=250"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-built_in">path</span> = <span class="hljs-string">&quot;NES&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：该路径没有在任何位置相交。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1614498905361-a424d53c-3239-4590-99a1-ac05a63f2e65.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&originHeight=720&originWidth=850&size=0&status=done&style=none&width=250"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-built_in">path</span> = <span class="hljs-string">&quot;NESWW&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：该路径经过原点两次。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= path.length &lt;= 10^4</code></li><li><code>path</code> 仅由 <code>&#123;&#39;N&#39;, &#39;S&#39;, &#39;E&#39;, &#39;W&#125;</code> 中的字符组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 set 记录已走过的坐标格式化后的字符串，如果 set 中有则返回 true。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">path</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPathCrossing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> posSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;(0,0)&quot;</span>]);<br>  <span class="hljs-keyword">let</span> horizontal = <span class="hljs-number">0</span>,<br>    vertical = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> path) &#123;<br>    <span class="hljs-keyword">switch</span> (arr) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;N&quot;</span>: &#123;<br>        vertical++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;S&quot;</span>: &#123;<br>        vertical--;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;E&quot;</span>: &#123;<br>        horizontal++;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;W&quot;</span>: &#123;<br>        horizontal--;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> posStr = <span class="hljs-string">`(<span class="hljs-subst">$&#123;horizontal&#125;</span>,<span class="hljs-subst">$&#123;vertical&#125;</span>)`</span>;<br>    <span class="hljs-keyword">if</span> (posSet.has(posStr)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> posSet.add(posStr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月27日</title>
    <link href="/2021/02/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/02/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1539. 第 k 个缺失的正整数</p><span id="more"></span><h1 id="1539-第-k-个缺失的正整数"><a href="#1539-第-k-个缺失的正整数" class="headerlink" title="1539. 第 k 个缺失的正整数"></a><a href="https://leetcode-cn.com/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></h1><p>给你一个 <strong>严格升序排列</strong> 的正整数数组 <code>arr</code> 和一个整数 <code>k</code> 。<br>请你找到这个数组里第 <code>k</code> 个缺失的正整数。<br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">2,3,4,7</span>,<span class="hljs-number">11</span>], k = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">9</span><br>解释：缺失的正整数包括 [<span class="hljs-number">1,5,6,8</span>,<span class="hljs-number">9,10,12,13</span>,...] 。第 <span class="hljs-number">5</span> 个缺失的正整数为 <span class="hljs-number">9</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[1,2,3,4]</span>, k = 2<br>输出：6<br>解释：缺失的正整数包括 <span class="hljs-comment">[5,6,7,...]</span> 。第 2 个缺失的正整数为 6 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li>对于所有 <code>1 &lt;= i &lt; j &lt;= arr.length</code> 的 <code>i</code> 和 <code>j</code> 满足 <code>arr[i] &lt; arr[j]</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 set 记录整数，从 1 开始不断加一遍历，如果当前数不在集合里则计数加一，如果计数等于 k 返回当前数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findKthPositive = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr, k</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>    i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!numSet.has(i)) count++;<br>    <span class="hljs-keyword">if</span> (count === k) <span class="hljs-keyword">return</span> i;<br>    i++;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月26日</title>
    <link href="/2021/02/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/02/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1287. 有序数组中出现次数超过 25%的元素</p><span id="more"></span><h1 id="1287-有序数组中出现次数超过-25-的元素"><a href="#1287-有序数组中出现次数超过-25-的元素" class="headerlink" title="1287. 有序数组中出现次数超过 25%的元素"></a><a href="https://leetcode-cn.com/problems/element-appearing-more-than-25-in-sorted-array/">1287. 有序数组中出现次数超过 25%的元素</a></h1><p>给你一个非递减的 <strong>有序  **整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。<br>请你找到并返回这个整数<br> **示例：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1,2,2,6</span>,<span class="hljs-number">6,6,6,7</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^4</code></li><li><code>0 &lt;= arr[i] &lt;= 10^5</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>注意数组已经排好序，当当前元素和当前元素后总数组四分之一长度的元素相同时，说明当前元素是目标元素。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findSpecialInteger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, length = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">4</span>);<br>    i &lt; arr.length - length;<br>    i++<br>  )<br>    <span class="hljs-keyword">if</span> (arr[i] === arr[i + length]) <span class="hljs-keyword">return</span> arr[i];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月25日</title>
    <link href="/2021/02/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/02/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1332. 删除回文子序列</p><span id="more"></span><h1 id="1332-删除回文子序列"><a href="#1332-删除回文子序列" class="headerlink" title="1332. 删除回文子序列"></a><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></h1><p>给你一个字符串 <code>s</code>，它仅由字母 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。<br>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。<br>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。<br>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ababa&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：字符串本身就是回文序列，只需要删除一次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;abb&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;abb&quot;</span> -&gt; <span class="hljs-string">&quot;bb&quot;</span> -&gt; <span class="hljs-string">&quot;&quot;</span>.<br>先删除回文子序列 <span class="hljs-string">&quot;a&quot;</span>，然后再删除 <span class="hljs-string">&quot;bb&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;baabb&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;baabb&quot;</span> -&gt; <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-string">&quot;&quot;</span>.<br>先删除回文子序列 <span class="hljs-string">&quot;baab&quot;</span>，然后再删除 <span class="hljs-string">&quot;b&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅包含字母  ‘a’  和 ‘b’</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>注意是子序列，任意字符串，总能一次取出所有 a 作为一个回文子序列删除，剩余 b 作为另外一个回文子序列删除。所以仅存在以下情况：</p><ol><li>空字符串返回 0；</li><li>本身就是回文字符串返回 1；</li><li>其他情况返回 2；</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removePalindromeSub = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>) === s) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月24日</title>
    <link href="/2021/02/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/02/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1748. 唯一元素的和</p><span id="more"></span><h1 id="1748-唯一元素的和"><a href="#1748-唯一元素的和" class="headerlink" title="1748. 唯一元素的和"></a><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和</a></h1><p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 <strong>恰好一次</strong> 的元素。<br>请你返回 <code>nums</code> 中唯一元素的 <strong>和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,2]</span><br>输出：4<br>解释：唯一元素为 <span class="hljs-comment">[1,3]</span> ，和为 4 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,1,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：没有唯一元素，和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">15</span><br>解释：唯一元素为 <span class="hljs-string">[1,2,3,4,5]</span> ，和为 <span class="hljs-number">15</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一次出现就都加入 set 中，map 记录是否已经出现过，出现过的话，删除 set 中的数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumOfUnique = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map[num]) &#123;<br>      res.delete(num);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    map[num] = <span class="hljs-literal">true</span>;<br>    res.add(num);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.size ? [...res.values()].reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b) : <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月23日</title>
    <link href="/2021/02/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/02/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt598. 范围求和 II</p><span id="more"></span><h1 id="598-范围求和-II"><a href="#598-范围求和-II" class="headerlink" title="598. 范围求和 II"></a><a href="https://leetcode-cn.com/problems/range-addition-ii/">598. 范围求和 II</a></h1><p>给定一个初始元素全部为 <strong>0</strong>，大小为 m*n 的矩阵 <strong>M **以及在 **M **上的一系列更新操作。<br>操作用二维数组表示，其中的每个操作用一个含有两个</strong>正整数  a** 和 <strong>b</strong> 的数组表示，含义是将所有符合 <strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素 <strong>M[i][j] **的值都</strong>增加 1<strong>。<br>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。<br>**示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入:<br>m = <span class="hljs-number">3</span>, n = <span class="hljs-number">3</span><br>operations = <span class="hljs-string">[[2,2],[3,3]]</span><br>输出: <span class="hljs-number">4</span><br>解释:<br>初始状态, M =<br><span class="hljs-string">[[0, 0, 0],</span><br><span class="hljs-string"> [0, 0, 0],</span><br><span class="hljs-string"> [0, 0, 0]]</span><br>执行完操作 [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 后, M =<br><span class="hljs-string">[[1, 1, 0],</span><br><span class="hljs-string"> [1, 1, 0],</span><br><span class="hljs-string"> [0, 0, 0]]</span><br>执行完操作 [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 后, M =<br><span class="hljs-string">[[2, 2, 1],</span><br><span class="hljs-string"> [2, 2, 1],</span><br><span class="hljs-string"> [1, 1, 1]]</span><br></code></pre></td></tr></table></figure><p>M 中最大的整数是 2, 而且 M 中有 4 个值为 2 的元素。因此返回 4。<br><strong>注意:</strong></p><ol><li>m 和 n 的范围是  [1,40000]。</li><li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li><li>操作数目不超过 10000。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>矩阵左上角必为(0,0)，所以所有矩阵都必定有重叠部分，求所有 ops 分别求得最小的横坐标和纵坐标。这个点和(0,0)构成矩阵必定被重复加过最多次，返回这个矩阵的面积结果即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">ops</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxCount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m, n, ops</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!ops.length) <span class="hljs-keyword">return</span> m * n;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-literal">Infinity</span>,<br>    y = <span class="hljs-literal">Infinity</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> op <span class="hljs-keyword">of</span> ops) &#123;<br>    <span class="hljs-keyword">const</span> [i, j] = op;<br>    x = <span class="hljs-built_in">Math</span>.min(i, x);<br>    y = <span class="hljs-built_in">Math</span>.min(j, y);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x * y;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月22日</title>
    <link href="/2021/02/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/02/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1128. 等价多米诺骨牌对的数量</p><span id="more"></span><h1 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/">1128. 等价多米诺骨牌对的数量</a></h1><p>你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。<br>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。<br>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a==c</code> 且 <code>b==d</code>，或是 <code>a==d</code> 且 <code>b==c</code>。<br>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。<br> <strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：dominoes = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>]</span><br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dominoes.length &lt;= 40000</code></li><li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力双重循环可以很容易得到答案。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>遍历，将等价多米诺牌进行计数，若不存在，则在哈希表中开始记录，若存在，说明当前牌可以和这个等价牌堆里的所有牌组成一个新对子，若当前牌堆有 n 个，组成的新对子数量新增 n 个。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">dominoes</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numEquivDominoPairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dominoes</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dominoes.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> [a, b] = dominoes[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; dominoes.length; j++) &#123;<br>      <span class="hljs-keyword">const</span> [c, d] = dominoes[j];<br>      <span class="hljs-keyword">if</span> ((a === d &amp;&amp; b === c) || (a === c &amp;&amp; b === d)) res++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">dominoes</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numEquivDominoPairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dominoes</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dominoe <span class="hljs-keyword">of</span> dominoes) &#123;<br>    <span class="hljs-keyword">let</span> [a, b] = dominoe;<br>    <span class="hljs-keyword">const</span> key = a &gt; b ? a + <span class="hljs-number">10</span> * b : b + a * <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (map[key]) res += map[key]++;<br>    <span class="hljs-keyword">else</span> map[key] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月21日</title>
    <link href="/2021/02/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/02/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt961. 重复 N 次的元素</p><span id="more"></span><h1 id="961-重复-N-次的元素"><a href="#961-重复-N-次的元素" class="headerlink" title="961. 重复 N 次的元素"></a><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/">961. 重复 N 次的元素</a></h1><p>在大小为 <code>2N</code> 的数组 <code>A</code> 中有 <code>N+1</code> 个不同的元素，其中有一个元素重复了 <code>N</code> 次。<br>返回重复了 <code>N</code> 次的那个元素。<br> <strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,3,3]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,1,2,5,3,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例  3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">5,1,5,2</span>,<span class="hljs-number">5,3,5,4</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>4 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt; 10000</code></li><li><code>A.length</code> 为偶数</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题得到的元素为 n/2 个，不能直接使用摩尔投票。用哈希表记录次数，当出现次数为 n/2 次时，返回元素。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> repeatedNTimes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = A.length / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> e <span class="hljs-keyword">of</span> A) &#123;<br>    <span class="hljs-keyword">if</span> (map.get(e) + <span class="hljs-number">1</span> === count) <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span> map.set(e, map.has(e) ? map.get(e) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月20日</title>
    <link href="/2021/02/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/02/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt766. 托普利茨矩阵</p><span id="more"></span><h1 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></h1><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回_ <em><code>false</code></em> 。*<br>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是* _<strong>托普利茨矩阵</strong> 。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1613822109929-68826a4c-b047-4047-8809-e180e9aebe5e.jpeg#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=322&size=0&status=done&style=none&width=322"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>在上述矩阵中, 其对角线为:<br><span class="hljs-string">&quot;[9]&quot;</span>, <span class="hljs-string">&quot;[5, 5]&quot;</span>, <span class="hljs-string">&quot;[1, 1, 1]&quot;</span>, <span class="hljs-string">&quot;[2, 2, 2]&quot;</span>, <span class="hljs-string">&quot;[3, 3]&quot;</span>, <span class="hljs-string">&quot;[4]&quot;</span>。<br>各条对角线上的所有元素均相同, 因此答案是 True 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1613822110004-6cfe8cf8-975d-44ff-a494-f17aa60dfd9e.jpeg#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=162&size=0&status=done&style=none&width=162"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[2,2]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>对角线 <span class="hljs-string">&quot;[1, 2]&quot;</span> 上的元素不同。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 20</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li><li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断每个数是否和他右上角元素相等即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isToeplitzMatrix = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; matrix.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; matrix[i].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (matrix[i][j] != matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月19日</title>
    <link href="/2021/02/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/02/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt762. 二进制表示中质数个计算置位</p><span id="more"></span><h1 id="762-二进制表示中质数个计算置位"><a href="#762-二进制表示中质数个计算置位" class="headerlink" title="762. 二进制表示中质数个计算置位"></a><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/">762. 二进制表示中质数个计算置位</a></h1><p>给定两个整数 <code>L</code> 和 <code>R</code> ，找到闭区间 <code>[L, R]</code> 范围内，计算置位位数为质数的整数个数。<br>（注意，计算置位代表二进制表示中 1 的个数。例如 <code>21</code> 的二进制表示 <code>10101</code> 有 3 个计算置位。还有，1 不是质数。）<br><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: L = <span class="hljs-number">6</span>, R = <span class="hljs-number">10</span><br>输出: <span class="hljs-number">4</span><br>解释:<br><span class="hljs-number">6</span> -&gt; <span class="hljs-number">110</span> (<span class="hljs-number">2</span> 个计算置位，<span class="hljs-number">2</span> 是质数)<br><span class="hljs-number">7</span> -&gt; <span class="hljs-number">111</span> (<span class="hljs-number">3</span> 个计算置位，<span class="hljs-number">3</span> 是质数)<br><span class="hljs-number">9</span> -&gt; <span class="hljs-number">1001</span> (<span class="hljs-number">2</span> 个计算置位，<span class="hljs-number">2</span> 是质数)<br><span class="hljs-number">10</span>-&gt; <span class="hljs-number">1010</span> (<span class="hljs-number">2</span> 个计算置位，<span class="hljs-number">2</span> 是质数)<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: L = 10, R = 15<br>输出: 5<br>解释:<br>10 -&gt;<span class="hljs-number"> 1010 </span>(2 个计算置位,<span class="hljs-number"> 2 </span>是质数)<br>11 -&gt;<span class="hljs-number"> 1011 </span>(3 个计算置位,<span class="hljs-number"> 3 </span>是质数)<br>12 -&gt;<span class="hljs-number"> 1100 </span>(2 个计算置位,<span class="hljs-number"> 2 </span>是质数)<br>13 -&gt;<span class="hljs-number"> 1101 </span>(3 个计算置位,<span class="hljs-number"> 3 </span>是质数)<br>14 -&gt;<span class="hljs-number"> 1110 </span>(3 个计算置位,<span class="hljs-number"> 3 </span>是质数)<br>15 -&gt;<span class="hljs-number"> 1111 </span>(4 个计算置位,<span class="hljs-number"> 4 </span>不是质数)<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>L, R</code> 是 <code>L &lt;= R</code> 且在 <code>[1, 10^6]</code> 中的整数。</li><li><code>R - L</code> 的最大值为 10000。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力求解，然后判断是否是素数即可。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>去除数组操作。整数小于 32 位，用一个 set 记录小于等于 32 的素数判断是否在其中免去是否是求素数过程。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">L</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countPrimeSetBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">L, R</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> judge = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">Math</span>.sqrt(num); i++) &#123;<br>      <span class="hljs-keyword">if</span> (num % i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = L; i &lt;= R; i++) &#123;<br>    <span class="hljs-keyword">const</span> len = i<br>      .toString(<span class="hljs-number">2</span>)<br>      .split(<span class="hljs-string">&quot;&quot;</span>)<br>      .filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e === <span class="hljs-string">&quot;1&quot;</span>).length;<br>    <span class="hljs-keyword">if</span> (judge(len)) count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">L</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countPrimeSetBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">L, R</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> prime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>]);<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = L; i &lt;= R; i++) &#123;<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> i.toString(<span class="hljs-number">2</span>)) <span class="hljs-keyword">if</span> (num === <span class="hljs-string">&quot;1&quot;</span>) len++;<br>    <span class="hljs-keyword">if</span> (prime.has(len)) count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月18日</title>
    <link href="/2021/02/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/02/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1217. 玩筹码</p><span id="more"></span><h1 id="1217-玩筹码"><a href="#1217-玩筹码" class="headerlink" title="1217. 玩筹码"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. 玩筹码</a></h1><p>数轴上放置了一些筹码，每个筹码的位置存在数组 <code>chips</code> 当中。<br>你可以对 <strong>任何筹码</strong> 执行下面两种操作之一（<strong>不限操作次数</strong>，0 次也可以）：</p><ul><li>将第 <code>i</code> 个筹码向左或者右移动 2 个单位，代价为 <strong>0</strong>。</li><li>将第 <code>i</code> 个筹码向左或者右移动 1 个单位，代价为 <strong>1</strong>。</li></ul><p>最开始的时候，同一位置上也可能放着两个或者更多的筹码。<br>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。<br> <strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：chips </span>=<span class="hljs-string"> [1,2,3]</span><br><span class="hljs-string">输出：1</span><br><span class="hljs-string">解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：chips = <span class="hljs-string">[2,2,2,3,3]</span><br>输出：<span class="hljs-number">2</span><br>解释：第四和第五个筹码移动到位置二的代价都是 <span class="hljs-number">1</span>，所以最小总代价为 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= chips.length &lt;= 100</code></li><li><code>1 &lt;= chips[i] &lt;= 10^9</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要先理解题目，chips 数组里存放的是第 i 个筹码存放的位置，如[2,2,2,3,3]，第一个、第二个、第三个筹码在位置二，第四个、第五个在位置三。<br>偶数移动到偶数，奇数移动到奇数不需要代价，可以直接移动。然后将偶数或者奇数中较小的那一堆移动到另外一堆就是最小需要的代价，即求数组中偶数或者奇数较小的那个次数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">position</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minCostToMoveChips = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">position</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> odd = <span class="hljs-number">0</span>,<br>    even = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> position) &#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) even++;<br>    <span class="hljs-keyword">else</span> odd++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(odd, even);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月17日</title>
    <link href="/2021/02/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/02/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt908. 最小差值 I</p><span id="more"></span><h1 id="908-最小差值-I"><a href="#908-最小差值-I" class="headerlink" title="908. 最小差值 I"></a><a href="https://leetcode-cn.com/problems/smallest-range-i/">908. 最小差值 I</a></h1><p>难度简单 63 收藏分享切换为英文接收动态反馈<br>给你一个整数数组 <code>A</code>，请你给数组中的每个元素 <code>A[i]</code> 都加上一个任意数字 <code>x</code> （<code>-K &lt;= x &lt;= K</code>），从而得到一个新数组 <code>B</code> 。<br>返回数组 <code>B</code> 的最大值和最小值之间可能存在的最小差值。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">K</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-attr">B</span> = [<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">10</span>], <span class="hljs-attr">K</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-attr">B</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>], <span class="hljs-attr">K</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 或 <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li><li><code>0 &lt;= K &lt;= 10000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>得到数组内最大最小的值，最大的减去 K，最小的加上 K，求最大减最小的结果则为最小差值，判断是否小于 0：小于则可以将该数组全部设为同一个数，差值为 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">K</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallestRangeI = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, K</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Math</span>.max(...A) - <span class="hljs-built_in">Math</span>.min(...A) - <span class="hljs-number">2</span> * K;<br>  <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月16日</title>
    <link href="/2021/02/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/02/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt589. N 叉树的前序遍历</p><span id="more"></span><h1 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589. N 叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></h1><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。<br>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613446935132-52d8f233-8d08-49a5-9d18-c3316b8de1c2.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=781&size=0&status=done&style=none&width=300"></p><p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p><p>**说明: **递归法很简单，你可以使用迭代法完成此题吗?</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>按题意递归即可</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>借助栈完成前序遍历</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">return</span> [root.val, ...root.children.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> preorder(e)).flat()];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> stack = [];<br>  stack.push(root);<br>  <span class="hljs-keyword">while</span> (stack.length) &#123;<br>    <span class="hljs-keyword">const</span> node = stack.pop();<br>    res.push(node.val);<br>    <span class="hljs-keyword">if</span> (node.children.length) stack.push(...node.children.reverse());<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
      <tag>迭代</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月15日</title>
    <link href="/2021/02/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/02/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt559. N 叉树的最大深度</p><span id="more"></span><h1 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h1><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。<br><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613368059879-3e96ba85-4464-425e-98c7-c706ea7b95db.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=781&size=0&status=done&style=none&width=300"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613368060781-8130b2c9-8201-4f05-bce6-58e8b60d23a7.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=596&size=0&status=done&style=none&width=296"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的深度不会超过 <code>1000</code> 。</li><li>树的节点数目位于 <code>[0, 10]</code> 之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意，递归解，用 map 求得每个 children 的深度，用 max 取最大的那个深度。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-number">1</span> +<br>    (root.children.length<br>      ? <span class="hljs-built_in">Math</span>.max(...root.children.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> maxDepth(e)))<br>      : <span class="hljs-number">0</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月14日</title>
    <link href="/2021/02/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/02/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1534. 统计好三元组</p><span id="more"></span><h1 id="1534-统计好三元组"><a href="#1534-统计好三元组" class="headerlink" title="1534. 统计好三元组"></a><a href="https://leetcode-cn.com/problems/count-good-triplets/">1534. 统计好三元组</a></h1><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。<br>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。<br>返回 <strong>好三元组的数量</strong> 。<br> <strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：arr = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>], a = <span class="hljs-number">7</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：一共有 <span class="hljs-number">4</span> 个好三元组：[<span class="hljs-comment">(3,0,1)</span>, <span class="hljs-comment">(3,0,1)</span>, <span class="hljs-comment">(3,1,1)</span>, <span class="hljs-comment">(0,1,1)</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">a</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">b</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">c</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：不存在满足所有条件的三元组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意，暴力解。做好剪枝，跳过不必要的循环。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">a</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">b</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">c</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countGoodTriplets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr, a, b, c</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(arr[i] - arr[j]) &gt; a) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = j + <span class="hljs-number">1</span>; k &lt; arr.length; k++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(arr[j] - arr[k]) &gt; b) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(arr[i] - arr[k]) &lt;= c) res++;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月13日</title>
    <link href="/2021/02/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/02/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1636. 按照频率将数组升序排序</p><span id="more"></span><h1 id="1636-按照频率将数组升序排序"><a href="#1636-按照频率将数组升序排序" class="headerlink" title="1636. 按照频率将数组升序排序"></a><a href="https://leetcode-cn.com/problems/sort-array-by-increasing-frequency/">1636. 按照频率将数组升序排序</a></h1><p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 <br>请你返回排序后的数组。<br><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>解释：<span class="hljs-string">&#x27;3&#x27;</span> 频率为 <span class="hljs-number">1</span>，<span class="hljs-string">&#x27;1&#x27;</span> 频率为 <span class="hljs-number">2</span>，<span class="hljs-string">&#x27;2&#x27;</span> 频率为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>解释：<span class="hljs-string">&#x27;2&#x27;</span> 和 <span class="hljs-string">&#x27;3&#x27;</span> 频率都为 <span class="hljs-number">2</span> ，所以它们之间按照数值本身降序排序。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,1,<span class="hljs-string">-6</span>,4,5,<span class="hljs-string">-6</span>,1,4,1]<br>输出：[5,<span class="hljs-string">-1</span>,4,4,<span class="hljs-string">-6</span>,<span class="hljs-string">-6</span>,1,1,1]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表存储字母及出现次数；<br>按字母出现次数降序，如果相同，按数值降序排序；<br>按次数生成新数组并扁平化返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> frequencySort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(num)) map.set(num, map.get(num) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> map.set(num, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...map.entries()]<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a[<span class="hljs-number">1</span>] !== b[<span class="hljs-number">1</span>] ? a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] : b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]))<br>    .map(<span class="hljs-function">(<span class="hljs-params">[num, count]</span>) =&gt;</span> <span class="hljs-built_in">Array</span>(count).fill(num))<br>    .flat();<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月12日</title>
    <link href="/2021/02/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/02/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1252. 奇数值单元格的数目</p><span id="more"></span><h1 id="1252-奇数值单元格的数目"><a href="#1252-奇数值单元格的数目" class="headerlink" title="1252. 奇数值单元格的数目"></a><a href="https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/">1252. 奇数值单元格的数目</a></h1><p>给你一个 <code>n</code> 行 <code>m</code> 列的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。<br>另有一个索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 中的 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（从 <code>0</code> 开始编号）。<br>你需要将每对 <code>[ri, ci]</code> 指定的行和列上的所有单元格的值加 <code>1</code>。<br>请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613133195768-ffc3ffe7-f7b5-4e88-815b-7e57dbb1efda.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=1143&size=0&status=done&style=none&width=600"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, m = <span class="hljs-number">3</span>, indices = <span class="hljs-string">[[0,1],[1,1]]</span><br>输出：<span class="hljs-number">6</span><br>解释：最开始的矩阵是 <span class="hljs-string">[[0,0,0],[0,0,0]]</span>。<br>第一次增量操作后得到 <span class="hljs-string">[[1,2,1],[0,1,0]]</span>。<br>最后的矩阵是 <span class="hljs-string">[[1,3,1],[1,3,1]]</span>，里面有 <span class="hljs-number">6</span> 个奇数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613133195782-b11fa4fb-7c37-4a86-90ff-4a1347479e45.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=1033&size=0&status=done&style=none&width=600"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, m = <span class="hljs-number">2</span>, indices = <span class="hljs-string">[[1,1],[0,0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：最后的矩阵是 <span class="hljs-string">[[2,2],[2,2]]</span>，里面没有奇数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>1 &lt;= m &lt;= 50</code></li><li><code>1 &lt;= indices.length &lt;= 100</code></li><li><code>0 &lt;= indices[i][0] &lt; n</code></li><li><code>0 &lt;= indices[i][1] &lt; m</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意，生成数组，遍历 indices，处理矩阵后，扁平化矩阵，求得奇数的个数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">indices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> oddCells = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, m, indices</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> matrix = <span class="hljs-built_in">Array</span>(n)<br>    .fill(<span class="hljs-literal">null</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-built_in">Array</span>(m).fill(<span class="hljs-number">0</span>));<br>  indices.forEach(<span class="hljs-function">(<span class="hljs-params">indice</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [row, col] = indice;<br>    matrix[row] = matrix[row].map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e + <span class="hljs-number">1</span>);<br>    matrix.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> (e[col] += <span class="hljs-number">1</span>));<br>  &#125;);<br>  <span class="hljs-keyword">return</span> matrix.flat().filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>).length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月11日</title>
    <link href="/2021/02/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/02/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt590. N 叉树的后序遍历</p><span id="more"></span><h1 id="590-N-叉树的后序遍历"><a href="#590-N-叉树的后序遍历" class="headerlink" title="590. N 叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></h1><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。<br>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1613013723806-56e051f6-84d4-4948-86c3-cb5f73c35dc6.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=781&size=0&status=done&style=none&width=300"></p><p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.<br><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>按题意，递归求后续遍历即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">if</span> (!root.children.length) <span class="hljs-keyword">return</span> [root.val];<br>  <span class="hljs-keyword">return</span> [<br>    ...root.children.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.concat(postorder(b)), []),<br>    root.val,<br>  ];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>递归</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月10日</title>
    <link href="/2021/02/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/02/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 01.09. 字符串轮转</p><span id="more"></span><h1 id="面试题-01-09-字符串轮转"><a href="#面试题-01-09-字符串轮转" class="headerlink" title="面试题 01.09. 字符串轮转"></a><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></h1><p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。<br><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;waterbottle&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;erbottlewat&quot;</span><br>输出：True<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;aba&quot;</span><br> 输出：False<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>字符串长度在[0, 100000]范围内。</li></ol><p><strong>说明:</strong></p><ol><li>你能只调用一次检查子串的方法吗？</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先判断长度是否一样，是的话将 s 字符首尾加起来，如果得到的字符串包含 s1，说明是轮转字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isFlipedString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> s1.length === s2.length &amp;&amp; (s2 + s2).toString().includes(s1);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月9日</title>
    <link href="/2021/02/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%889%E6%97%A5/"/>
    <url>/2021/02/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt985. 查询后的偶数和</p><span id="more"></span><h1 id="985-查询后的偶数和"><a href="#985-查询后的偶数和" class="headerlink" title="985. 查询后的偶数和"></a><a href="https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries/">985. 查询后的偶数和</a></h1><p>给出一个整数数组 <code>A</code> 和一个查询数组 <code>queries</code>。<br>对于第 <code>i</code> 次查询，有 <code>val = queries[i][0], index = queries[i][1]</code>，我们会把 <code>val</code> 加到 <code>A[index]</code> 上。然后，第 <code>i</code> 次查询的答案是 <code>A</code> 中偶数值的和。<br><em>（此处给定的 <code>index = queries[i][1]</code> 是从 0 开始的索引，每次查询都会永久修改数组 <code>A</code>。）</em><br>返回所有查询的答案。你的答案应当以数组 <code>answer</code> 给出，<code>answer[i]</code> 为第 <code>i</code> 次查询的答案。<br><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：A = <span class="hljs-comment">[1,2,3,4]</span>, queries = <span class="hljs-comment">[<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[-3,1]</span>,<span class="hljs-comment">[-4,0]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：<span class="hljs-comment">[8,6,2,4]</span><br>解释：<br>开始时，数组为 <span class="hljs-comment">[1,2,3,4]</span>。<br>将 1 加到 A<span class="hljs-comment">[0]</span> 上之后，数组为 <span class="hljs-comment">[2,2,3,4]</span>，偶数值之和为 2 + 2 + 4 = 8。<br>将 -3 加到 A<span class="hljs-comment">[1]</span> 上之后，数组为 <span class="hljs-comment">[2,-1,3,4]</span>，偶数值之和为 2 + 4 = 6。<br>将 -4 加到 A<span class="hljs-comment">[0]</span> 上之后，数组为 <span class="hljs-comment">[-2,-1,3,4]</span>，偶数值之和为 -2 + 4 = 2。<br>将 2 加到 A<span class="hljs-comment">[3]</span> 上之后，数组为 <span class="hljs-comment">[-2,-1,3,6]</span>，偶数值之和为 -2 + 6 = 4。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>1 &lt;= queries.length &lt;= 10000</code></li><li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li><li><code>0 &lt;= queries[i][1] &lt; A.length</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意求解即可，双重循环</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">queries</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumEvenAfterQueries = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A, queries</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> queries.map(<span class="hljs-function">(<span class="hljs-params">query</span>) =&gt;</span> &#123;<br>    A[query[<span class="hljs-number">1</span>]] += query[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    A.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) res += e;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月8日</title>
    <link href="/2021/02/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%888%E6%97%A5/"/>
    <url>/2021/02/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt690. 员工的重要性</p><span id="more"></span><h1 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690. 员工的重要性"></a><a href="https://leetcode-cn.com/problems/employee-importance/">690. 员工的重要性</a></h1><p>给定一个保存员工信息的数据结构，它包含了员工<strong>唯一的 id</strong>，<strong>重要度  **和 **直系下属的 id</strong>。<br>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15, 10, 5。那么员工 1 的数据结构是[1, 15, [2]]，员工 2 的数据结构是[2, 10, [3]]，员工 3 的数据结构是[3, 5, []]。注意虽然员工 3 也是员工 1 的一个下属，但是由于<strong>并不是直系</strong>下属，因此没有体现在员工 1 的数据结构中。<br>现在输入一个公司的所有员工信息，以及单个员工 id，返回这个员工和他所有下属的重要度之和。<br><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[<span class="hljs-comment">[1, 5, <span class="hljs-comment">[2, 3]</span>]</span>, <span class="hljs-comment">[2, 3, <span class="hljs-comment">[]</span>]</span>, <span class="hljs-comment">[3, 3, <span class="hljs-comment">[]</span>]</span>]</span>, 1<br>输出: 11<br>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>一个员工最多有一个<strong>直系</strong>领导，但是可以有多个<strong>直系</strong>下属</li><li>员工数量不超过 2000。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表存储每个员工 id 对应的关系，使用队列累加求重要值。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * function Employee(id, importance, subordinates) &#123;</span><br><span class="hljs-comment"> *     this.id = id;</span><br><span class="hljs-comment"> *     this.importance = importance;</span><br><span class="hljs-comment"> *     this.subordinates = subordinates;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Employee[]&#125;</span> <span class="hljs-variable">employees</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">id</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> GetImportance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">employees, id</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  employees.forEach(<span class="hljs-function">(<span class="hljs-params">employee</span>) =&gt;</span> &#123;<br>    map.set(employee.id, &#123;<br>      <span class="hljs-attr">importance</span>: employee.importance,<br>      <span class="hljs-attr">subordinates</span>: employee.subordinates,<br>    &#125;);<br>  &#125;);<br>  <span class="hljs-keyword">let</span> queue = [id];<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> cur = map.get(queue.pop());<br>    res += cur.importance;<br>    queue = queue.concat(cur.subordinates);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月7日</title>
    <link href="/2021/02/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%887%E6%97%A5/"/>
    <url>/2021/02/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1446. 连续字符</p><span id="more"></span><h1 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446. 连续字符"></a><a href="https://leetcode-cn.com/problems/consecutive-characters/">1446. 连续字符</a></h1><p>给你一个字符串 <code>s</code> ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。<br>请你返回字符串的能量。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：子字符串 <span class="hljs-string">&quot;ee&quot;</span> 长度为 <span class="hljs-number">2</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abbcccddddeeeeedcba&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：子字符串 <span class="hljs-string">&quot;eeeee&quot;</span> 长度为 <span class="hljs-number">5</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;triplepillooooow&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;hooraaaaaaaaaaay&quot;</span><br>输出：<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;tourist&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>max 记录最大连续出现的字符长度，count 为当前字符连续出现次数急速，cur 记录当前字符。如果相同，count 累加；如果不同 max 更新，cur 更新为新字符，count 重新置为 1。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxPower = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (arr === cur) count++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      max = <span class="hljs-built_in">Math</span>.max(count, max);<br>      cur = arr;<br>      count = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(count, max);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月6日</title>
    <link href="/2021/02/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%886%E6%97%A5/"/>
    <url>/2021/02/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1507. 转变日期格式</p><span id="more"></span><h1 id="1507-转变日期格式"><a href="#1507-转变日期格式" class="headerlink" title="1507. 转变日期格式"></a><a href="https://leetcode-cn.com/problems/reformat-date/">1507. 转变日期格式</a></h1><p>给你一个字符串 <code>date</code> ，它的格式为 <code>Day Month Year</code> ，其中：</p><ul><li><code>Day</code> 是集合 <code>&#123;&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;&#125;</code> 中的一个元素。</li><li><code>Month</code> 是集合 <code>&#123;&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;&#125;</code> 中的一个元素。</li><li><code>Year</code> 的范围在 <code>[1900, 2100]</code> 之间。</li></ul><p>请你将字符串转变为 <code>YYYY-MM-DD</code> 的格式，其中：</p><ul><li><code>YYYY</code> 表示 4 位的年份。</li><li><code>MM</code> 表示 2 位的月份。</li><li><code>DD</code> 表示 2 位的天数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">date</span> = <span class="hljs-string">&quot;20th Oct 2052&quot;</span><br>输出：<span class="hljs-string">&quot;2052-10-20&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">date</span> = <span class="hljs-string">&quot;6th Jun 1933&quot;</span><br>输出：<span class="hljs-string">&quot;1933-06-06&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">date</span> = <span class="hljs-string">&quot;26th May 1960&quot;</span><br>输出：<span class="hljs-string">&quot;1960-05-26&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定日期保证是合法的，所以不需要处理异常输入。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建立月份 map 表，分隔字符串，得到年和月，日，日如果为 1 位需要在前面补 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">date</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reformatDate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">date</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> months = &#123;<br>    <span class="hljs-attr">Jan</span>: <span class="hljs-string">&quot;01&quot;</span>,<br>    <span class="hljs-attr">Feb</span>: <span class="hljs-string">&quot;02&quot;</span>,<br>    <span class="hljs-attr">Mar</span>: <span class="hljs-string">&quot;03&quot;</span>,<br>    <span class="hljs-attr">Apr</span>: <span class="hljs-string">&quot;04&quot;</span>,<br>    <span class="hljs-attr">May</span>: <span class="hljs-string">&quot;05&quot;</span>,<br>    <span class="hljs-attr">Jun</span>: <span class="hljs-string">&quot;06&quot;</span>,<br>    <span class="hljs-attr">Jul</span>: <span class="hljs-string">&quot;07&quot;</span>,<br>    <span class="hljs-attr">Aug</span>: <span class="hljs-string">&quot;08&quot;</span>,<br>    <span class="hljs-attr">Sep</span>: <span class="hljs-string">&quot;09&quot;</span>,<br>    <span class="hljs-attr">Oct</span>: <span class="hljs-string">&quot;10&quot;</span>,<br>    <span class="hljs-attr">Nov</span>: <span class="hljs-string">&quot;11&quot;</span>,<br>    <span class="hljs-attr">Dec</span>: <span class="hljs-string">&quot;12&quot;</span>,<br>  &#125;;<br>  date = date.split(<span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;date[<span class="hljs-number">2</span>]&#125;</span>-<span class="hljs-subst">$&#123;months[date[<span class="hljs-number">1</span>]]&#125;</span>-<span class="hljs-subst">$&#123;date[<span class="hljs-number">0</span>]</span></span><br><span class="hljs-subst"><span class="hljs-string">    .slice(<span class="hljs-number">0</span>, date[<span class="hljs-number">0</span>].length === <span class="hljs-number">4</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">    .padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>)&#125;</span>`</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月5日</title>
    <link href="/2021/02/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%885%E6%97%A5/"/>
    <url>/2021/02/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1592. 重新排列单词间的空格</p><span id="more"></span><h1 id="1592-重新排列单词间的空格"><a href="#1592-重新排列单词间的空格" class="headerlink" title="1592. 重新排列单词间的空格"></a><a href="https://leetcode-cn.com/problems/rearrange-spaces-between-words/">1592. 重新排列单词间的空格</a></h1><p>给你一个字符串 <code>text</code> ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 <code>text</code> <strong>至少包含一个单词</strong> 。<br>请你重新排列空格，使每对相邻单词之间的空格数目都 <strong>相等</strong> ，并尽可能 <strong>最大化</strong> 该数目。如果不能重新平均分配所有空格，请 <strong>将多余的空格放置在字符串末尾</strong> ，这也意味着返回的字符串应当与原 <code>text</code> 字符串的长度相等。<br>返回 <strong>重新排列空格后的字符串</strong> 。<br> <strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：text = <span class="hljs-comment">&quot;  this   is  a sentence &quot;</span><br>输出：<span class="hljs-comment">&quot;this   is   a   sentence&quot;</span><br>解释：总共有 <span class="hljs-number">9</span> 个空格和 <span class="hljs-number">4</span> 个单词。可以将 <span class="hljs-number">9</span> 个空格平均分配到相邻单词之间，相邻单词间空格数为：<span class="hljs-number">9</span> / (<span class="hljs-number">4</span><span class="hljs-number">-1</span>) = <span class="hljs-number">3</span> 个。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：text = &quot; practice   makes   perfect&quot;<br>输出：&quot;practice   makes   perfect &quot;<br>解释：总共有<span class="hljs-number"> 7 </span>个空格和<span class="hljs-number"> 3 </span>个单词。7 / (3-1) =<span class="hljs-number"> 3 </span>个空格加上<span class="hljs-number"> 1 </span>个多余的空格。多余的空格需要放在字符串的末尾。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;hello   world&quot;</span><br>输出：<span class="hljs-string">&quot;hello   world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：text = <span class="hljs-comment">&quot;  walks  udp package   into  bar a&quot;</span><br>输出：<span class="hljs-comment">&quot;walks  udp  package  into  bar  a &quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：text = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-comment">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text.length &lt;= 100</code></li><li><code>text</code> 由小写英文字母和 <code>&#39; &#39;</code> 组成</li><li><code>text</code> 中至少包含一个单词</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>提取单词，计算空格数（总长度减去单词长度），计算应该间隔的空格个数（空格数除以单词数组长度减一，取商），如果只有一个单词，那么间隔为 0。计算剩余的空格数（取余数），如果只有一个单词，剩余空格数就为总空格数。按照计算结果生成字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reorderSpaces = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> arrCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> arr = text.split(<span class="hljs-string">&quot; &quot;</span>).filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (e) arrCount += e.length;<br>    <span class="hljs-keyword">return</span> e;<br>  &#125;);<br>  <span class="hljs-keyword">const</span> spaceCount = text.length - arrCount;<br>  <span class="hljs-keyword">const</span> spaceNum =<br>    arr.length - <span class="hljs-number">1</span> === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Math</span>.floor(spaceCount / (arr.length - <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">const</span> rest =<br>    arr.length - <span class="hljs-number">1</span> === <span class="hljs-number">0</span> ? spaceCount : spaceCount % (arr.length - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> space = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(spaceNum).fill(<span class="hljs-string">&quot; &quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">return</span> arr.join(space) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(rest).fill(<span class="hljs-string">&quot; &quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月4日</title>
    <link href="/2021/02/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%884%E6%97%A5/"/>
    <url>/2021/02/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1417. 重新格式化字符串</p><span id="more"></span><h1 id="1417-重新格式化字符串"><a href="#1417-重新格式化字符串" class="headerlink" title="1417. 重新格式化字符串"></a><a href="https://leetcode-cn.com/problems/reformat-the-string/">1417. 重新格式化字符串</a></h1><p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。<br>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。<br>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;a0b1c2&quot;</span><br>输出：<span class="hljs-string">&quot;0a1b2c&quot;</span><br>解释：<span class="hljs-string">&quot;0a1b2c&quot;</span> 中任意两个相邻字符的类型都不同。 <span class="hljs-string">&quot;a0b1c2&quot;</span>, <span class="hljs-string">&quot;0a1b2c&quot;</span>, <span class="hljs-string">&quot;0c2a1b&quot;</span> 也是满足题目要求的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<span class="hljs-string">&quot;leetcode&quot;</span> 中只有字母，所以无法满足重新格式化的条件。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1229857369&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<span class="hljs-string">&quot;1229857369&quot;</span> 中只有数字，所以无法满足重新格式化的条件。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;covid2019&quot;</span><br>输出：<span class="hljs-string">&quot;c2o0v1i9d&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ab123&quot;</span><br>输出：<span class="hljs-string">&quot;1a2b3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母和/或数字组成。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两个数组存数字和字符，再判断两个数组长度差是否大于 1，大于则不能格式化，返回空字符串。<br>如果两个数组相等，分别遍历数组，轮流加入结果字符串。<br>如果不等，遍历数组，先加入大的数组中的对应字符，再加入小的数组中的对应字符。遍历后再将大的最后一位加入字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reformat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/^[0-9]*$/</span>,<br>    reg2 = <span class="hljs-regexp">/^[a-zA-Z]*$/</span>;<br>  <span class="hljs-keyword">const</span> num = [],<br>    arr = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (reg1.test(char)) num.push(char);<br>    <span class="hljs-keyword">if</span> (reg2.test(char)) arr.push(char);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(num.length - arr.length) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">const</span> min = num.length &lt; arr.length ? num : arr;<br>  <span class="hljs-keyword">const</span> max = num.length &lt; arr.length ? arr : num;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; min.length; i++) &#123;<br>    res += max[i] + min[i];<br>  &#125;<br>  <span class="hljs-keyword">if</span> (max.length &gt; min.length) &#123;<br>    res += max[max.length - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月3日</title>
    <link href="/2021/02/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%883%E6%97%A5/"/>
    <url>/2021/02/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1437. 是否所有 1 都至少相隔 k 个元素</p><span id="more"></span><h1 id="1437-是否所有-1-都至少相隔-k-个元素"><a href="#1437-是否所有-1-都至少相隔-k-个元素" class="headerlink" title="1437. 是否所有 1 都至少相隔 k 个元素"></a><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/">1437. 是否所有 1 都至少相隔 k 个元素</a></h1><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">true</span><br>解释：每个 <span class="hljs-number">1</span> 都至少相隔 <span class="hljs-number">2</span> 个元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br>解释：第二个 <span class="hljs-number">1</span> 和第三个 <span class="hljs-number">1</span> 之间只隔了 <span class="hljs-number">1</span> 个元素。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= k &lt;= nums.length</code></li><li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找到第一个 1 的位置，然后从下一个开始遍历，如果不是 1 就令 count 加一，为一就判断 1 是否小于 k，是的话返回 false，不是将 count 置为 0，继续判断，直到遍历完毕</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kLengthApart = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (nums[i] !== <span class="hljs-number">1</span> &amp;&amp; i &lt; nums.length) i++;<br>  <span class="hljs-keyword">for</span> (i = i + <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      count = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      count++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月2日</title>
    <link href="/2021/02/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%882%E6%97%A5/"/>
    <url>/2021/02/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt917. 仅仅反转字母</p><span id="more"></span><h1 id="917-仅仅反转字母"><a href="#917-仅仅反转字母" class="headerlink" title="917. 仅仅反转字母"></a><a href="https://leetcode-cn.com/problems/reverse-only-letters/">917. 仅仅反转字母</a></h1><p>给定一个字符串 <code>S</code>，返回  “反转后的”  字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;ab-cd&quot;</span><br>输出：<span class="hljs-string">&quot;dc-ba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：<span class="hljs-comment">&quot;a-bC-dEf-ghIj&quot;</span><br>输出：<span class="hljs-comment">&quot;j-Ih-gfE-dCba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;Test1ng-Leet=code-Q!&quot;</span><br>输出：<span class="hljs-string">&quot;Qedo1ct-eeLg=ntse-T!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S.length &lt;= 100</code></li><li><code>33 &lt;= S[i].ASCIIcode &lt;= 122</code></li><li><code>S</code> 中不包含 <code>\</code> or <code>&quot;</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字符串转为数组，使用正则判断是否是英文字母，不是的话令指针移动，直到左右指针指向的都是英文字母，交换两个指针指向的字符。结束后将数组转为字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年2月1日</title>
    <link href="/2021/02/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%881%E6%97%A5/"/>
    <url>/2021/02/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B42%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1089. 复写零</p><span id="more"></span><h1 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089. 复写零"></a><a href="https://leetcode-cn.com/problems/duplicate-zeros/">1089. 复写零</a></h1><p>给你一个长度固定的整数数组 <code>arr</code>，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。<br>注意：请不要在超过该数组长度的位置写入元素。<br>要求：请对输入的数组 <strong>就地  **进行上述修改，不要从函数返回任何东西。<br> **示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,0,2,3</span>,<span class="hljs-number">0,4,5,0</span>]<br>输出：null<br>解释：调用函数后，输入的数组将被修改为：[<span class="hljs-number">1,0,0,2</span>,<span class="hljs-number">3,0,0,4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,3]</span><br>输出：null<br>解释：调用函数后，输入的数组将被修改为：<span class="hljs-selector-attr">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 9</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 splice 插入，最后使用 splice 删除多余部分</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify arr in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> duplicateZeros = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> length = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] === <span class="hljs-number">0</span>) arr.splice(i++, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  arr.splice(length, arr.length);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月31日</title>
    <link href="/2021/01/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8831%E6%97%A5/"/>
    <url>/2021/01/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt485. 最大连续 1 的个数</p><span id="more"></span><h1 id="485-最大连续-1-的个数"><a href="#485-最大连续-1-的个数" class="headerlink" title="485. 最大连续 1 的个数"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a></h1><p>给定一个二进制数组， 计算其中最大连续 1 的个数。<br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,1,0,1,1,1]</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>输入的数组只包含 <code>0</code> 和<code>1</code>。</li><li>输入数组的长度是正整数，且不超过 10,000。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个计数和最大连续个数计数即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findMaxConsecutiveOnes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) count++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      max = <span class="hljs-built_in">Math</span>.max(max, count);<br>      count = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(max, count);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月30日</title>
    <link href="/2021/01/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8830%E6%97%A5/"/>
    <url>/2021/01/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1556. 千位分隔数</p><span id="more"></span><h1 id="1556-千位分隔数"><a href="#1556-千位分隔数" class="headerlink" title="1556. 千位分隔数"></a><a href="https://leetcode-cn.com/problems/thousand-separator/">1556. 千位分隔数</a></h1><p>给你一个整数 <code>n</code>，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。<br> <strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">987</span><br>输出：<span class="hljs-string">&quot;987&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1234</span><br>输出：<span class="hljs-string">&quot;1.234&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">123456789</span><br>输出：&quot;<span class="hljs-number">123.456</span>.<span class="hljs-number">789</span>&quot;<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将数值转化为字符串再转化为数组，从最后一位开始，每隔三位插入一个点，再转化字符串返回</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> thousandSeparator = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  n = (n + <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n.length - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">1</span>; i -= <span class="hljs-number">3</span>) &#123;<br>    n.splice(i, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> n.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月29日</title>
    <link href="/2021/01/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8829%E6%97%A5/"/>
    <url>/2021/01/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt693. 交替位二进制数</p><span id="more"></span><h1 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h1><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-number">5</span> 的二进制表示是：<span class="hljs-number">101</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：n = <span class="hljs-number">7</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">7</span> 的二进制表示是：<span class="hljs-number">111</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：n = <span class="hljs-number">11</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">11</span> 的二进制表示是：<span class="hljs-number">1011</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-number">10</span> 的二进制表示是：<span class="hljs-number">1010</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>转为二进制字符串以后判断每一位是否与上一位相同</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>将原数字和原数字向右移动一位的数进行抑或，如果为交替出现 01 的二进制，此时得到的数应该为 0 开头剩余都为 1 的二进制数。<br>将得到的数加一可以得到 1 开头剩余都为 0 的二进制数，两个数相与得到的数为 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasAlternatingBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  n = n.toString(<span class="hljs-number">2</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> prev;<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> n) &#123;<br>    <span class="hljs-keyword">if</span> (num === prev) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    prev = num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasAlternatingBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> m = n ^ (n &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> (m &amp; (m + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月28日</title>
    <link href="/2021/01/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8828%E6%97%A5/"/>
    <url>/2021/01/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1550. 存在连续三个奇数的数组</p><span id="more"></span><h1 id="1550-存在连续三个奇数的数组"><a href="#1550-存在连续三个奇数的数组" class="headerlink" title="1550. 存在连续三个奇数的数组"></a><a href="https://leetcode-cn.com/problems/three-consecutive-odds/">1550. 存在连续三个奇数的数组</a></h1><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">arr</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：不存在连续三个元素都是奇数的情况。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1,2,34,3</span>,<span class="hljs-number">4,5,7,23</span>,<span class="hljs-number">12</span>]<br>输出：true<br>解释：存在连续三个元素都是奇数的情况，即 [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">23</span>] 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意即可，使用一个变量计数</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> threeConsecutiveOdds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>      count++;<br>      <span class="hljs-keyword">if</span> (count === <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月27日</title>
    <link href="/2021/01/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8827%E6%97%A5/"/>
    <url>/2021/01/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1688. 比赛中的配对次数</p><span id="more"></span><h4 id="1688-比赛中的配对次数"><a href="#1688-比赛中的配对次数" class="headerlink" title="1688. 比赛中的配对次数"></a><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/">1688. 比赛中的配对次数</a></h4><p>给你一个整数 <code>n</code> ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p><ul><li>如果当前队伍数是 <strong>偶数</strong> ，那么每支队伍都会与另一支队伍配对。总共进行 <code>n / 2</code> 场比赛，且产生 <code>n / 2</code> 支队伍进入下一轮。</li><li>如果当前队伍数为 <strong>奇数</strong> ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 <code>(n - 1) / 2</code> 场比赛，且产生 <code>(n - 1) / 2 + 1</code> 支队伍进入下一轮。</li></ul><p>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 7<br>输出：6<br>解释：比赛详情：<br>- 第<span class="hljs-number"> 1 </span>轮：队伍数 =<span class="hljs-number"> 7 </span>，配对次数 =<span class="hljs-number"> 3 </span>，4 支队伍晋级。<br>- 第<span class="hljs-number"> 2 </span>轮：队伍数 =<span class="hljs-number"> 4 </span>，配对次数 =<span class="hljs-number"> 2 </span>，2 支队伍晋级。<br>- 第<span class="hljs-number"> 3 </span>轮：队伍数 =<span class="hljs-number"> 2 </span>，配对次数 =<span class="hljs-number"> 1 </span>，决出<span class="hljs-number"> 1 </span>支获胜队伍。<br>总配对次数 =<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 6<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 14<br>输出：13<br>解释：比赛详情：<br>- 第<span class="hljs-number"> 1 </span>轮：队伍数 =<span class="hljs-number"> 14 </span>，配对次数 =<span class="hljs-number"> 7 </span>，7 支队伍晋级。<br>- 第<span class="hljs-number"> 2 </span>轮：队伍数 =<span class="hljs-number"> 7 </span>，配对次数 =<span class="hljs-number"> 3 </span>，4 支队伍晋级。<br>- 第<span class="hljs-number"> 3 </span>轮：队伍数 =<span class="hljs-number"> 4 </span>，配对次数 =<span class="hljs-number"> 2 </span>，2 支队伍晋级。<br>- 第<span class="hljs-number"> 4 </span>轮：队伍数 =<span class="hljs-number"> 2 </span>，配对次数 =<span class="hljs-number"> 1 </span>，决出<span class="hljs-number"> 1 </span>支获胜队伍。<br>总配对次数 =<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 13<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 200</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意，比赛次数技术偶数时为 n/2，奇数时为(n-1)/2。剩余队伍数，偶数时为 n/2 ，奇数时为 ((n-1)/2 + 1)。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numberOfMatches = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>    res += n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? n / <span class="hljs-number">2</span> : (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    n = n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? n / <span class="hljs-number">2</span> : (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月26日</title>
    <link href="/2021/01/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8826%E6%97%A5/"/>
    <url>/2021/01/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1413. 逐步求和得到正数的最小值</p><span id="more"></span><h4 id="1413-逐步求和得到正数的最小值"><a href="#1413-逐步求和得到正数的最小值" class="headerlink" title="1413. 逐步求和得到正数的最小值"></a><a href="https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum/">1413. 逐步求和得到正数的最小值</a></h4><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 <strong>正数</strong> startValue 作为初始值。<br>你需要从左到右遍历 <code>nums</code> 数组，并将 startValue 依次累加上 <code>nums</code> 数组中的值。<br>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <strong>正数</strong> 作为 startValue 。<br> <strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-3</span>,2,<span class="hljs-string">-3</span>,4,2]<br>输出：5<br>解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。<br>                累加求和<br>                startValue = 4 | startValue = 5 | nums<br>                  (4 <span class="hljs-string">-3</span> ) = 1  | (5 <span class="hljs-string">-3</span> ) = 2    |  <span class="hljs-string">-3</span><br>                  (1 <span class="hljs-string">+2</span> ) = 3  | (2 <span class="hljs-string">+2</span> ) = 4    |   2<br>                  (3 <span class="hljs-string">-3</span> ) = 0  | (4 <span class="hljs-string">-3</span> ) = 1    |  <span class="hljs-string">-3</span><br>                  (0 <span class="hljs-string">+4</span> ) = 4  | (1 <span class="hljs-string">+4</span> ) = 5    |   4<br>                  (4 <span class="hljs-string">+2</span> ) = 6  | (5 <span class="hljs-string">+2</span> ) = 7    |   2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：1</span><br><span class="hljs-string">解释：最小的 startValue 需要是正数。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>]<br>输出：5<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意来写即可，直到遍历完全部数组且累加值大于 0 返回结果。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minStartValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> temp = res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>      temp += nums[i];<br>      <span class="hljs-keyword">if</span> (temp &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span> (i === nums.length - <span class="hljs-number">1</span> &amp;&amp; temp &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月25日</title>
    <link href="/2021/01/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8825%E6%97%A5/"/>
    <url>/2021/01/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt821. 字符的最短距离</p><span id="more"></span><h1 id="821-字符的最短距离"><a href="#821-字符的最短距离" class="headerlink" title="821. 字符的最短距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821. 字符的最短距离</a></h1><p>给定一个字符串 <code>S</code> 和一个字符 <code>C</code>。返回一个代表字符串 <code>S</code> 中每个字符到字符串 <code>S</code> 中的字符 <code>C</code> 的最短距离的数组。<br> <strong>示例：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;loveleetcode&quot;</span>, <span class="hljs-attr">C</span> = &#x27;e&#x27;<br>输出：[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>字符串 <code>S</code> 的长度范围为 <code>[1, 10000]</code>。</li><li><code>C</code> 是一个单字符，且保证是字符串 <code>S</code> 里的字符。</li><li><code>S</code> 和 <code>C</code> 中的所有字母均为小写字母。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历每个字符，从该字符向其左右同时进行搜索，直到找到目标字符。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character&#125;</span> <span class="hljs-variable">C</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> shortestToChar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S, C</span>) </span>&#123;<br>  S = S.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">return</span> S.map(<span class="hljs-function">(<span class="hljs-params">arr, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (S[index] === C) <span class="hljs-keyword">return</span> count;<br>    count++;<br>    <span class="hljs-keyword">while</span> (index - count &gt;= <span class="hljs-number">0</span> || index + count &lt;= S.length - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (index + count &lt;= S.length - <span class="hljs-number">1</span> &amp;&amp; S[index + count] === C) <span class="hljs-keyword">return</span> count;<br>      <span class="hljs-keyword">if</span> (index - count &gt;= <span class="hljs-number">0</span> &amp;&amp; S[index - count] === C) <span class="hljs-keyword">return</span> count;<br>      count++;<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月24日</title>
    <link href="/2021/01/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8824%E6%97%A5/"/>
    <url>/2021/01/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1652. 拆炸弹</p><span id="more"></span><h1 id="1652-拆炸弹"><a href="#1652-拆炸弹" class="headerlink" title="1652. 拆炸弹"></a><a href="https://leetcode-cn.com/problems/defuse-the-bomb/">1652. 拆炸弹</a></h1><p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>n</code> 的 <strong>循环</strong> 数组 <code>code</code> 以及一个密钥 <code>k</code> 。<br>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p><ul><li>如果 <code>k &gt; 0</code> ，将第 <code>i</code> 个数字用 <strong>接下来</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k &lt; 0</code> ，将第 <code>i</code> 个数字用 <strong>之前</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用 <code>0</code> 替换。</li></ul><p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是 <code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是 <code>code[n-1]</code> 。<br>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥 <code>k</code> ，请你返回解密后的结果来拆除炸弹！<br> <strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [5,7,1,4], k = 3<br>输出：[12,10,16,13]<br>解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7<span class="hljs-string">+1</span><span class="hljs-string">+4</span>, 1<span class="hljs-string">+4</span><span class="hljs-string">+5</span>, 4<span class="hljs-string">+5</span><span class="hljs-string">+7</span>, 5<span class="hljs-string">+7</span><span class="hljs-string">+1</span>]。注意到数组是循环连接的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">code</span> = <span class="hljs-selector-attr">[1,2,3,4]</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-selector-attr">[0,0,0,0]</span><br>解释：当 k 为 <span class="hljs-number">0</span> 时，所有数字都被 <span class="hljs-number">0</span> 替换。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [2,4,9,3], k = <span class="hljs-string">-2</span><br>输出：[12,5,6,13]<br>解释：解密后的密码为 [3<span class="hljs-string">+9</span>, 2<span class="hljs-string">+3</span>, 4<span class="hljs-string">+2</span>, 9<span class="hljs-string">+4</span>] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == code.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= code[i] &lt;= 100</code></li><li><code>-(n - 1) &lt;= k &lt;= n - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>分情况进行字符串操作</p><h4 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h4><p>当 k 大于零的时候   循环相加的下一个索引为<br>(i+j+1)%len<br>当 k 小于零的时候，循环相加起第一个元素值<br> (i-j-1+len)%len</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="字符串操作-1"><a href="#字符串操作-1" class="headerlink" title="字符串操作"></a>字符串操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">code</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decrypt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(code.length).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> code.map(<span class="hljs-function">(<span class="hljs-params">num, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> tail = [];<br>    <span class="hljs-keyword">let</span> head = [];<br>    <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span>) &#123;<br>      tail = code.slice(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span> + k);<br>      head = code.slice(<span class="hljs-number">0</span>, k - tail.length);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (index + k &lt; <span class="hljs-number">0</span>) &#123;<br>        tail = code.slice(index + k);<br>        head = code.slice(<span class="hljs-number">0</span>, -k - tail.length);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        tail = code.slice(index + k, index);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tail.concat(head).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="通项公式-1"><a href="#通项公式-1" class="headerlink" title="通项公式"></a>通项公式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">code</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decrypt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(code.length).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> code.map(<span class="hljs-function">(<span class="hljs-params">num, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>,<br>      i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">Math</span>.abs(k)) &#123;<br>      <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        sum += code[(index + i + <span class="hljs-number">1</span>) % code.length];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        sum += code[(code.length - <span class="hljs-number">1</span> + index - i) % code.length];<br>      &#125;<br>      i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月23日</title>
    <link href="/2021/01/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8823%E6%97%A5/"/>
    <url>/2021/01/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt521. 最长特殊序列 Ⅰ</p><span id="more"></span><h1 id="521-最长特殊序列-Ⅰ"><a href="#521-最长特殊序列-Ⅰ" class="headerlink" title="521. 最长特殊序列 Ⅰ"></a><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">521. 最长特殊序列 Ⅰ</a></h1><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。<br>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。<br><strong>子序列</strong> 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。<br>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。<br> <strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;aba&quot;</span>, <span class="hljs-string">&quot;cdc&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 最长特殊序列可为 <span class="hljs-string">&quot;aba&quot;</span> (或 <span class="hljs-string">&quot;cdc&quot;</span>)，两者均为自身的子序列且不是对方的子序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">a</span> = <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-attr">b</span> = <span class="hljs-string">&quot;bbb&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">a</span> = <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-attr">b</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>两个字符串长度均处于区间 <code>[1 - 100]</code> 。</li><li>字符串中的字符仅含有 <code>&#39;a&#39;~&#39;z&#39;</code> 。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>脑筋急转弯，如果字符串相同返回-1，如果不同返回长的那个字符串即可，长的那个字符串他本身一定是最长的特殊序列</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> a === b ? -<span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.max(a.length, b.length);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月22日</title>
    <link href="/2021/01/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8822%E6%97%A5/"/>
    <url>/2021/01/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1047. 删除字符串中的所有相邻重复项</p><span id="more"></span><h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h1><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。<br><strong>示例：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbaca&quot;</span><br>输出：<span class="hljs-string">&quot;ca&quot;</span><br>解释：<br>例如，在 <span class="hljs-string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="hljs-string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">&quot;aaca&quot;</span>，其中又只有 <span class="hljs-string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">&quot;ca&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>遇到相同的字符删除，并从头开始重新寻找</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>遇到栈顶相同则出栈，不相同则入栈</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  S = S.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">while</span> (j &lt; S.length) &#123;<br>    <span class="hljs-keyword">if</span> (S[j] === S[j + <span class="hljs-number">1</span>]) &#123;<br>      S.splice(j, <span class="hljs-number">2</span>);<br>      j = -<span class="hljs-number">1</span>;<br>    &#125;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> S.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> S) &#123;<br>    <span class="hljs-keyword">if</span> (stack[stack.length - <span class="hljs-number">1</span>] === arr) stack.pop();<br>    <span class="hljs-keyword">else</span> stack.push(arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月21日</title>
    <link href="/2021/01/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8821%E6%97%A5/"/>
    <url>/2021/01/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1662. 检查两个字符串数组是否相等</p><span id="more"></span><h1 id="1662-检查两个字符串数组是否相等"><a href="#1662-检查两个字符串数组是否相等" class="headerlink" title="1662. 检查两个字符串数组是否相等"></a><a href="https://leetcode-cn.com/problems/check-if-two-string-arrays-are-equivalent/">1662. 检查两个字符串数组是否相等</a></h1><p>给你两个字符串数组 <code>word1</code> 和 <code>word2</code> 。如果两个数组表示的字符串相同，返回_ <em><code>true</code></em> <em>；否则，返回 <code>false</code></em> 。_<br><strong>数组表示的字符串</strong> 是由数组中的所有元素 <strong>按顺序</strong> 连接形成的字符串。<br><strong>示例 1：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入：word1 = [<span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>], word2 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>]<br>输出：<span class="hljs-keyword">true</span><br>解释：<br>word1 表示的字符串为 <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-string">&quot;abc&quot;</span><br>word2 表示的字符串为 <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;bc&quot;</span> -&gt; <span class="hljs-string">&quot;abc&quot;</span><br>两个字符串相同，返回 <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">word1</span> = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;cb&quot;</span>], <span class="hljs-attr">word2</span> = [<span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">word1</span>  = [<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;defg&quot;</span>], <span class="hljs-attr">word2</span> = [<span class="hljs-string">&quot;abcddefg&quot;</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 10</code></li><li><code>1 &lt;= word1[i].length, word2[i].length &lt;= 10</code></li><li><code>1 &lt;= sum(word1[i].length), sum(word2[i].length) &lt;= 10</code></li><li><code>word1[i]</code> 和 <code>word2[i]</code> 由小写字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两个数组 join 后比较是否相等即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">word1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">word2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arrayStringsAreEqual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word1, word2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> word1.join(<span class="hljs-string">&quot;&quot;</span>) === word2.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月20日</title>
    <link href="/2021/01/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8820%E6%97%A5/"/>
    <url>/2021/01/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1588. 所有奇数长度子数组的和</p><span id="more"></span><h1 id="1588-所有奇数长度子数组的和"><a href="#1588-所有奇数长度子数组的和" class="headerlink" title="1588. 所有奇数长度子数组的和"></a><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></h1><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。<br><strong>子数组</strong> 定义为原数组中的一个连续子序列。<br>请你返回 <code>arr</code> 中 <strong>所有奇数长度子数组的和</strong> 。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[1,4,2,5,3]</span><br>输出：58<br>解释：所有奇数长度子数组和它们的和为：<br><span class="hljs-comment">[1]</span> = 1<br><span class="hljs-comment">[4]</span> = 4<br><span class="hljs-comment">[2]</span> = 2<br><span class="hljs-comment">[5]</span> = 5<br><span class="hljs-comment">[3]</span> = 3<br><span class="hljs-comment">[1,4,2]</span> = 7<br><span class="hljs-comment">[4,2,5]</span> = 11<br><span class="hljs-comment">[2,5,3]</span> = 10<br><span class="hljs-comment">[1,4,2,5,3]</span> = 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[1,2]</span><br>输出：3<br>解释：总共只有 2 个长度为奇数的子数组，<span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[2]</span>。它们的和为 3 。<br>示例 3：<br>输入：arr = <span class="hljs-comment">[10,11,12]</span><br>输出：66<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当长度小于等于当前数组长度时重复遍历数组，每次令长度加二，从首部开始截取子数组并求和计数</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumOddLengthSubarrays = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (length &lt;= arr.length) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= arr.length - length) &#123;<br>      res += arr.slice(i, i + length).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> +a + +b);<br>      i++;<br>    &#125;<br>    length += <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月19日</title>
    <link href="/2021/01/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8819%E6%97%A5/"/>
    <url>/2021/01/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1317. 将整数转换为两个无零整数的和</p><span id="more"></span><h1 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317. 将整数转换为两个无零整数的和"></a><a href="https://leetcode-cn.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/">1317. 将整数转换为两个无零整数的和</a></h1><p>「无零整数」是十进制表示中 <strong>不含任何 0</strong> 的正整数。<br>给你一个整数 <code>n</code>，请你返回一个 <strong>由两个整数组成的列表</strong> <code>[A, B]</code>，满足：</p><ul><li><code>A</code> 和 <code>B</code> 都是无零整数</li><li><code>A + B = n</code></li></ul><p>题目数据保证至少有一个有效的解决方案。<br>如果存在多个有效解决方案，你可以返回其中任意一个。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<span class="hljs-attr">A</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">B</span> = <span class="hljs-number">1</span>. A + <span class="hljs-attr">B</span> = n 并且 A 和 B 的十进制表示形式都不包含任何 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">11</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">10000</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">9999</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">69</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">68</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1010</span><br>输出：[<span class="hljs-number">11</span>,<span class="hljs-number">999</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10^4</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字母转化为字符串判断有没有零，有的话将当前数字减一</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getNoZeroIntegers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> first = <span class="hljs-number">0</span>,<br>    second = n;<br>  <span class="hljs-keyword">while</span> (first.toString().includes(<span class="hljs-string">&quot;0&quot;</span>) || second.toString().includes(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>    first++;<br>    second--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [first, second];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月18日</title>
    <link href="/2021/01/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8818%E6%97%A5/"/>
    <url>/2021/01/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1408. 数组中的字符串匹配</p><span id="more"></span><h1 id="1408-数组中的字符串匹配"><a href="#1408-数组中的字符串匹配" class="headerlink" title="1408. 数组中的字符串匹配"></a><a href="https://leetcode-cn.com/problems/string-matching-in-an-array/">1408. 数组中的字符串匹配</a></h1><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。<br>如果你可以删除 <code>words[j]</code> 最左侧和/或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。<br> <strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;mass&quot;</span>,<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-string">&quot;hero&quot;</span>,<span class="hljs-string">&quot;superhero&quot;</span>]<br>输出：[<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-string">&quot;hero&quot;</span>]<br>解释：<span class="hljs-string">&quot;as&quot;</span> 是 <span class="hljs-string">&quot;mass&quot;</span> 的子字符串，<span class="hljs-string">&quot;hero&quot;</span> 是 <span class="hljs-string">&quot;superhero&quot;</span> 的子字符串。<br>[<span class="hljs-string">&quot;hero&quot;</span>,<span class="hljs-string">&quot;as&quot;</span>] 也是有效的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>]<br>输出：[<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>]<br>解释：<span class="hljs-string">&quot;et&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 都是 <span class="hljs-string">&quot;leetcode&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;bu&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 仅包含小写英文字母。</li><li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按字符串长度从小到大排序，使用一个 set 存储单词，遍历数组，判断当前单词是否包含 set 中都某一个单词，是的话将那个单词加入结果 set 中，判断完后将当前单词加入单词 set 中。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> stringMatching = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  words.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.length - b.length);<br>  <span class="hljs-built_in">console</span>.log(words);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    [...map.values()].forEach(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (word.includes(element)) res.add(element);<br>    &#125;);<br>    map.add(word);<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...res.values()];<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(stringMatching([<span class="hljs-string">&quot;leetcoder&quot;</span>, <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-string">&quot;od&quot;</span>, <span class="hljs-string">&quot;hamlet&quot;</span>, <span class="hljs-string">&quot;am&quot;</span>]));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月17日</title>
    <link href="/2021/01/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8817%E6%97%A5/"/>
    <url>/2021/01/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt897. 递增顺序查找树</p><span id="more"></span><h1 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h1><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。<br><strong>示例 ：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>    <span class="hljs-number">6</span><br>   / <span class="hljs-string">\</span>    <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">4</span>    <span class="hljs-number">8</span><br> /        / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>        <span class="hljs-number">7</span>   <span class="hljs-number">9</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>]<br> <span class="hljs-number">1</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>    <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span><br>      <span class="hljs-string">\</span><br>       <span class="hljs-number">4</span><br>        <span class="hljs-string">\</span><br>         <span class="hljs-number">5</span><br>          <span class="hljs-string">\</span><br>           <span class="hljs-number">6</span><br>            <span class="hljs-string">\</span><br>             <span class="hljs-number">7</span><br>              <span class="hljs-string">\</span><br>               <span class="hljs-number">8</span><br>                <span class="hljs-string">\</span><br>                 <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树中的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li><li>每个结点都有一个从 <code>0</code> 到 <code>1000</code> 范围内的唯一整数值。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>中序遍历得到递增数组，再根据数组生成递增树</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> increasingBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = [];<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    visit(root.left);<br>    arr.push(root.val);<br>    visit(root.right);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> TreeNode(arr.shift());<br>  <span class="hljs-keyword">let</span> temp = res;<br>  <span class="hljs-keyword">while</span> (arr.length) &#123;<br>    temp.right = <span class="hljs-keyword">new</span> TreeNode(arr.shift());<br>    temp = temp.right;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月16日</title>
    <link href="/2021/01/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8816%E6%97%A5/"/>
    <url>/2021/01/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt824. 山羊拉丁文</p><span id="more"></span><h1 id="824-山羊拉丁文"><a href="#824-山羊拉丁文" class="headerlink" title="824. 山羊拉丁文"></a><a href="https://leetcode-cn.com/problems/goat-latin/">824. 山羊拉丁文</a></h1><p>给定一个由空格分割单词的句子 <code>S</code>。每个单词只包含大写或小写字母。<br>我们要将句子转换为 _“Goat Latin”_（一种类似于 猪拉丁文  - Pig Latin 的虚构语言）。<br>山羊拉丁文的规则如下：</p><ul><li>如果单词以元音开头（a, e, i, o, u），在单词后添加<code>&quot;ma&quot;</code>。<br>例如，单词<code>&quot;apple&quot;</code>变为<code>&quot;applema&quot;</code>。</li><li>如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加<code>&quot;ma&quot;</code>。<br>例如，单词<code>&quot;goat&quot;</code>变为<code>&quot;oatgma&quot;</code>。</li><li>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母<code>&#39;a&#39;</code>，索引从 1 开始。<br>例如，在第一个单词后添加<code>&quot;a&quot;</code>，在第二个单词后添加<code>&quot;aa&quot;</code>，以此类推。</li></ul><p>返回将 <code>S</code> 转换为山羊拉丁文后的句子。<br><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;I speak Goat Latin&quot;</span><br>输出: <span class="hljs-string">&quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;The quick brown fox jumped over the lazy dog&quot;</span><br>输出: <span class="hljs-comment">&quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>S</code> 中仅包含大小写字母和空格。单词间有且仅有一个空格。</li><li><code>1 &lt;= S.length &lt;= 150</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分隔字符串为数组，遍历，按照题意进行处理返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> toGoatLatin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  S = S.split(<span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>].indexOf(S[i][<span class="hljs-number">0</span>]) !== -<span class="hljs-number">1</span><br>    )<br>      S[i] += <span class="hljs-string">&quot;ma&quot;</span>;<br>    <span class="hljs-keyword">else</span> S[i] = S[i].slice(<span class="hljs-number">1</span>) + S[i][<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;ma&quot;</span>;<br>    S[i] = S[i] + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i + <span class="hljs-number">1</span>).fill(<span class="hljs-string">&quot;a&quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> S.join(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月15日</title>
    <link href="/2021/01/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8815%E6%97%A5/"/>
    <url>/2021/01/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1078. Bigram 分词</p><span id="more"></span><h1 id="1078-Bigram-分词"><a href="#1078-Bigram-分词" class="headerlink" title="1078. Bigram 分词"></a><a href="https://leetcode-cn.com/problems/occurrences-after-bigram/">1078. Bigram 分词</a></h1><p>给出第一个词 <code>first</code> 和第二个词 <code>second</code>，考虑在某些文本 <code>text</code> 中可能以 “<code>first second third</code>“ 形式出现的情况，其中 <code>second</code> 紧随 <code>first</code> 出现，<code>third</code> 紧随 <code>second</code> 出现。<br>对于每种这样的情况，将第三个词 “<code>third</code>“ 添加到答案中，并返回答案。<br> <strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;alice is a good girl she is a good student&quot;</span>, <span class="hljs-keyword">first</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-keyword">second</span> = <span class="hljs-string">&quot;good&quot;</span><br>输出：[<span class="hljs-string">&quot;girl&quot;</span>,<span class="hljs-string">&quot;student&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：text = <span class="hljs-comment">&quot;we will we will rock you&quot;</span>, first = <span class="hljs-comment">&quot;we&quot;</span>, second = <span class="hljs-comment">&quot;will&quot;</span><br>输出：[<span class="hljs-comment">&quot;we&quot;</span>,<span class="hljs-comment">&quot;rock&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= text.length &lt;= 1000</code></li><li><code>text</code> 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成</li><li><code>1 &lt;= first.length, second.length &lt;= 10</code></li><li><code>first</code> 和 <code>second</code> 由小写英文字母组成</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>字符串分隔为数组，判断当前和下一个数是否分别等于 first，second，是的话将下下个数加入结果数组。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">text</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">first</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">second</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findOcurrences = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text, first, second</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> arr = text.split(<span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] === first &amp;&amp; arr[i + <span class="hljs-number">1</span>] === second) &#123;<br>      res.push(arr[i + <span class="hljs-number">2</span>]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月14日</title>
    <link href="/2021/01/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8814%E6%97%A5/"/>
    <url>/2021/01/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-01-03-URL-化"><a href="#面试题-01-03-URL-化" class="headerlink" title="面试题 01.03. URL 化"></a>面试题 01.03. URL 化</h4><span id="more"></span><h1 id="面试题-01-03-URL-化-1"><a href="#面试题-01-03-URL-化-1" class="headerlink" title="面试题 01.03. URL 化"></a><a href="https://leetcode-cn.com/problems/string-to-url-lcci/">面试题 01.03. URL 化</a></h1><p>URL 化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用<code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）<br> <strong>示例 1：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：<span class="hljs-string">&quot;Mr John Smith    &quot;</span>, <span class="hljs-number">13</span><br>输出：<span class="hljs-string">&quot;Mr%20John%20Smith&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：<span class="hljs-string">&quot;               &quot;</span>, <span class="hljs-number">5</span><br>输出：<span class="hljs-string">&quot;%20%20%20%20%20&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>字符串长度在 [0, 500000] 范围内。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>截取长度后，将空格替换为%20</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">length</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> replaceSpaces = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S, length</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> S.slice(<span class="hljs-number">0</span>, length).replace(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">&quot;%20&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月13日</title>
    <link href="/2021/01/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8813%E6%97%A5/"/>
    <url>/2021/01/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1704. 判断字符串的两半是否相似</p><span id="more"></span><h1 id="1704-判断字符串的两半是否相似"><a href="#1704-判断字符串的两半是否相似" class="headerlink" title="1704. 判断字符串的两半是否相似"></a><a href="https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/">1704. 判断字符串的两半是否相似</a></h1><p>给你一个偶数长度的字符串 <code>s</code> 。将其拆分成长度相同的两半，前一半为 <code>a</code> ，后一半为 <code>b</code> 。<br>两个字符串 <strong>相似</strong> 的前提是它们都含有相同数目的元音（<code>&#39;a&#39;</code>，<code>&#39;e&#39;</code>，<code>&#39;i&#39;</code>，<code>&#39;o&#39;</code>，<code>&#39;u&#39;</code>，<code>&#39;A&#39;</code>，<code>&#39;E&#39;</code>，<code>&#39;I&#39;</code>，<code>&#39;O&#39;</code>，<code>&#39;U&#39;</code>）。注意，<code>s</code> 可能同时含有大写和小写字母。<br>如果_ <em><code>a</code></em> <em>和</em> _<code>b</code> 相似，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br> <strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：s = <span class="hljs-string">&quot;book&quot;</span><br>输出：true<br>解释：<span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;bo&quot;</span> 且 <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;ok&quot;</span> 。<span class="hljs-selector-tag">a</span> 中有 <span class="hljs-number">1</span> 个元音，<span class="hljs-selector-tag">b</span> 也有 <span class="hljs-number">1</span> 个元音。所以，<span class="hljs-selector-tag">a</span> 和 <span class="hljs-selector-tag">b</span> 相似。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：s = <span class="hljs-string">&quot;textbook&quot;</span><br>输出：false<br>解释：<span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;text&quot;</span> 且 <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;book&quot;</span> 。<span class="hljs-selector-tag">a</span> 中有 <span class="hljs-number">1</span> 个元音，<span class="hljs-selector-tag">b</span> 中有 <span class="hljs-number">2</span> 个元音。因此，<span class="hljs-selector-tag">a</span> 和 <span class="hljs-selector-tag">b</span> 不相似。<br>注意，元音 o 在 <span class="hljs-selector-tag">b</span> 中出现两次，记为 <span class="hljs-number">2</span> 个。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;MerryChristmas&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;AbCdEfGh&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= s.length &lt;= 1000</code></li><li><code>s.length</code> 是偶数</li><li><code>s</code> 由 <strong>大写和小写</strong> 字母组成</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从字符中开始判断，左边字符是元音的话 count++，右边的话 count–，遍历完成后判断 count 是否为 0</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> halvesAreAlike = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> vowel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>]);<br>  <span class="hljs-keyword">let</span> left = s.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>,<br>    right = s.length / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (vowel.has(s[left--])) count++;<br>    <span class="hljs-keyword">if</span> (vowel.has(s[right++])) count--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count === <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月12日</title>
    <link href="/2021/01/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8812%E6%97%A5/"/>
    <url>/2021/01/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1299. 将每个元素替换为右侧最大元素</p><span id="more"></span><h1 id="1299-将每个元素替换为右侧最大元素"><a href="#1299-将每个元素替换为右侧最大元素" class="headerlink" title="1299. 将每个元素替换为右侧最大元素"></a><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/">1299. 将每个元素替换为右侧最大元素</a></h1><p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。<br>完成所有替换操作后，请你返回这个数组。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [17,18,5,4,6,1]<br>输出：[18,6,6,6,1,-1]<br>解释：<br>- 下标<span class="hljs-number"> 0 </span>的元素 --&gt; 右侧最大元素是下标<span class="hljs-number"> 1 </span>的元素 (18)<br>- 下标<span class="hljs-number"> 1 </span>的元素 --&gt; 右侧最大元素是下标<span class="hljs-number"> 4 </span>的元素 (6)<br>- 下标<span class="hljs-number"> 2 </span>的元素 --&gt; 右侧最大元素是下标<span class="hljs-number"> 4 </span>的元素 (6)<br>- 下标<span class="hljs-number"> 3 </span>的元素 --&gt; 右侧最大元素是下标<span class="hljs-number"> 4 </span>的元素 (6)<br>- 下标<span class="hljs-number"> 4 </span>的元素 --&gt; 右侧最大元素是下标<span class="hljs-number"> 5 </span>的元素 (1)<br>- 下标<span class="hljs-number"> 5 </span>的元素 --&gt; 右侧没有其他元素，替换为 -1<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[400]</span><br>输出：<span class="hljs-comment">[-1]</span><br>解释：下标 0 的元素右侧没有其他元素。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10</code></li><li><code>1 &lt;= arr[i] &lt;= 10</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记录当前数组的最大值，从最后一位开始求，最后一位为-1，最大的数为最后一位数。从倒数第二位开始，使用一个临时数记录当前数，将当前数设为最大值，再将最大值更新为临时数和最大数中大的那个。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> replaceElements = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = arr[arr.length - <span class="hljs-number">1</span>];<br>  arr[arr.length - <span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> temp = arr[i];<br>    arr[i] = max;<br>    max = <span class="hljs-built_in">Math</span>.max(max, temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月11日</title>
    <link href="/2021/01/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8811%E6%97%A5/"/>
    <url>/2021/01/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt965. 单值二叉树</p><span id="more"></span><h1 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h1><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。<br>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。<br> <strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1610369675214-efb5d467-f338-4909-8e12-a779b8ee025e.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&originHeight=786&originWidth=988&size=0&status=done&style=none&width=200"></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1610369675216-d2632712-496b-4e86-b5e1-a4b298979d9e.png#align=left&display=inline&height=158&margin=%5Bobject%20Object%5D&originHeight=796&originWidth=1010&size=0&status=done&style=none&width=200"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,5,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数范围是 <code>[1, 100]</code>。</li><li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归即可，如果为叶子节点返回 true，如果只有左或右孩子，判断当前节点和左、右孩子节点值是否相等，再递归判断左、右孩子。如果左右孩子皆有，判断当前欠点和左及右孩子节点值是否相等，再递归判断左和右孩子。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1639155/1610369836316-041496e5-b701-4273-aed2-5e224e049881.png#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&name=image.png&originHeight=374&originWidth=922&size=41618&status=done&style=none&width=461" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isUnivalTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root || (!root.left &amp;&amp; !root.right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (!root.left)<br>    <span class="hljs-keyword">return</span> root.val === root.right.val &amp;&amp; isUnivalTree(root.right);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root.right)<br>    <span class="hljs-keyword">return</span> root.val === root.left.val &amp;&amp; isUnivalTree(root.left);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> (<br>      root.val === root.left.val &amp;&amp;<br>      root.val === root.right.val &amp;&amp;<br>      isUnivalTree(root.left) &amp;&amp;<br>      isUnivalTree(root.right)<br>    );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月10日</title>
    <link href="/2021/01/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8810%E6%97%A5/"/>
    <url>/2021/01/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1046. 最后一块石头的重量</p><span id="more"></span><h1 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h1><p>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块**  最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。<br><strong>示例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,7,4,1,8,1]</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>先选出 <span class="hljs-number">7</span> 和 <span class="hljs-number">8</span>，得到 <span class="hljs-number">1</span>，所以数组转换为 <span class="hljs-selector-attr">[2,4,1,1,1]</span>，<br>再选出 <span class="hljs-number">2</span> 和 <span class="hljs-number">4</span>，得到 <span class="hljs-number">2</span>，所以数组转换为 <span class="hljs-selector-attr">[2,1,1,1]</span>，<br>接着是 <span class="hljs-number">2</span> 和 <span class="hljs-number">1</span>，得到 <span class="hljs-number">1</span>，所以数组转换为 <span class="hljs-selector-attr">[1,1,1]</span>，<br>最后选出 <span class="hljs-number">1</span> 和 <span class="hljs-number">1</span>，得到 <span class="hljs-number">0</span>，最终数组转换为 <span class="hljs-selector-attr">[1]</span>，这就是最后剩下那块石头的重量。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先排序，取最前两个元素，计算差，再用插入排序找到位置插入元素，持续以上循环，知道最后数组内剩下元素只有一个，返回该元素。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">stones</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stones</span>) </span>&#123;<br>  stones.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<br>  <span class="hljs-keyword">while</span> (stones.length &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">const</span> num = stones.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (num &gt;= stones[i]) &#123;<br>        stones.splice(i, <span class="hljs-number">0</span>, num);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i === stones.length - <span class="hljs-number">1</span>) &#123;<br>        stones.push(num);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (stones.length === <span class="hljs-number">0</span>) stones.push(num);<br>  &#125;<br>  <span class="hljs-keyword">return</span> stones[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月9日</title>
    <link href="/2021/01/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%889%E6%97%A5/"/>
    <url>/2021/01/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt905. 按奇偶排序数组</p><span id="more"></span><h1 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905. 按奇偶排序数组"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">905. 按奇偶排序数组</a></h1><p>给定一个非负整数数组 <code>A</code>，返回一个数组，在该数组中， <code>A</code> 的所有偶数元素之后跟着所有奇数元素。<br>你可以返回满足此条件的任何数组作为答案。<br> <strong>示例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,1,2,4]</span><br>输出：<span class="hljs-selector-attr">[2,4,3,1]</span><br>输出 <span class="hljs-selector-attr">[4,2,3,1]</span>，<span class="hljs-selector-attr">[2,4,1,3]</span> 和 <span class="hljs-selector-attr">[4,2,1,3]</span> 也会被接受。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 5000</code></li><li><code>0 &lt;= A[i] &lt;= 5000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针，分别指向左右，如果左指针指向的是奇数，交换左右指针的数，右指针向左移动。当为偶数时，左指针向左移动。直到两个指针相遇停止。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParity = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = A.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">if</span> (A[l] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;<br>      [A[l], A[r--]] = [A[r], A[l]];<br>    &#125; <span class="hljs-keyword">else</span> l++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> A;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月8日</title>
    <link href="/2021/01/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%888%E6%97%A5/"/>
    <url>/2021/01/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1281. 整数的各位积和之差</p><span id="more"></span><h1 id="1281-整数的各位积和之差"><a href="#1281-整数的各位积和之差" class="headerlink" title="1281. 整数的各位积和之差"></a><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/">1281. 整数的各位积和之差</a></h1><p>给你一个整数 <code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 234<br>输出：15<br>解释：<br>各位数之积 =<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 3 </span>*<span class="hljs-number"> 4 </span>= 24<br>各位数之和 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>= 9<br>结果 =<span class="hljs-number"> 24 </span>-<span class="hljs-number"> 9 </span>= 15<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4421<br>输出：21<br>解释：<br>各位数之积 =<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 1 </span>= 32<br>各位数之和 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 11<br>结果 =<span class="hljs-number"> 32 </span>-<span class="hljs-number"> 11 </span>= 21<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subtractProductAndSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  n = n.toString().split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">return</span> n.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a * b) - n.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) + <span class="hljs-built_in">Number</span>(b));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月7日</title>
    <link href="/2021/01/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%887%E6%97%A5/"/>
    <url>/2021/01/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1624. 两个相同字符之间的最长子字符串</p><span id="more"></span><h1 id="1624-两个相同字符之间的最长子字符串"><a href="#1624-两个相同字符之间的最长子字符串" class="headerlink" title="1624. 两个相同字符之间的最长子字符串"></a><a href="https://leetcode-cn.com/problems/largest-substring-between-two-equal-characters/">1624. 两个相同字符之间的最长子字符串</a></h1><p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。<br><strong>子字符串</strong> 是字符串中的一个连续字符序列。<br> <strong>示例 1：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">输入：s = <span class="hljs-string">&quot;aa&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：最优的子字符串是两个 <span class="hljs-comment">&#x27;a&#x27; 之间的空子字符串。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abca&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最优的子字符串是 <span class="hljs-string">&quot;bc&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbzxy&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：s 中不存在出现出现两次的字符，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cabbac&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最优的子字符串是 <span class="hljs-string">&quot;abba&quot;</span> ，其他的非最优解包括 <span class="hljs-string">&quot;bb&quot;</span> 和 <span class="hljs-string">&quot;&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>s</code> 只含小写英文字母</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表记录第一次出现的距离，判断当前字符是否已经出现过，若出现过记录，计算当前下标和第一次出现下标中间的字母数量并判断是否更新 max。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxLengthBetweenEqualCharacters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> max = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isInteger(map[s[i]])) &#123;<br>      max = <span class="hljs-built_in">Math</span>.max(max, i - map[s[i]] - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map[s[i]] = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月6日</title>
    <link href="/2021/01/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%886%E6%97%A5/"/>
    <url>/2021/01/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1528. 重新排列字符串</p><span id="more"></span><h1 id="1528-重新排列字符串"><a href="#1528-重新排列字符串" class="headerlink" title="1528. 重新排列字符串"></a><a href="https://leetcode-cn.com/problems/shuffle-string/">1528. 重新排列字符串</a></h1><p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。<br>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。<br>返回重新排列后的字符串。<br> <strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1639155/1609943529994-cb002ce0-7b9d-43e6-869e-72c31de8d787.jpeg#align=left&display=inline&height=243&margin=%5Bobject%20Object%5D&originHeight=243&originWidth=321&size=0&status=done&style=none&width=321"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;codeleet&quot;</span>, <span class="hljs-attr">indices</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-string">&quot;leetcode&quot;</span><br>解释：如图所示，<span class="hljs-string">&quot;codeleet&quot;</span> 重新排列后变为 <span class="hljs-string">&quot;leetcode&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">indices</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-string">&quot;abc&quot;</span><br>解释：重新排列后，每个字符都还留在原来的位置上。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aiohn&quot;</span>, <span class="hljs-attr">indices</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">&quot;nihao&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaiougrt&quot;</span>, <span class="hljs-attr">indices</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">&quot;arigatou&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong><br><strong>输入：</strong>s = “art”, <code>indices</code> = [1,0,2]<br><strong>输出：</strong>“rat”<br><strong>提示：</strong></p><ul><li><code>s.length == indices.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母。</li><li><code>0 &lt;= indices[i] &lt; n</code></li><li><code>indices</code> 的所有的值都是唯一的（也就是说，<code>indices</code> 是整数 <code>0</code> 到 <code>n - 1</code> 形成的一组排列）。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>新建一个数组，再遍历 indices，将 res[indices[i]]设为 s[i]</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">indices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> restoreString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, indices</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(s.length);<br>  indices.forEach(<span class="hljs-function">(<span class="hljs-params">e, i</span>) =&gt;</span> &#123;<br>    res[e] = s[i];<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月5日</title>
    <link href="/2021/01/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%885%E6%97%A5/"/>
    <url>/2021/01/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt804. 唯一摩尔斯密码词</p><span id="more"></span><h1 id="804-唯一摩尔斯密码词"><a href="#804-唯一摩尔斯密码词" class="headerlink" title="804. 唯一摩尔斯密码词"></a><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">804. 唯一摩尔斯密码词</a></h1><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，  比如: <code>&quot;a&quot;</code> 对应 <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。<br>为了方便，所有 26 个英文字母对应摩尔斯密码表如下：<br>[“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—“,”-.-“,”.-..”,”–”,”-.”,”—“,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]<br>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “.-“ + “-…” 字符串的结合)。我们将这样一个连接过程称作单词翻译。<br>返回我们可以获得所有词不同单词翻译的数量。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">例如:<br>输入: words = [<span class="hljs-string">&quot;gin&quot;</span>, <span class="hljs-string">&quot;zen&quot;</span>, <span class="hljs-string">&quot;gig&quot;</span>, <span class="hljs-string">&quot;msg&quot;</span>]<br>输出: <span class="hljs-number">2</span><br>解释:<br>各单词翻译如下:<br><span class="hljs-string">&quot;gin&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;zen&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;gig&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br><span class="hljs-string">&quot;msg&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br>共有 <span class="hljs-number">2</span> 种不同翻译, <span class="hljs-string">&quot;--...-.&quot;</span> 和 <span class="hljs-string">&quot;--...--.&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li><li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li><li>每个单词 <code>words[i]</code>只包含小写字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表存字符对应摩尔斯密码，遍历每个单词，生成对应的摩尔斯密码，看结果哈希表中是否已经有该密码，有的话计数加一，没有的话计数设为 1</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniqueMorseRepresentations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arrMap = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;.-&quot;</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;-...&quot;</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;-.-.&quot;</span>,<br>    <span class="hljs-attr">d</span>: <span class="hljs-string">&quot;-..&quot;</span>,<br>    <span class="hljs-attr">e</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>    <span class="hljs-attr">f</span>: <span class="hljs-string">&quot;..-.&quot;</span>,<br>    <span class="hljs-attr">g</span>: <span class="hljs-string">&quot;--.&quot;</span>,<br>    <span class="hljs-attr">h</span>: <span class="hljs-string">&quot;....&quot;</span>,<br>    <span class="hljs-attr">i</span>: <span class="hljs-string">&quot;..&quot;</span>,<br>    <span class="hljs-attr">j</span>: <span class="hljs-string">&quot;.---&quot;</span>,<br>    <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;-.-&quot;</span>,<br>    <span class="hljs-attr">l</span>: <span class="hljs-string">&quot;.-..&quot;</span>,<br>    <span class="hljs-attr">m</span>: <span class="hljs-string">&quot;--&quot;</span>,<br>    <span class="hljs-attr">n</span>: <span class="hljs-string">&quot;-.&quot;</span>,<br>    <span class="hljs-attr">o</span>: <span class="hljs-string">&quot;---&quot;</span>,<br>    <span class="hljs-attr">p</span>: <span class="hljs-string">&quot;.--.&quot;</span>,<br>    <span class="hljs-attr">q</span>: <span class="hljs-string">&quot;--.-&quot;</span>,<br>    <span class="hljs-attr">r</span>: <span class="hljs-string">&quot;.-.&quot;</span>,<br>    <span class="hljs-attr">s</span>: <span class="hljs-string">&quot;...&quot;</span>,<br>    <span class="hljs-attr">t</span>: <span class="hljs-string">&quot;-&quot;</span>,<br>    <span class="hljs-attr">u</span>: <span class="hljs-string">&quot;..-&quot;</span>,<br>    <span class="hljs-attr">v</span>: <span class="hljs-string">&quot;...-&quot;</span>,<br>    <span class="hljs-attr">w</span>: <span class="hljs-string">&quot;.--&quot;</span>,<br>    <span class="hljs-attr">x</span>: <span class="hljs-string">&quot;-..-&quot;</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-string">&quot;-.--&quot;</span>,<br>    <span class="hljs-attr">z</span>: <span class="hljs-string">&quot;--..&quot;</span>,<br>  &#125;;<br>  <span class="hljs-keyword">const</span> res = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">const</span> str = word.split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + arrMap[b], <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (res[str]) res[str]++;<br>    <span class="hljs-keyword">else</span> res[str] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(res).length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月4日</title>
    <link href="/2021/01/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%884%E6%97%A5/"/>
    <url>/2021/01/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt682. 棒球比赛</p><span id="more"></span><h1 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛</a></h1><p>你现在是一场采特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。<br>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p><ol><li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li><li><code>&quot;+&quot;</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li><li><code>&quot;D&quot;</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li><li><code>&quot;C&quot;</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li></ol><p>请你返回记录中所有得分的总和。<br> <strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ops = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">30</span><br>解释：<br><span class="hljs-string">&quot;5&quot;</span> - 记录加 <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>]<br><span class="hljs-string">&quot;2&quot;</span> - 记录加 <span class="hljs-number">2</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>]<br><span class="hljs-string">&quot;C&quot;</span> - 使前一次得分的记录无效并将其移除，记录现在是 [<span class="hljs-number">5</span>].<br><span class="hljs-string">&quot;D&quot;</span> - 记录加 <span class="hljs-number">2</span> * <span class="hljs-number">5</span> = <span class="hljs-number">10</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>].<br><span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">5</span> + <span class="hljs-number">10</span> = <span class="hljs-number">15</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>].<br>所有得分的总和 <span class="hljs-number">5</span> + <span class="hljs-number">10</span> + <span class="hljs-number">15</span> = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ops = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;-2&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]<br>输出：<span class="hljs-number">27</span><br>解释：<br><span class="hljs-string">&quot;5&quot;</span> - 记录加 <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>]<br><span class="hljs-string">&quot;-2&quot;</span> - 记录加 <span class="hljs-number">-2</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>]<br><span class="hljs-string">&quot;4&quot;</span> - 记录加 <span class="hljs-number">4</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-string">&quot;C&quot;</span> - 使前一次得分的记录无效并将其移除，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>]<br><span class="hljs-string">&quot;D&quot;</span> - 记录加 <span class="hljs-number">2</span> * <span class="hljs-number">-2</span> = <span class="hljs-number">-4</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>]<br><span class="hljs-string">&quot;9&quot;</span> - 记录加 <span class="hljs-number">9</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>]<br><span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">-4</span> + <span class="hljs-number">9</span> = <span class="hljs-number">5</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>]<br><span class="hljs-string">&quot;+&quot;</span> - 记录加 <span class="hljs-number">9</span> + <span class="hljs-number">5</span> = <span class="hljs-number">14</span> ，记录现在是 [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">14</span>]<br>所有得分的总和 <span class="hljs-number">5</span> + <span class="hljs-number">-2</span> + <span class="hljs-number">-4</span> + <span class="hljs-number">9</span> + <span class="hljs-number">5</span> + <span class="hljs-number">14</span> = <span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ops</span> = [<span class="hljs-string">&quot;1&quot;</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ops.length &lt;= 1000</code></li><li><code>ops[i]</code> 为 <code>&quot;C&quot;</code>、<code>&quot;D&quot;</code>、<code>&quot;+&quot;</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10, 3 * 10]</code></li><li>对于 <code>&quot;+&quot;</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li><li>对于 <code>&quot;C&quot;</code> 和 <code>&quot;D&quot;</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个栈维护有效的成绩，遍历数组，switch 判断再执行相应操作即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">ops</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> calPoints = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ops</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> op <span class="hljs-keyword">of</span> ops) &#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;D&quot;</span>:<br>        res.push(res[res.length - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C&quot;</span>:<br>        res.pop();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>        res.push(res[res.length - <span class="hljs-number">1</span>] + res[res.length - <span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        res.push(<span class="hljs-built_in">Number</span>(op));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月3日</title>
    <link href="/2021/01/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%883%E6%97%A5/"/>
    <url>/2021/01/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 04.02. 最小高度树，递归</p><span id="more"></span><h1 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a></h1><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。<br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定有序数组: [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9],<br>一个可能的答案是：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>          0<br>         / \<br>       <span class="hljs-string">-3</span>   9<br>       /   /<br>     <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为为升序排列的数组，每次递归都取中点作为节点，再将从中点分割的左右数组分别让左右孩子递归取中点值，就可以得到一个高度最小的树，当传入数组为空时，返回 null。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedArrayToBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> middle = <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(nums[middle]);<br>  node.left = sortedArrayToBST(nums.slice(<span class="hljs-number">0</span>, middle));<br>  node.right = sortedArrayToBST(nums.slice(middle + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> node;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月2日</title>
    <link href="/2021/01/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%882%E6%97%A5/"/>
    <url>/2021/01/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt852. 山脉数组的峰顶索引</p><span id="more"></span><h1 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a></h1><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p><ul><li><code>A.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值。<br><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[0,1,0]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[0,2,1,0]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li>0 &lt;= A[i] &lt;= 10^6</li><li>A 是如上定义的山脉</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当当前元素比下一个元素大时，就为山峰，返回当前下标</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> peakIndexInMountainArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2021年1月1日</title>
    <link href="/2021/01/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%881%E6%97%A5/"/>
    <url>/2021/01/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2021%E5%B9%B41%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1200. 最小绝对差</p><span id="more"></span><h1 id="1200-最小绝对差"><a href="#1200-最小绝对差" class="headerlink" title="1200. 最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference/">1200. 最小绝对差</a></h1><p>给你个整数数组 <code>arr</code>，其中每个元素都 <strong>不相同</strong>。<br>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。<br> <strong>示例 1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：arr = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>]<br>输出：<span class="hljs-string">[[1,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[3,8,-10,23,19,-4,-14,27]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-14,-10]</span>,<span class="hljs-comment">[19,23]</span>,<span class="hljs-comment">[23,27]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>升序排序后，使用一个 minAbs 记录最小的绝对差，比较相邻的元素：如果绝对差比最小绝对差要大，直接跳过；如果相等，在结果数组中插入相应的值；如果要小，更新 minAbs，并结果数组设为空，重新开始插入新数组对。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minimumAbsDifference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">let</span> minAbs = <span class="hljs-literal">Infinity</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> abs = arr[i + <span class="hljs-number">1</span>] - arr[i];<br>    <span class="hljs-keyword">if</span> (abs &lt; minAbs) &#123;<br>      minAbs = abs;<br>      res = [[arr[i], arr[i + <span class="hljs-number">1</span>]]];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abs === minAbs) &#123;<br>      res.push([arr[i], arr[i + <span class="hljs-number">1</span>]]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月31日</title>
    <link href="/2020/12/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8831%E6%97%A5/"/>
    <url>/2020/12/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt657. 机器人能否返回原点</p><span id="more"></span><h1 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">657. 机器人能否返回原点</a></h1><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在** (0, 0) 处结束<strong>。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>**注意：</strong>机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。<br> <strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;UD&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;LL&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 <span class="hljs-literal">false</span>，因为它在移动结束时没有返回原点。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用水平和垂直两个值来计数，如果最后两者计数都为 0，说明可以返回原点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">moves</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> judgeCircle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">moves</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> horizontal = <span class="hljs-number">0</span>,<br>    vertical = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> str <span class="hljs-keyword">of</span> moves) &#123;<br>    <span class="hljs-keyword">switch</span> (str) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;R&quot;</span>:<br>        horizontal++;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;L&quot;</span>:<br>        horizontal--;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;U&quot;</span>:<br>        vertical++;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;D&quot;</span>:<br>        vertical--;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> horizontal === <span class="hljs-number">0</span> &amp;&amp; vertical === <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月30日</title>
    <link href="/2020/12/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8830%E6%97%A5/"/>
    <url>/2020/12/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1021. 删除最外层的括号</p><span id="more"></span><h1 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021. 删除最外层的括号"></a><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">1021. 删除最外层的括号</a></h1><p>有效括号字符串为空 <code>(&quot;&quot;)</code>、<code>&quot;(&quot; + A + &quot;)&quot;</code> 或 <code>A + B</code>，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。<br>如果有效字符串 <code>S</code> 非空，且不存在将其拆分为 <code>S = A+B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。<br>给出一个非空有效字符串 <code>S</code>，考虑将其进行原语化分解，使得：<code>S = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。<br>对 <code>S</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>S</code> 。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;(()())(())&quot;</span><br>输出：<span class="hljs-string">&quot;()()()&quot;</span><br>解释：<br>输入字符串为 <span class="hljs-string">&quot;(()())(())&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;(()())&quot;</span> + <span class="hljs-string">&quot;(())&quot;</span>，<br>删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;()()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span> = <span class="hljs-string">&quot;()()()&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;(()())(())(()(()))&quot;</span><br>输出：<span class="hljs-string">&quot;()()()()(())&quot;</span><br>解释：<br>输入字符串为 <span class="hljs-string">&quot;(()())(())(()(()))&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;(()())&quot;</span> + <span class="hljs-string">&quot;(())&quot;</span> + <span class="hljs-string">&quot;(()(()))&quot;</span>，<br>删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;()()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span> + <span class="hljs-string">&quot;()(())&quot;</span> = <span class="hljs-string">&quot;()()()()(())&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;()()&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<br>输入字符串为 <span class="hljs-string">&quot;()()&quot;</span>，原语化分解得到 <span class="hljs-string">&quot;()&quot;</span> + <span class="hljs-string">&quot;()&quot;</span>，<br>删除每个部分中的最外层括号后得到 <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S.length &lt;= 10000</code></li><li><code>S[i]</code> 为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code></li><li><code>S</code> 是一个有效括号字符串</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只需要一个储存结果的临时字符串。用 count 计数，为 0 的时候说明是一个原语，截取 start 到下标 i 的就为外层括号里的内容，加入结果字符串中即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeOuterParentheses = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>    start = <span class="hljs-number">1</span>,<br>    res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>      start = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (S[i] === <span class="hljs-string">&quot;(&quot;</span>) count++;<br>    <span class="hljs-keyword">else</span> count--;<br>    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>      res += S.slice(start, i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月29日</title>
    <link href="/2020/12/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8829%E6%97%A5/"/>
    <url>/2020/12/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt.1694. 重新格式化电话号码</p><span id="more"></span><h1 id="1694-重新格式化电话号码"><a href="#1694-重新格式化电话号码" class="headerlink" title="1694. 重新格式化电话号码"></a><a href="https://leetcode-cn.com/problems/reformat-phone-number/">1694. 重新格式化电话号码</a></h1><p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>&#39; &#39;</code>、和破折号 <code>&#39;-&#39;</code> 组成。<br>请你按下述方式重新格式化电话号码。</p><ul><li>首先，<strong>删除</strong> 所有的空格和破折号。</li><li>其次，将数组从左到右<strong>每 3 个一组</strong>分块，**直到  **剩下 4 个或更少数字。剩下的数字将按下述规定再分块：<ul><li>2 个数字：单个含 2 个数字的块。</li><li>3 个数字：单个含 3 个数字的块。</li><li>4 个数字：两个分别含 2 个数字的块。</li></ul></li></ul><p>最后用破折号将这些块连接起来。注意，重新格式化过程中 <strong>不应该</strong> 生成仅含 1 个数字的块，并且 <strong>最多</strong> 生成两个含 2 个数字的块。<br>返回格式化后的电话号码。<br> <strong>示例 1：</strong><br><strong>输入：</strong>number = “1-23-45 6”<br><strong>输出：</strong>“123-456”<br><strong>解释：</strong>数字是 “123456”<br>步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 “123” 。<br>步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 “456” 。<br>连接这些块后得到 “123-456” 。<br><strong>示例 2：</strong><br><strong>输入：</strong>number = “123 4-567”<br><strong>输出：</strong>“123-45-67”<br><strong>解释：</strong>数字是 “1234567”.<br>步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 “123” 。<br>步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 “45” 和 “67” 。<br>连接这些块后得到 “123-45-67” 。<br><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;123 4-5678&quot;</span><br>输出：<span class="hljs-string">&quot;123-456-78&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;12345678&quot;</span> 。<br>步骤 <span class="hljs-number">1</span>：第 <span class="hljs-number">1</span> 个块 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：第 <span class="hljs-number">2</span> 个块 <span class="hljs-string">&quot;456&quot;</span> 。<br>步骤 <span class="hljs-number">3</span>：剩下 <span class="hljs-number">2</span> 个数字，将它们放入单个含 <span class="hljs-number">2</span> 个数字的块。第 <span class="hljs-number">3</span> 个块是 <span class="hljs-string">&quot;78&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456-78&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br></code></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：number = &quot;-<span class="hljs-string">-17</span><span class="hljs-string">-5</span> 229 35<span class="hljs-string">-39475</span> &quot;<br>输出：&quot;175<span class="hljs-string">-229</span><span class="hljs-string">-353</span><span class="hljs-string">-94</span><span class="hljs-string">-75</span>&quot;<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>2 &lt;= number.length &lt;= 100</li><li>number 由数字和字符 ‘-‘ 及 ‘ ‘ 组成。</li><li>number 中至少含 2 个数字。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>正则去除多余符号。当原字符串长度大于 4 时，截取 3 个存入结果数组，当小于等于 4 时，根据剩余长度做不同处理。最后返回结果数组转成的字符串即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">number</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reformatNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) </span>&#123;<br>  number = number.replace(<span class="hljs-regexp">/[^\d.]/g</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">while</span> (number.length) &#123;<br>    <span class="hljs-keyword">if</span> (number.length &gt; <span class="hljs-number">4</span>) res.push(number.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (number.length === <span class="hljs-number">4</span>)<br>        res.push(number.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), number.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number.length === <span class="hljs-number">3</span>) res.push(number.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>      <span class="hljs-keyword">else</span> res.push(number.splice(<span class="hljs-number">0</span>, number.length));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.join(<span class="hljs-string">&quot;&quot;</span>)).join(<span class="hljs-string">&quot;-&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月28日</title>
    <link href="/2020/12/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8828%E6%97%A5/"/>
    <url>/2020/12/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 02.03. 删除中间节点</p><span id="more"></span><h1 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">面试题 02.03. 删除中间节点</a></h1><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。<br><strong>示例：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：单向链表<span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">b</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">d</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>f中的节点c<br>结果：不返回任何数据，但该链表变为<span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">b</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">d</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>f<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>难点在读题意，传入的是中点节点 c。将当前的 val 和 next 设为 next 的 val 和 next 即可。<br>如果给的是链表头可以使用快慢指针找中间节点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">node</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify node in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;<br>  node.val = node.next.val;<br>  node.next = node.next.next;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月27日</title>
    <link href="/2020/12/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8827%E6%97%A5/"/>
    <url>/2020/12/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1431. 拥有最多糖果的孩子</p><span id="more"></span><h1 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431. 拥有最多糖果的孩子"></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">1431. 拥有最多糖果的孩子</a></h1><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。<br>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candies = [2,3,5,1,3], extraCandies = 3<br>输出：[true,true,true,false,true]<br>解释：<br>孩子<span class="hljs-number"> 1 </span>有<span class="hljs-number"> 2 </span>个糖果，如果他得到所有额外的糖果（3个），那么他总共有<span class="hljs-number"> 5 </span>个糖果，他将成为拥有最多糖果的孩子。<br>孩子<span class="hljs-number"> 2 </span>有<span class="hljs-number"> 3 </span>个糖果，如果他得到至少<span class="hljs-number"> 2 </span>个额外糖果，那么他将成为拥有最多糖果的孩子。<br>孩子<span class="hljs-number"> 3 </span>有<span class="hljs-number"> 5 </span>个糖果，他已经是拥有最多糖果的孩子。<br>孩子<span class="hljs-number"> 4 </span>有<span class="hljs-number"> 1 </span>个糖果，即使他得到所有额外的糖果，他也只有<span class="hljs-number"> 4 </span>个糖果，无法成为拥有糖果最多的孩子。<br>孩子<span class="hljs-number"> 5 </span>有<span class="hljs-number"> 3 </span>个糖果，如果他得到至少<span class="hljs-number"> 2 </span>个额外糖果，那么他将成为拥有最多糖果的孩子。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">candies</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">extraCandies</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>]<br>解释：只有 <span class="hljs-number">1</span> 个额外糖果，所以不管额外糖果给谁，只有孩子 <span class="hljs-number">1</span> 可以成为拥有糖果最多的孩子。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">candies</span> = [<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">12</span>], <span class="hljs-attr">extraCandies</span> = <span class="hljs-number">10</span><br>输出：[<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= candies.length &lt;= 100</code></li><li><code>1 &lt;= candies[i] &lt;= 100</code></li><li><code>1 &lt;= extraCandies &lt;= 50</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求出数组最大数，再遍历一次根据最大数和额外糖数返回每一个孩子的结果。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">candies</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">extraCandies</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kidsWithCandies = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">candies, extraCandies</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max(...candies);<br>  <span class="hljs-keyword">return</span> candies.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e + extraCandies &gt;= max);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月26日</title>
    <link href="/2020/12/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8826%E6%97%A5/"/>
    <url>/2020/12/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1221. 分割平衡字符串</p><span id="more"></span><h1 id="1221-分割平衡字符串"><a href="#1221-分割平衡字符串" class="headerlink" title="1221. 分割平衡字符串"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></h1><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。<br>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。<br>返回可以通过分割得到的平衡字符串的最大数量<strong>。</strong><br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;RLRRLLRLRL&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：s 可以分割为 <span class="hljs-string">&quot;RL&quot;</span>, <span class="hljs-string">&quot;RRLL&quot;</span>, <span class="hljs-string">&quot;RL&quot;</span>, <span class="hljs-string">&quot;RL&quot;</span>, 每个子字符串中都包含相同数量的 &#x27;L&#x27; 和 &#x27;R&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;RLLLLRRRLR&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：s 可以分割为 <span class="hljs-string">&quot;RL&quot;</span>, <span class="hljs-string">&quot;LLLRRR&quot;</span>, <span class="hljs-string">&quot;LR&quot;</span>, 每个子字符串中都包含相同数量的 &#x27;L&#x27; 和 &#x27;R&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：s = <span class="hljs-string">&quot;LLLLRRRR&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：s 只能保持原样 <span class="hljs-string">&quot;LLLLRRRR&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li><li>分割得到的每个字符串都必须是平衡字符串。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相当于括号匹配，当前为 R 计数加一，为 L 减一，当当前计数为 0，说明左右括号个数相等，凑成一个平衡字符串。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> balancedStringSplit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>    res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot;R&quot;</span>) count++;<br>    <span class="hljs-keyword">else</span> count--;<br>    <span class="hljs-keyword">if</span> (!count) res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月25日</title>
    <link href="/2020/12/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8825%E6%97%A5/"/>
    <url>/2020/12/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1290. 二进制链表转整数</p><span id="more"></span><h4 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数</a></h4><p>给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。<br>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1608904045944-f8b16f41-f690-48d6-8dcb-38b60a60dad6.png#align=left&display=inline&height=108&margin=%5Bobject%20Object%5D&originHeight=108&originWidth=426&size=0&status=done&style=none&width=426"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">5</span><br>解释：二进制数 <span class="hljs-comment">(101)</span> 转化为十进制数 <span class="hljs-comment">(5)</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：head </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：head </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,0,0,1</span>,<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">18880</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：head </span>=<span class="hljs-string"> [0,0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表不为空。</li><li>链表的结点总数不超过 <code>30</code>。</li><li>每个结点的值不是 <code>0</code> 就是 <code>1</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历链表，用字符串存字符，然后将字符串转十进制。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getDecimalValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    res += head.val;<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(res, <span class="hljs-number">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月24日</title>
    <link href="/2020/12/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8824%E6%97%A5/"/>
    <url>/2020/12/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1313. 解压缩编码列表</p><span id="more"></span><h1 id="1313-解压缩编码列表"><a href="#1313-解压缩编码列表" class="headerlink" title="1313. 解压缩编码列表"></a><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/">1313. 解压缩编码列表</a></h1><p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。<br>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i &gt;= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。<br>请你返回解压后的列表。<br> <strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4]</span><br>输出：<span class="hljs-comment">[2,4,4,4]</span><br>解释：第一对 <span class="hljs-comment">[1,2]</span> 代表着 2 的出现频次为 1，所以生成数组 <span class="hljs-comment">[2]</span>。<br>第二对 <span class="hljs-comment">[3,4]</span> 代表着 4 的出现频次为 3，所以生成数组 <span class="hljs-comment">[4,4,4]</span>。<br>最后将它们串联到一起 <span class="hljs-comment">[2]</span> + <span class="hljs-comment">[4,4,4]</span> = <span class="hljs-comment">[2,4,4,4]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 100</code></li><li><code>nums.length % 2 == 0</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意，遍历生成对应的数组并加入结果数组中返回</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decompressRLElist = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;<br>    res = res.concat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums[i]).fill(nums[i + <span class="hljs-number">1</span>]));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月23日</title>
    <link href="/2020/12/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8823%E6%97%A5/"/>
    <url>/2020/12/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 17.10. 主要元素，摩尔投票</p><span id="more"></span><h1 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h1><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。<br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,2,5,9</span>,<span class="hljs-number">5,9,5,5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong><br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表计数，筛选出大于数组个数一半的元素，没有的话返回-1</p><h4 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h4><p>摩尔投票，选一个数作为众数。遍历数组相同时加一，不同时减一，如果当前计数为 0，换一个数作为众数代表，继续判断。本题不一定存在众数，如果 count&gt;0 还要判断当前数在原数组中出现的次数应该大于数组长度的一半。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map[num]) map[num]++;<br>    <span class="hljs-keyword">else</span> map[num] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>.entries(map).filter(<br>    <span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> value &gt; <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>)<br>  );<br>  <span class="hljs-keyword">return</span> arr.length &gt; <span class="hljs-number">0</span> ? arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] : -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="摩尔投票-1"><a href="#摩尔投票-1" class="headerlink" title="摩尔投票"></a>摩尔投票</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>,<br>  major = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>    major = num;<br>    count++;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (major === num) count++;<br>    <span class="hljs-keyword">else</span> count--;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> count &gt; <span class="hljs-number">0</span> &amp;&amp;<br>  nums.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e === major).length &gt; <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>)<br>  ? major<br>  : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>摩尔投票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月22日</title>
    <link href="/2020/12/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8822%E6%97%A5/"/>
    <url>/2020/12/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1323. 6 和 9 组成的最大数字</p><span id="more"></span><h1 id="1323-6-和-9-组成的最大数字"><a href="#1323-6-和-9-组成的最大数字" class="headerlink" title="1323. 6 和 9 组成的最大数字"></a><a href="https://leetcode-cn.com/problems/maximum-69-number/">1323. 6 和 9 组成的最大数字</a></h1><p>给你一个仅由数字 6 和 9 组成的正整数 <code>num</code>。<br>你最多只能翻转一位数字，将 6 变成  9，或者把  9 变成  6 。<br>请返回你可以得到的最大数字。<br> <strong>示例 1：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：num</span> <span class="hljs-string">=</span> <span class="hljs-number">9669</span><br><span class="hljs-string">输出：9969</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">改变第一位数字可以得到</span> <span class="hljs-number">6669</span> <span class="hljs-string">。</span><br><span class="hljs-string">改变第二位数字可以得到</span> <span class="hljs-number">9969</span> <span class="hljs-string">。</span><br><span class="hljs-string">改变第三位数字可以得到</span> <span class="hljs-number">9699</span> <span class="hljs-string">。</span><br><span class="hljs-string">改变第四位数字可以得到</span> <span class="hljs-number">9666</span> <span class="hljs-string">。</span><br><span class="hljs-string">其中最大的数字是</span> <span class="hljs-number">9969</span> <span class="hljs-string">。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：num</span> <span class="hljs-string">=</span> <span class="hljs-number">9996</span><br><span class="hljs-string">输出：9999</span><br><span class="hljs-string">解释：将最后一位从</span> <span class="hljs-number">6</span> <span class="hljs-string">变到</span> <span class="hljs-number">9</span><span class="hljs-string">，其结果</span> <span class="hljs-number">9999</span> <span class="hljs-string">是最大的数。</span><br><span class="hljs-string">示例</span> <span class="hljs-number">3</span><span class="hljs-string">：</span><br><span class="hljs-string">输入：num</span> <span class="hljs-string">=</span> <span class="hljs-number">9999</span><br><span class="hljs-string">输出：9999</span><br><span class="hljs-string">解释：无需改变就已经是最大的数字了。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^4</code></li><li><code>num</code> 每一位上的数字都是 6 或者  9 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转为数组将第一个 6 改为 9 即可。或者调用 replace 替换第一个 6 为 9</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximum69Number = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  num = (num + <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (num[i] == <span class="hljs-number">6</span>) &#123;<br>      num[i] = <span class="hljs-number">9</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximum69Number = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;&quot;</span> + num).replace(<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月21日</title>
    <link href="/2020/12/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8821%E6%97%A5/"/>
    <url>/2020/12/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt496. 下一个更大元素 I ，单调栈, 哈希表</p><span id="more"></span><h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><p>给定两个**  没有重复元素** 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。<br><code>nums1</code> 中数字 <strong>x</strong> 的下一个更大元素是指 <strong>x</strong> 在 <code>nums2</code> 中对应位置的右边的第一个比 <strong>x **大的元素。如果不存在，对应位置输出 -1 。<br> **示例 1:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>].<br>输出: [<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释:<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">4</span>，你无法在第二个数组中找到下一个更大的数字，因此输出 <span class="hljs-number">-1</span>。<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">1</span>，第二个数组中数字<span class="hljs-number">1</span>右边的下一个较大数字是 <span class="hljs-number">3</span>。<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">2</span>，第二个数组中没有下一个更大的数字，因此输出 <span class="hljs-number">-1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释:<br>    对于 <span class="hljs-symbol">num1</span> 中的数字 <span class="hljs-number">2</span> ，第二个数组中的下一个较大数字是 <span class="hljs-number">3</span> 。<br>    对于 <span class="hljs-symbol">num1</span> 中的数字 <span class="hljs-number">4</span> ，第二个数组中没有下一个更大的数字，因此输出 <span class="hljs-number">-1</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li><li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过 1000。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>双重遍历，用 indexof 找出 nums1 中元素在 nums2 中的位置，然后逐个向右找，直到找到或者遍历完，将结果插入结果数组</p><h4 id="单调栈-哈希表"><a href="#单调栈-哈希表" class="headerlink" title="单调栈+哈希表"></a>单调栈+哈希表</h4><p>遍历 nums2，将元素加入栈中，保持当前栈是一个单调递减的栈。如果当前元素比栈顶来的大，出栈，将栈顶元素设为 key，当前元素为 value 加入哈希表中。重复以上过程，直到栈空或者栈顶元素比当前元素大。最后遍历 nums1，取哈希表的值，如果没有值则返回-1。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums1) &#123;<br>    <span class="hljs-keyword">let</span> temp = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = nums2.indexOf(num); i &lt; nums2.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (nums2[i] &gt; num) &#123;<br>        temp = nums2[i];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    res.push(temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单调栈-哈希表-1"><a href="#单调栈-哈希表-1" class="headerlink" title="单调栈+哈希表"></a>单调栈+哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextGreaterElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> stack = [],<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums2) &#123;<br>    <span class="hljs-keyword">if</span> (!stack.length || num &lt;= stack[stack.length - <span class="hljs-number">1</span>]) stack.push(num);<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span> (stack.length &amp;&amp; num &gt; stack[stack.length - <span class="hljs-number">1</span>])<br>        map.set(stack.pop(), num);<br>      stack.push(num);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums1.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> (map.has(num) ? map.get(num) : -<span class="hljs-number">1</span>));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月20日</title>
    <link href="/2020/12/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8820%E6%97%A5/"/>
    <url>/2020/12/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 59 - I. 滑动窗口的最大值</p><span id="more"></span><h1 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h1><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。<br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>提示：</strong><br>你可以假设 *k *总是有效的，在输入数组不为空的情况下，1 ≤ k ≤  输入数组的大小。<br>注意：本题与主站 239 题相同：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>双重循环求每一个窗口的最大值</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>使用一个队列单调队列存储元素。遍历时，先判断移动窗口后被丢弃的那个元素是不是和队首的元素相同，是的话说明该元素已经不在窗口内，直接出队。再将新进入的元素加入单调队列中（如果当前队尾元素比当前元素小直接移除，保持队列单调递减）。再将队首加入结果数组中。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length - k; i++) &#123;<br>    res.push(<span class="hljs-built_in">Math</span>.max(...nums.slice(i, i + k)));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单调队列-1"><a href="#单调队列-1" class="headerlink" title="单调队列"></a>单调队列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> queue = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>      <span class="hljs-keyword">let</span> outElem = nums[i - k];<br>      <span class="hljs-keyword">if</span> (outElem === queue[<span class="hljs-number">0</span>]) queue.shift();<br>    &#125;<br>    <span class="hljs-keyword">const</span> inItem = nums[i];<br>    <span class="hljs-keyword">while</span> (queue.length &amp;&amp; queue[queue.length - <span class="hljs-number">1</span>] &lt; inItem) queue.pop();<br>    queue.push(inItem);<br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) res.push(queue.slice(-k)[<span class="hljs-number">0</span>]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>队列</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月19日</title>
    <link href="/2020/12/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8819%E6%97%A5/"/>
    <url>/2020/12/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 02.01. 移除重复节点</p><span id="more"></span><h1 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></h1><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。<br><strong>示例 1:</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1, 2, 3, 3, 2, 1]</span><br> 输出：<span class="hljs-selector-attr">[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1, 1, 1, 1, 2]</span><br> 输出：<span class="hljs-selector-attr">[1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><p><strong>进阶：</strong><br>如果不得使用临时缓冲区，该怎么解决？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>遍历一次 set 存储，然后再根据 set 值生成新链表返回</p><h4 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h4><p>时间换空间，遍历一次，选择一个节点，然后再从该节点开始遍历一次，将链表里所有一样值的节点删除</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeDuplicateNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> setNum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    <span class="hljs-keyword">if</span> (!setNum.has(head.val)) setNum.add(head.val);<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> ListNode();<br>  <span class="hljs-keyword">const</span> arr = [...setNum.values()];<br>  <span class="hljs-keyword">let</span> temp = res;<br>  <span class="hljs-keyword">while</span> (arr.length) &#123;<br>    temp.next = <span class="hljs-keyword">new</span> ListNode(arr.shift());<br>    temp = temp.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双重循环-1"><a href="#双重循环-1" class="headerlink" title="双重循环"></a>双重循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeDuplicateNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = head;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">let</span> q = p;<br>    <span class="hljs-keyword">while</span> (q.next) &#123;<br>      <span class="hljs-keyword">if</span> (q.next.val === p.val) q.next = q.next.next;<br>      <span class="hljs-keyword">else</span> q = q.next;<br>    &#125;<br>    p = p.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月18日</title>
    <link href="/2020/12/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8818%E6%97%A5/"/>
    <url>/2020/12/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 <code>N</code>，计算 <code>F(N)</code>。<br><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：F<span class="hljs-comment">(2)</span> = F<span class="hljs-comment">(1)</span> + F<span class="hljs-comment">(0)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：F<span class="hljs-comment">(3)</span> = F<span class="hljs-comment">(2)</span> + F<span class="hljs-comment">(1)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2.</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">4</span><br>输出：<span class="hljs-number">3</span><br>解释：F<span class="hljs-comment">(4)</span> = F<span class="hljs-comment">(3)</span> + F<span class="hljs-comment">(2)</span> = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 ≤ <code>N</code> ≤ 30</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每个数都只和自己前两个数有关，所以一次遍历，用 a，b 记录两个数，遍历时新计算出的数字值为 a+b 赋值给 b，再将 b 赋值给 a，完成一轮计算。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>,<br>    b = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    [a, b] = [b, a + b];<br>  &#125;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月17日</title>
    <link href="/2020/12/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8817%E6%97%A5/"/>
    <url>/2020/12/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1512. 好数对的数目</p><span id="more"></span><h1 id="1512-好数对的数目"><a href="#1512-好数对的数目" class="headerlink" title="1512. 好数对的数目"></a><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">1512. 好数对的数目</a></h1><p>难度简单 45 收藏分享切换为英文接收动态反馈<br>给你一个整数数组 <code>nums</code> 。<br>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。<br>返回好数对的数目。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1,1,3]<br>输出：4<br>解释：有<span class="hljs-number"> 4 </span>组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从<span class="hljs-number"> 0 </span>开始<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：数组中的每组数字都是好数对<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用桶计数法，求完之后，筛选出长度大于 1 的数组，对每个数组进行求取 2 个元素的组合数相加即为答案。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numIdenticalPairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (map[nums[i]]) map[nums[i]].push(i);<br>    <span class="hljs-keyword">else</span> map[nums[i]] = [i];<br>  &#125;<br>  <span class="hljs-keyword">const</span> fact = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) sum *= i;<br>    <span class="hljs-keyword">return</span> sum;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> fact(n) / (fact(<span class="hljs-number">2</span>) * fact(n - <span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> [...Object.values(map)])<br>    <span class="hljs-keyword">if</span> (item.length &gt; <span class="hljs-number">1</span>) res += combine(item.length);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>桶计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月16日</title>
    <link href="/2020/12/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8816%E6%97%A5/"/>
    <url>/2020/12/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 17.16. 按摩师</p><span id="more"></span><h1 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/">面试题 17.16. 按摩师</a></h1><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。<br><strong>注意：</strong>本题相对原题稍作改动<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： [1,2,3,1]<br>输出： 4<br>解释： 选择<span class="hljs-number"> 1 </span>号预约和<span class="hljs-number"> 3 </span>号预约，总时长 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 4。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择<span class="hljs-number"> 1 </span>号预约、<span class="hljs-number"> 3 </span>号预约和<span class="hljs-number"> 5 </span>号预约，总时长 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>= 12。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择<span class="hljs-number"> 1 </span>号预约、<span class="hljs-number"> 3 </span>号预约、<span class="hljs-number"> 5 </span>号预约和<span class="hljs-number"> 8 </span>号预约，总时长 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>= 12。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>同<a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>。<br>动态规划题：</p><ol><li>当没有订单时，返回 0</li><li>当只有一个订单时，返回当前订单时间</li><li>当有两个订单时，返回时间长的订单时间</li><li>当大于两个订单时，当为第 k 个时：<ol><li>如果当前单接，时间为当前单时间加上 k-2 个前的最长时间</li><li>如果当前单不接，时间为 k-1 个前最长的时间</li></ol></li></ol><p>得到的递推公式为<code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code>。<br>可以看到只和当前数的前两个数有关，可以省去 dp 的数组空间。使用 first 和 second 分别记录第 k-2 个数和第 k-1 个数，计算完<code>max(second,first+num)</code>后，将 first 设为 second，second 设为较大的那一方。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> massage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> first = <span class="hljs-number">0</span>,<br>    second = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">Math</span>.max(second, first + num);<br>    first = second;<br>    second = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(first, second);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月15日</title>
    <link href="/2020/12/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8815%E6%97%A5/"/>
    <url>/2020/12/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt637. 二叉树的层平均值</p><span id="more"></span><h1 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h1><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：<br>    3<br>   / \<br> <span class="hljs-number"> 9 </span> 20<br>    /  \<br>  <span class="hljs-number"> 15 </span>  7<br>输出：[3, 14.5, 11]<br>解释：<br>第<span class="hljs-number"> 0 </span>层的平均值是<span class="hljs-number"> 3 </span>,  第1层是 14.5 , 第2层是<span class="hljs-number"> 11 </span>。因此返回 [3, 14.5, 11] 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>节点值的范围在 32 位有符号整数范围内。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>同二叉树的层次遍历，层次遍历的时候求每层的和，结束遍历之后用和除数组长度即为平均值加入结果数组中即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> averageOfLevels = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> temp = queue.splice(<span class="hljs-number">0</span>, queue.length);<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> length = temp.length;<br>    <span class="hljs-keyword">while</span> (temp.length) &#123;<br>      <span class="hljs-keyword">let</span> node = temp.shift();<br>      sum += node.val;<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>    res.push(sum / length);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月14日</title>
    <link href="/2020/12/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8814%E6%97%A5/"/>
    <url>/2020/12/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1389. 按既定顺序创建目标数组</p><span id="more"></span><h1 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389. 按既定顺序创建目标数组"></a><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/">1389. 按既定顺序创建目标数组</a></h1><p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p><ul><li>目标数组 <code>target</code> 最初为空。</li><li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li><li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li></ul><p>请你返回目标数组。<br>题目保证数字插入位置总是存在。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,2,3,4]</span>, index = <span class="hljs-comment">[0,1,2,2,1]</span><br>输出：<span class="hljs-comment">[0,4,1,3,2]</span><br>解释：<br>nums       index     target<br>0            0        <span class="hljs-comment">[0]</span><br>1            1        <span class="hljs-comment">[0,1]</span><br>2            2        <span class="hljs-comment">[0,1,2]</span><br>3            2        <span class="hljs-comment">[0,1,3,2]</span><br>4            1        <span class="hljs-comment">[0,4,1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4,0]</span>, index = <span class="hljs-comment">[0,1,2,3,0]</span><br>输出：<span class="hljs-comment">[0,1,2,3,4]</span><br>解释：<br>nums       index     target<br>1            0        <span class="hljs-comment">[1]</span><br>2            1        <span class="hljs-comment">[1,2]</span><br>3            2        <span class="hljs-comment">[1,2,3]</span><br>4            3        <span class="hljs-comment">[1,2,3,4]</span><br>0            0        <span class="hljs-comment">[0,1,2,3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, index = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li><li><code>nums.length == index.length</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li><li><code>0 &lt;= index[i] &lt;= i</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题意进行即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">index</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> createTargetArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, index</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index.length; i++) &#123;<br>    res.splice(index[i], <span class="hljs-number">0</span>, nums[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月13日</title>
    <link href="/2020/12/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8813%E6%97%A5/"/>
    <url>/2020/12/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1436. 旅行终点站</p><span id="more"></span><h1 id="1436-旅行终点站"><a href="#1436-旅行终点站" class="headerlink" title="1436. 旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/">1436. 旅行终点站</a></h1><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA, cityB]</code> 表示该线路将会从 <code>cityA</code> 直接前往 <code>cityB</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em><br>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。<br> <strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：paths = [[<span class="hljs-string">&quot;London&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>],[<span class="hljs-string">&quot;New York&quot;</span>,<span class="hljs-string">&quot;Lima&quot;</span>],[<span class="hljs-string">&quot;Lima&quot;</span>,<span class="hljs-string">&quot;Sao Paulo&quot;</span>]]<br>输出：<span class="hljs-string">&quot;Sao Paulo&quot;</span><br>解释：从 <span class="hljs-string">&quot;London&quot;</span> 出发，最后抵达终点站 <span class="hljs-string">&quot;Sao Paulo&quot;</span> 。本次旅行的路线是 <span class="hljs-string">&quot;London&quot;</span> -&gt; <span class="hljs-string">&quot;New York&quot;</span> -&gt; <span class="hljs-string">&quot;Lima&quot;</span> -&gt; <span class="hljs-string">&quot;Sao Paulo&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：paths = [[<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>],[<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>],[<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]]<br>输出：<span class="hljs-string">&quot;A&quot;</span><br>解释：所有可能的线路是：<br><span class="hljs-string">&quot;D&quot;</span> -&gt; <span class="hljs-string">&quot;B&quot;</span> -&gt; <span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>.<br><span class="hljs-string">&quot;B&quot;</span> -&gt; <span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>.<br><span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>.<br><span class="hljs-string">&quot;A&quot;</span>.<br>显然，旅行终点站是 <span class="hljs-string">&quot;A&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：paths = <span class="hljs-string">[[&quot;A&quot;,&quot;Z&quot;]]</span><br>输出：<span class="hljs-string">&quot;Z&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= paths.length &lt;= 100</code></li><li><code>paths[i].length == 2</code></li><li><code>1 &lt;= cityA.length, cityB.length &lt;= 10</code></li><li><code>cityA!= cityB</code></li><li>所有字符串均由大小写英文字母和空格字符组成。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>先使用哈希表建表，再从第一个元素开始遍历，如果 map 中不存在以当前元素为起点，说明到达了终点，返回结果即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[][]&#125;</span> <span class="hljs-variable">paths</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> destCity = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paths</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> path <span class="hljs-keyword">of</span> paths) &#123;<br>    map.set(path[<span class="hljs-number">0</span>], path[<span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">let</span> cur = paths[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(cur)) &#123;<br>      cur = map.get(cur);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月12日</title>
    <link href="/2020/12/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8812%E6%97%A5/"/>
    <url>/2020/12/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1385. 两个数组间的距离值</p><span id="more"></span><h1 id="1385-两个数组间的距离值"><a href="#1385-两个数组间的距离值" class="headerlink" title="1385. 两个数组间的距离值"></a><a href="https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/">1385. 两个数组间的距离值</a></h1><p>给你两个整数数组 <code>arr1</code> ， <code>arr2</code> 和一个整数 <code>d</code> ，请你返回两个数组之间的 <strong>距离值</strong> 。<br>「<strong>距离值</strong>」** *<em>定义为符合此距离要求的元素数目：对于元素 <code>arr1[i]</code> ，不存在任何元素 <code>arr2[j]</code> 满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。<br> **示例 1：\</em>*</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：arr1 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>], arr2 = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>], d = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>对于 arr1[<span class="hljs-number">0</span>]=<span class="hljs-number">4</span> 我们有：<br>|<span class="hljs-type">4</span><span class="hljs-number">-10</span>|<span class="hljs-type">=6</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">4</span><span class="hljs-number">-9</span>|<span class="hljs-type">=5</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">4</span><span class="hljs-number">-1</span>|<span class="hljs-type">=3</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">4</span><span class="hljs-number">-8</span>|<span class="hljs-type">=4</span> &gt; d=<span class="hljs-number">2</span><br>所以 arr1[<span class="hljs-number">0</span>]=<span class="hljs-number">4</span> 符合距离要求<br>对于 arr1[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span> 我们有：<br>|<span class="hljs-type">5</span><span class="hljs-number">-10</span>|<span class="hljs-type">=5</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">5</span><span class="hljs-number">-9</span>|<span class="hljs-type">=4</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">5</span><span class="hljs-number">-1</span>|<span class="hljs-type">=4</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">5</span><span class="hljs-number">-8</span>|<span class="hljs-type">=3</span> &gt; d=<span class="hljs-number">2</span><br>所以 arr1[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span> 也符合距离要求<br>对于 arr1[<span class="hljs-number">2</span>]=<span class="hljs-number">8</span> 我们有：<br>|<span class="hljs-type">8</span><span class="hljs-number">-10</span>|<span class="hljs-type">=2</span> &lt;= d=<span class="hljs-number">2</span><br>|<span class="hljs-type">8</span><span class="hljs-number">-9</span>|<span class="hljs-type">=1</span> &lt;= d=<span class="hljs-number">2</span><br>|<span class="hljs-type">8</span><span class="hljs-number">-1</span>|<span class="hljs-type">=7</span> &gt; d=<span class="hljs-number">2</span><br>|<span class="hljs-type">8</span><span class="hljs-number">-8</span>|<span class="hljs-type">=0</span> &lt;= d=<span class="hljs-number">2</span><br>存在距离小于等于 <span class="hljs-number">2</span> 的情况，不符合距离要求<br>故而只有 arr1[<span class="hljs-number">0</span>]=<span class="hljs-number">4</span> 和 arr1[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span> 两个符合距离要求，距离值为 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">arr1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">arr2</span> = [-<span class="hljs-number">4</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>], <span class="hljs-attr">d</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">arr1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">arr2</span> = [-<span class="hljs-number">5</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">d</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li><li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li><li><code>0 &lt;= d &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="一行解法"><a href="#一行解法" class="headerlink" title="一行解法"></a>一行解法</h4><p>使用 filter，代替双重遍历求得的数组长度即为答案</p><h4 id="正常解法"><a href="#正常解法" class="headerlink" title="正常解法"></a>正常解法</h4><p>如果一个点不满足就可以提前结束循环了，节省时间</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="一行解法-1"><a href="#一行解法-1" class="headerlink" title="一行解法"></a>一行解法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">d</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findTheDistanceValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2, d</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr1.filter(<br>    <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> arr2.filter(<span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> <span class="hljs-built_in">Math</span>.abs(a - b) &gt; d).length === arr2.length<br>  ).length;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="正常解法-1"><a href="#正常解法-1" class="headerlink" title="正常解法"></a>正常解法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">d</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findTheDistanceValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2, d</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> a <span class="hljs-keyword">of</span> arr1) &#123;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> b <span class="hljs-keyword">of</span> arr2) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(a - b) &lt;= d) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    res += flag ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月11日</title>
    <link href="/2020/12/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8811%E6%97%A5/"/>
    <url>/2020/12/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1351. 统计有序矩阵中的负数</p><span id="more"></span><h1 id="1351-统计有序矩阵中的负数"><a href="#1351-统计有序矩阵中的负数" class="headerlink" title="1351. 统计有序矩阵中的负数"></a><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">1351. 统计有序矩阵中的负数</a></h1><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 <br>请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。<br> <strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：grid = [[4,3,2,<span class="hljs-string">-1</span>],[3,2,1,<span class="hljs-string">-1</span>],[1,1,<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>],[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>]]<br>输出：8<br>解释：矩阵中共有 8 个负数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[3,2],[1,0]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,-1],[-1,-1]]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[-1]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力无难度，不同的一行解法</p><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>利用有序数组条件，如果当前数小于 0，说明他和最右下角组成的矩阵都负数。计数完后，当前列及之后的列就可以不判断了，令当前矩阵变小。再反复对剩下的矩阵遍历，求小于 0 的元素的右下角面积，再缩小矩阵，最后即可得到答案。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countNegatives = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> grid<br>    .map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e &lt; <span class="hljs-number">0</span>).length)<br>    .reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countNegatives = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> grid.flat(<span class="hljs-number">2</span>).filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e &lt; <span class="hljs-number">0</span>).length;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="有序数组-1"><a href="#有序数组-1" class="headerlink" title="有序数组"></a>有序数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countNegatives = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,<br>    j = <span class="hljs-number">0</span>,<br>    res = <span class="hljs-number">0</span>,<br>    m = grid.length,<br>    n = grid[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j] &lt; <span class="hljs-number">0</span>) &#123;<br>        res += (m - i) * (n - j);<br>        n = j;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月10日</title>
    <link href="/2020/12/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8810%E6%97%A5/"/>
    <url>/2020/12/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt860. 柠檬水找零</p><span id="more"></span><h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></h1><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。<br>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。<br>注意，一开始你手头没有任何零钱。<br>如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最简单的贪心，按照题意写 if 即可，每次都优先先找 10 元再找 5 元。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">bills</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lemonadeChange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bills</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> five = <span class="hljs-number">0</span>,<br>    ten = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bill <span class="hljs-keyword">of</span> bills) &#123;<br>    <span class="hljs-keyword">if</span> (bill === <span class="hljs-number">5</span>) &#123;<br>      five++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill === <span class="hljs-number">10</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>) &#123;<br>      five--;<br>      ten++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill === <span class="hljs-number">20</span> &amp;&amp; (five &gt; <span class="hljs-number">2</span> || (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>))) &#123;<br>      <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;<br>        ten--;<br>        five--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">2</span>) &#123;<br>        five -= <span class="hljs-number">3</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月9日</title>
    <link href="/2020/12/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%889%E6%97%A5/"/>
    <url>/2020/12/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt999. 可以被一步捕获的棋子数</p><span id="more"></span><h1 id="999-可以被一步捕获的棋子数"><a href="#999-可以被一步捕获的棋子数" class="headerlink" title="999. 可以被一步捕获的棋子数"></a><a href="https://leetcode-cn.com/problems/available-captures-for-rook/">999. 可以被一步捕获的棋子数</a></h1><p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。<br>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p><ul><li>棋手选择主动停下来。</li><li>棋子因到达棋盘的边缘而停下。</li><li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li><li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li></ul><p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1607521843326-b4f7c55e-73ee-49f1-8c39-b6cc0c89a17b.png#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=606&originWidth=597&size=0&status=done&style=none&width=300"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：[[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：<br>在本例中，车能够捕获所有的卒。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1607521838664-a953e2a3-75e7-4fcd-a84a-134ec759dac9.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&originHeight=608&originWidth=596&size=0&status=done&style=none&width=300"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：[[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]]<br>输出：<span class="hljs-number">0</span><br>解释：<br>象阻止了车捕获任何卒。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1607521838890-20354ae5-7fbd-4016-9089-ac190a8b55dc.png#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=588&size=0&status=done&style=none&width=300"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：[[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：<br>车可以捕获位置 b5，d6 和 f5 的卒。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>board.length == board[i].length == 8</code></li><li><code>board[i][j]</code> 可以是 <code>&#39;R&#39;</code>，<code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 或 <code>&#39;p&#39;</code></li><li>只有一个格子上存在 <code>board[i][j] == &#39;R&#39;</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找到 R，然后上下左右直走，如果遇到 p 就 count 加一，如果遇到 R 或到边界则跳出，返回结果</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">board</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numRookCaptures = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">board</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,<br>    j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-string">&quot;R&quot;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-string">&quot;R&quot;</span>) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">8</span> || j == <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> x = i,<br>    y = j;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span> &amp;&amp; board[--x][y] !== <span class="hljs-string">&quot;B&quot;</span>)<br>    <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-string">&quot;p&quot;</span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  x = i;<br>  <span class="hljs-keyword">while</span> (x &lt; <span class="hljs-number">7</span> &amp;&amp; board[++x][y] !== <span class="hljs-string">&quot;B&quot;</span>)<br>    <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-string">&quot;p&quot;</span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  x = i;<br>  <span class="hljs-keyword">while</span> (y &gt; <span class="hljs-number">0</span> &amp;&amp; board[x][--y] !== <span class="hljs-string">&quot;B&quot;</span>)<br>    <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-string">&quot;p&quot;</span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  y = j;<br>  <span class="hljs-keyword">while</span> (y &lt; <span class="hljs-number">7</span> &amp;&amp; board[x][++y] !== <span class="hljs-string">&quot;B&quot;</span>)<br>    <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-string">&quot;p&quot;</span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月8日</title>
    <link href="/2020/12/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%888%E6%97%A5/"/>
    <url>/2020/12/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 01.02. 判定是否互为字符重排</p><span id="more"></span><h1 id="面试题-01-02-判定是否互为字符重排"><a href="#面试题-01-02-判定是否互为字符重排" class="headerlink" title="面试题 01.02. 判定是否互为字符重排"></a><a href="https://leetcode-cn.com/problems/check-permutation-lcci/">面试题 01.02. 判定是否互为字符重排</a></h1><p>难度简单 20 收藏分享切换为英文接收动态反馈<br>给定两个字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">&quot;bca&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">&quot;bad&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>0 &lt;= len(s1) &lt;= 100</code></li><li><code>0 &lt;= len(s2) &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>遍历一次统计字符加入哈希表，再遍历另外一个字符，删除响应的元素，最后剩下空对象则为重排字符</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>比较排序后结果是否相同</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> CheckPermutation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s1) &#123;<br>    <span class="hljs-keyword">if</span> (obj[arr]) obj[arr] += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> obj[arr] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s2) &#123;<br>    <span class="hljs-keyword">if</span> (obj[arr] &gt;= <span class="hljs-number">1</span>) obj[arr] -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">Object</span>.values(obj).filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e !== <span class="hljs-number">0</span>).length;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> CheckPermutation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> s1.split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>) === s2.split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月7日</title>
    <link href="/2020/12/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%887%E6%97%A5/"/>
    <url>/2020/12/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt832. 翻转图像</p><span id="more"></span><h1 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a></h1><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。<br>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。<br>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。<br><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <span class="hljs-string">[[1,1,0],[1,0,1],[0,0,0]]</span><br>输出: <span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br>解释: 首先翻转每一行: <span class="hljs-string">[[0,1,1],[1,0,1],[0,0,0]]</span>；<br>     然后反转图片: <span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[1,0,0,1]</span>,<span class="hljs-comment">[0,1,1,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[0,0,0,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br>解释: 首先翻转每一行: <span class="hljs-comment">[<span class="hljs-comment">[0,0,1,1]</span>,<span class="hljs-comment">[1,0,0,1]</span>,<span class="hljs-comment">[1,1,1,0]</span>,<span class="hljs-comment">[0,1,0,1]</span>]</span>；<br>     然后反转图片: <span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[0,1,1,0]</span>,<span class="hljs-comment">[0,0,0,1]</span>,<span class="hljs-comment">[1,0,1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li><li><code>0 &lt;= A[i][j] &lt;= 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按题意使用双指针交换元素，后再遍历一遍交换每个值的 1、0</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flipAndInvertImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  A = A.map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>      right = row.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      [row[left], row[right]] = [row[right], row[left]];<br>      left++;<br>      right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> row;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> A.map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> (e === <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="函数改进"><a href="#函数改进" class="headerlink" title="函数改进"></a>函数改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flipAndInvertImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> A.map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.reverse().map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> (e === <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)));<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月6日</title>
    <link href="/2020/12/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%886%E6%97%A5/"/>
    <url>/2020/12/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt925. 长按键入</p><span id="more"></span><h1 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a><a href="https://leetcode-cn.com/problems/long-pressed-name/">925. 长按键入</a></h1><p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。<br>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code>。<br> <strong>示例 1：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入：<span class="hljs-type">name</span> = &quot;alex&quot;, typed = &quot;aaleex&quot;<br>输出：<span class="hljs-keyword">true</span><br>解释：<span class="hljs-string">&#x27;alex&#x27;</span> 中的 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;e&#x27;</span> 被长按。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;saeed&quot;</span>, <span class="hljs-attr">typed</span> = <span class="hljs-string">&quot;ssaaedd&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：&#x27;e&#x27; 一定需要被键入两次，但在 typed 的输出中不是这样。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;leelee&quot;</span>, <span class="hljs-attr">typed</span> = <span class="hljs-string">&quot;lleeelee&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;laiden&quot;</span>, <span class="hljs-attr">typed</span> = <span class="hljs-string">&quot;laiden&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：长按名字中的字符并不是必要的。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>name.length &lt;= 1000</code></li><li><code>typed.length &lt;= 1000</code></li><li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两个指针分别指向两个字符串的开始：</p><ol><li>如果指针指向的字符相同：<ol><li>如果 p 的下一个不是重复字符的话，将 q 一直指向下一个字符，直到指向不同的字符</li><li>如果 p 的下一个是相同字符的话，将 q 指向下一个字符即可</li><li>p 指向下一个字符</li></ol></li><li>如果指向的不同，直接返回 false</li><li>判断两个指针是否刚好指向结尾的后一个，如果不是说没，其中一个字符串多出了字符，不符合题意，返回 false</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">name</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">typed</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isLongPressedName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, typed</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>,<br>    q = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p &lt; name.length &amp;&amp; q &lt; typed.length) &#123;<br>    <span class="hljs-keyword">if</span> (name[p] === typed[q]) &#123;<br>      <span class="hljs-keyword">if</span> (name[p] !== name[++p]) <span class="hljs-keyword">while</span> (typed[q] === typed[++q]) &#123;&#125;<br>      <span class="hljs-keyword">else</span> q++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p === name.length &amp;&amp; q === typed.length;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月5日</title>
    <link href="/2020/12/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%885%E6%97%A5/"/>
    <url>/2020/12/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 02.02. 返回倒数第 k 个节点，快慢指针</p><span id="more"></span><h1 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h1><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。<br><strong>注意：</strong>本题相对原题稍作改动<br><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入： <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span> 和 k = <span class="hljs-number">2</span><br>输出： <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong><br>给定的 <em>k</em> 保证是有效的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针，快指针先移动，当计数到 k 时，慢指针移动，当快指针到链表尾部时，慢指针正指向倒数第 k 个节点</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthToLast = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> slow = head,<br>    fast = head,<br>    count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (fast) &#123;<br>    count++;<br>    fast = fast.next;<br>    <span class="hljs-keyword">if</span> (count &gt;= k &amp;&amp; fast) slow = slow.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slow.val;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月4日</title>
    <link href="/2020/12/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%884%E6%97%A5/"/>
    <url>/2020/12/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt836. 矩形重叠</p><span id="more"></span><h1 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a></h1><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。<br>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。<br>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">rec1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">rec2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">rec1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">rec2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">rec1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">rec2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rect1.length == 4</code></li><li><code>rect2.length == 4</code></li><li><code>-10 &lt;= rec1[i], rec2[i] &lt;= 10</code></li><li><code>rec1[0] &lt;= rec1[2]</code> 且 <code>rec1[1] &lt;= rec1[3]</code></li><li><code>rec2[0] &lt;= rec2[2]</code> 且 <code>rec2[1] &lt;= rec2[3]</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当一个矩形在另外一个矩形的外侧，即：左下角的点在另外一个矩形右上角的点上侧或右侧，或右上角的点在另外一个矩形左下角点的左侧或下侧时，两个矩形不相交，根据以上情况可以解出题目。要注意题目输入用例有一个线段用例，还需要判断构成的面积是否大于 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">rec1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">rec2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isRectangleOverlap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rec1, rec2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [[x1, y1, x2, y2], [x3, y3, x4, y4]] = [rec1, rec2];<br>  <span class="hljs-keyword">return</span> (<br>    !(y3 &gt;= y2 || x3 &gt;= x2 || x4 &lt;= x1 || y4 &lt;= y1) &amp;&amp;<br>    (x2 - x1) * (y2 - y1) * (x4 - x3) * (y4 - y3) &gt; <span class="hljs-number">0</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月3日</title>
    <link href="/2020/12/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%883%E6%97%A5/"/>
    <url>/2020/12/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>L1480. 一维数组的动态和</p><span id="more"></span><h1 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></h1><p>难度简单 41 收藏分享切换为英文接收动态反馈<br>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code> 。<br>请返回 <code>nums</code> 的动态和。<br><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1<span class="hljs-string">+2</span>, 1<span class="hljs-string">+2</span><span class="hljs-string">+3</span>, 1<span class="hljs-string">+2</span><span class="hljs-string">+3</span><span class="hljs-string">+4</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1<span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,2,10,1]</span><br>输出：<span class="hljs-string">[3,4,6,16,17]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="新数组"><a href="#新数组" class="headerlink" title="新数组"></a>新数组</h4><p>借助一个 count，map 遍历返回新数组</p><h4 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h4><p>当前数加上前一个数即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="新数组-1"><a href="#新数组-1" class="headerlink" title="新数组"></a>新数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> runningSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> nums.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    count += e;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="原地修改-1"><a href="#原地修改-1" class="headerlink" title="原地修改"></a>原地修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> runningSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月2日</title>
    <link href="/2020/12/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%882%E6%97%A5/"/>
    <url>/2020/12/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt 面试题 01.04. 回文排列</p><span id="more"></span><h1 id="面试题-01-04-回文排列"><a href="#面试题-01-04-回文排列" class="headerlink" title="面试题 01.04. 回文排列"></a><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">面试题 01.04. 回文排列</a></h1><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>回文串不一定是字典当中的单词。 <br><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：<span class="hljs-string">&quot;tactcoa&quot;</span><br>输出：<span class="hljs-literal">true</span>（排列有<span class="hljs-string">&quot;tacocat&quot;</span>、<span class="hljs-string">&quot;atcocta&quot;</span>，等等）<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序后，两两删除，判断最后剩下的数组长度是否为 1 或 0</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>遍历计数后筛选出不为偶数的元素个数，出现个数至多只能 1 个</p><h4 id="哈希表优化"><a href="#哈希表优化" class="headerlink" title="哈希表优化"></a>哈希表优化</h4><p>实际上不需要储存个数，如果存在就删除，如果不存在就设置，最后直接统计哈希表中的元素即可。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>同上</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>).sort();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] === s[i + <span class="hljs-number">1</span>]) &#123;<br>      s.splice(i, <span class="hljs-number">2</span>);<br>      i -= <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.length &lt;= <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) map.set(arr, map.has(arr) ? map.get(arr) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [...map.values()].filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>).length &lt;= <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希表优化-1"><a href="#哈希表优化-1" class="headerlink" title="哈希表优化"></a>哈希表优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (map[arr]) <span class="hljs-keyword">delete</span> map[arr];<br>    <span class="hljs-keyword">else</span> map[arr] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(map).length &lt;= <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (set.has(arr)) set.delete(arr);<br>    <span class="hljs-keyword">else</span> set.add(arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> set.size &lt;= <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年12月1日</title>
    <link href="/2020/12/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%881%E6%97%A5/"/>
    <url>/2020/12/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B412%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt34. 在排序数组中查找元素的第一个和最后一个位置，二分算法</p><span id="more"></span><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>难度中等 677 收藏分享切换为英文接收动态反馈<br>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。<br><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例  2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="普通遍历"><a href="#普通遍历" class="headerlink" title="普通遍历"></a>普通遍历</h4><p>使用两个额外变量，记录第一次出现下标，遍历元素，每出现一次就更新一次最后出现的下标。时间复杂度 O(n)</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>先使用二分查找出第一个等于目标值的元素的下标，再分别再左右两边二分算法，缩小窗口大小，直到又找到一个等于目标值的元素：如果是左边就不断令左窗口边界减一直到边界值剑一的元素为非目标值元素，如果是左边就不断令右窗口边界加一直到边界值加一的元素为非目标值元素。左右窗口边界的值即为所求目标。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="普通遍历-1"><a href="#普通遍历-1" class="headerlink" title="普通遍历"></a>普通遍历</h4><p>不写了，很容易就可以想到，此题为复习题，可以搜索查看之前的博文。</p><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>执行用时超过 99%</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>,<br>    end = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt; target) start = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) end = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>      index = mid;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<br>  start = <span class="hljs-number">0</span>;<br>  end = index;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    start = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[start] &lt; target) start++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; nums[start - <span class="hljs-number">1</span>] === target) start--;<br>      res[<span class="hljs-number">0</span>] = start;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  start = index;<br>  end = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    end = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[end] &gt; target) end--;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span> (end &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[end + <span class="hljs-number">1</span>] === target) end++;<br>      res[<span class="hljs-number">1</span>] = end;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月30日</title>
    <link href="/2020/11/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8830%E6%97%A5/"/>
    <url>/2020/11/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1342. 将数字变成 0 的操作次数</p><span id="more"></span><h1 id="1342-将数字变成-0-的操作次数"><a href="#1342-将数字变成-0-的操作次数" class="headerlink" title="1342. 将数字变成 0 的操作次数"></a><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/">1342. 将数字变成 0 的操作次数</a></h1><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 14<br>输出：6<br>解释：<br>步骤 1)<span class="hljs-number"> 14 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 7 </span>。<br>步骤 2）<span class="hljs-number"> 7 </span>是奇数，减<span class="hljs-number"> 1 </span>得到<span class="hljs-number"> 6 </span>。<br>步骤 3）<span class="hljs-number"> 6 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 3 </span>。<br>步骤 4）<span class="hljs-number"> 3 </span>是奇数，减<span class="hljs-number"> 1 </span>得到<span class="hljs-number"> 2 </span>。<br>步骤 5）<span class="hljs-number"> 2 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 1 </span>。<br>步骤 6）<span class="hljs-number"> 1 </span>是奇数，减<span class="hljs-number"> 1 </span>得到<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 8<br>输出：4<br>解释：<br>步骤 1）<span class="hljs-number"> 8 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 4 </span>。<br>步骤 2）<span class="hljs-number"> 4 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 2 </span>。<br>步骤 3）<span class="hljs-number"> 2 </span>是偶数，除以<span class="hljs-number"> 2 </span>得到<span class="hljs-number"> 1 </span>。<br>步骤 4）<span class="hljs-number"> 1 </span>是奇数，减<span class="hljs-number"> 1 </span>得到<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">123</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt;= 10^6</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p>按照题目要求运算即可</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>num 与 1 进行与计算，如果二进制第一位为 1，与计算结果为 1，说明是奇数。将当前数与 1 进行异或计算，将第一位变为 0。如果与 1 与计算为 0，说明为偶数，将当前数右移以为，相当于除以 2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="常规-1"><a href="#常规-1" class="headerlink" title="常规"></a>常规</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numberOfSteps = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (num) &#123;<br>    count++;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) num /= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> num--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numberOfSteps = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (num) &#123;<br>    <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) === <span class="hljs-number">0</span>) num &gt;&gt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> num ^= <span class="hljs-number">1</span>;<br>    count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月29日</title>
    <link href="/2020/11/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8829%E6%97%A5/"/>
    <url>/2020/11/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt976. 三角形的最大周长，排序</p><span id="more"></span><h1 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a></h1><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。<br>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。<br> <strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,1,2]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2,3,4]</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,6,2,3]</span><br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 10^6</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>按降序排序，从第一个开始，判断连续的三个元素是否可以构成三角形，可以的话返回这三个元素的和。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> largestPerimeter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  A.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; A.length - <span class="hljs-number">2</span>; index++) &#123;<br>    <span class="hljs-keyword">if</span> (A[index + <span class="hljs-number">2</span>] + A[index + <span class="hljs-number">1</span>] &gt; A[index])<br>      <span class="hljs-keyword">return</span> A[index] + A[index + <span class="hljs-number">1</span>] + A[index + <span class="hljs-number">2</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月28日</title>
    <link href="/2020/11/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8828%E6%97%A5/"/>
    <url>/2020/11/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1160. 拼写单词，哈希表，桶计数</p><span id="more"></span><h1 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160. 拼写单词"></a><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">1160. 拼写单词</a></h1><p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。<br>假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。<br>注意：每次拼写（指拼写词汇表中的一个单词）时，<code>chars</code> 中的每个字母都只能用一次。<br>返回词汇表 <code>words</code> 中你掌握的所有单词的 <strong>长度之和</strong>。<br> <strong>示例 1：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;bt&quot;</span>,<span class="hljs-string">&quot;hat&quot;</span>,<span class="hljs-string">&quot;tree&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;atach&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<br>可以形成字符串 <span class="hljs-string">&quot;cat&quot;</span> 和 <span class="hljs-string">&quot;hat&quot;</span>，所以答案是 <span class="hljs-number">3</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;welldonehoneyr&quot;</span><br>输出：<span class="hljs-number">10</span><br>解释：<br>可以形成字符串 <span class="hljs-string">&quot;hello&quot;</span> 和 <span class="hljs-string">&quot;world&quot;</span>，所以答案是 <span class="hljs-number">5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li><li>所有字符串中都仅包含小写英文字母</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>暴力，哈希表计数，char 对应的 map 和当前字符 map 相减，看 word 是不是存在不存在的字符，以及数量是否可拼写</p><h4 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h4><p>word 求 map 是不必要的，一次遍历即可出结果，使用双重循环优化</p><h4 id="桶计数"><a href="#桶计数" class="headerlink" title="桶计数"></a>桶计数</h4><p>因为只有 26 个字母，可以使用桶计数。大大节省时间空间复杂度，双 99%。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">chars</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countCharacters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words, chars</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getMap = <span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) map[char] ? map[char]++ : (map[char] = <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> calculateMap = <span class="hljs-function">(<span class="hljs-params">wordMap, charMap</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> wordMap) &#123;<br>      <span class="hljs-keyword">if</span> (!charMap[key]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      charMap[key] -= wordMap[key];<br>      <span class="hljs-keyword">if</span> (charMap[key] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> charMap = getMap(chars);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">const</span> tempMap = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, charMap);<br>    res += calculateMap(getMap(word), tempMap) ? word.length : <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">chars</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countCharacters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words, chars</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getMap = <span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> s) map[char] ? map[char]++ : (map[char] = <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> charMap = getMap(chars);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">const</span> tempMap = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, charMap);<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> word) &#123;<br>      <span class="hljs-keyword">if</span> (!tempMap[arr]) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      tempMap[arr] -= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) res += word.length;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="桶计数-1"><a href="#桶计数-1" class="headerlink" title="桶计数"></a>桶计数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">chars</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countCharacters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words, chars</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) arr[chars.charCodeAt(i) - <span class="hljs-number">97</span>]++;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">const</span> tempArr = arr.concat();<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; word.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!tempArr[word.charCodeAt(i) - <span class="hljs-number">97</span>]) flag = <span class="hljs-literal">false</span>;<br>      tempArr[word.charCodeAt(i) - <span class="hljs-number">97</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) res += word.length;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月27日</title>
    <link href="/2020/11/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8827%E6%97%A5/"/>
    <url>/2020/11/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt876. 链表的中间结点，快慢指针</p><span id="more"></span><h1 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h1><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。<br><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-attr">[1,2,3,4,5]</span><br>输出：此列表中的结点 <span class="hljs-number">3</span> (序列化形式：<span class="hljs-selector-attr">[3,4,5]</span>)<br>返回的结点值为 <span class="hljs-number">3</span> 。 (测评系统对该结点序列化表述是 <span class="hljs-selector-attr">[3,4,5]</span>)。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans<span class="hljs-selector-class">.val</span> = <span class="hljs-number">3</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">4</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">5</span>, 以及 ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span> = NULL.<br></code></pre></td></tr></table></figure><p><strong>示例  2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,3,4,5,6]</span><br>输出：此列表中的结点 <span class="hljs-number">4</span> (序列化形式：<span class="hljs-selector-attr">[4,5,6]</span>)<br>由于该列表有两个中间结点，值分别为 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span>，我们返回第二个结点。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>设置快慢指针遍历链表，快指针遍历完时，慢指针正好在链表中点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> slow = head,<br>    fast = head;<br>  <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) &#123;<br>    slow = slow.next;<br>    fast = fast.next.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月26日</title>
    <link href="/2020/11/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8826%E6%97%A5/"/>
    <url>/2020/11/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt347. 前 K 个高频元素</p><span id="more"></span><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p>给定一个非空的整数数组，返回其中出现频率前 <strong>_k _</strong>高的元素。<br> <strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出: <span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你可以假设给定的 *k *总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , *n *是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希表排序"><a href="#哈希表排序" class="headerlink" title="哈希表排序"></a>哈希表排序</h4><p>借助哈希表记录元素个数，sort 排序，取前 k 个元素返回。时间复杂度最大的为排序，O(nlogn)。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="哈希表排序-1"><a href="#哈希表排序-1" class="headerlink" title="哈希表排序"></a>哈希表排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) map.set(num, map.has(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [...map.entries()]<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>])<br>    .splice(<span class="hljs-number">0</span>, k)<br>    .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月25日</title>
    <link href="/2020/11/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8825%E6%97%A5/"/>
    <url>/2020/11/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1370. 上升下降字符串，桶计数</p><span id="more"></span><h1 id="1370-上升下降字符串"><a href="#1370-上升下降字符串" class="headerlink" title="1370. 上升下降字符串"></a><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">1370. 上升下降字符串</a></h1><p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p><ol><li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li><li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li><li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li></ol><p>在任何一步中，如果最小或者最大字符不止一个  ，你可以选择其中任意一个，并将其添加到结果字符串。<br>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。<br><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaaabbbbcccc&quot;</span><br>输出：<span class="hljs-string">&quot;abccbaabccba&quot;</span><br>解释：第一轮的步骤 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> 后，结果字符串为 <span class="hljs-attr">result</span> = <span class="hljs-string">&quot;abc&quot;</span><br>第一轮的步骤 <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> 后，结果字符串为 <span class="hljs-attr">result</span> = <span class="hljs-string">&quot;abccba&quot;</span><br>第一轮结束，现在 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aabbcc&quot;</span> ，我们再次回到步骤 <span class="hljs-number">1</span><br>第二轮的步骤 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> 后，结果字符串为 <span class="hljs-attr">result</span> = <span class="hljs-string">&quot;abccbaabc&quot;</span><br>第二轮的步骤 <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> 后，结果字符串为 <span class="hljs-attr">result</span> = <span class="hljs-string">&quot;abccbaabccba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rat&quot;</span><br>输出：<span class="hljs-string">&quot;art&quot;</span><br>解释：单词 <span class="hljs-string">&quot;rat&quot;</span> 在上述算法重排序以后变成 <span class="hljs-string">&quot;art&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;cdelotee&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ggggggg&quot;</span><br>输出：<span class="hljs-string">&quot;ggggggg&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;spo&quot;</span><br>输出：<span class="hljs-string">&quot;ops&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>完全按照题目的算法步骤，结合 set 实现，每次都遍历一次原字符串，直接使用 splice 删除原字符串。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>输入仅有 26 个字母，可以使用桶排序，先遍历原字符串将字母放入桶中，步骤 1-2 其实就是从 0 开始，找下一个非 0 桶将其中的元素加入结果字符串，步骤 4-5 其实就是从 25 开始，找下一个非 0 桶加入结果字符串中。直到所有桶中都为空，结束循环。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> length = s.length;<br>  <span class="hljs-keyword">while</span> (res.length &lt; length) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>    <span class="hljs-keyword">while</span> (s.length) &#123;<br>      <span class="hljs-keyword">let</span> min = <span class="hljs-string">&quot;&#123;&quot;</span>;<br>      <span class="hljs-keyword">let</span> minIndex = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &lt; min &amp;&amp; !map.has(s[i])) &#123;<br>          min = s[i];<br>          minIndex = i;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (min === <span class="hljs-string">&quot;&#123;&quot;</span>) <span class="hljs-keyword">break</span>;<br>      s.splice(minIndex, <span class="hljs-number">1</span>);<br>      map.add(min);<br>      res += min;<br>    &#125;<br>    map.clear();<br>    <span class="hljs-keyword">while</span> (s.length) &#123;<br>      <span class="hljs-keyword">let</span> max = <span class="hljs-string">&quot;`&quot;</span>;<br>      <span class="hljs-keyword">let</span> maxIndex = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt; max &amp;&amp; !map.has(s[i])) &#123;<br>          max = s[i];<br>          maxIndex = i;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (max === <span class="hljs-string">&quot;`&quot;</span>) <span class="hljs-keyword">break</span>;<br>      s.splice(maxIndex, <span class="hljs-number">1</span>);<br>      map.add(max);<br>      res += max;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="桶排序-1"><a href="#桶排序-1" class="headerlink" title="桶排序"></a>桶排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) arr[s.charCodeAt(i) - <span class="hljs-number">97</span>]++;<br>  <span class="hljs-keyword">while</span> (res.length &lt; s.length) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i]) &#123;<br>        res += <span class="hljs-built_in">String</span>.fromCharCode(i + <span class="hljs-number">97</span>);<br><br>        arr[i]--;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i]) &#123;<br>        res += <span class="hljs-built_in">String</span>.fromCharCode(i + <span class="hljs-number">97</span>);<br>        arr[i]--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月24日</title>
    <link href="/2020/11/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8824%E6%97%A5/"/>
    <url>/2020/11/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt222. 完全二叉树的节点个数，二分算法</p><span id="more"></span><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h1><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。<br><strong>说明：</strong><br><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2 个节点。<br><strong>示例:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入:<br>    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> <span class="hljs-regexp">/ \  /</span><br><span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>输出: <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="简单遍历"><a href="#简单遍历" class="headerlink" title="简单遍历"></a>简单遍历</h4><p>简单递归便利二叉树计数节点数量即可</p><h4 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h4><p>分别求出当前节点左右子树的高度，因为是完全二叉树只可能有两种情况：</p><ol><li>左右子树高度相同，因此可以判定左子树一定为满二叉树，n 为树深度，节点数量为 2^n-1，加上当前节点一共 2^n 个。然后判断右子树。</li><li>右子树的高度小于左子树的高度，可以判断当前树非满二叉树，但是右子树一定是满二叉树，加上右子树的所有节点。然后判断左子树。</li></ol><p>直到找到最后一个节点，结束递归。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="简单遍历-1"><a href="#简单遍历-1" class="headerlink" title="简单遍历"></a>简单遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> root ? countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="完全二叉树性质-1"><a href="#完全二叉树性质-1" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> getDepth = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> node ? <span class="hljs-number">1</span> + getDepth(node.left) : <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> countNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> left = getDepth(root.left);<br>  <span class="hljs-keyword">const</span> right = getDepth(root.right);<br>  <span class="hljs-keyword">if</span> (left === right) <span class="hljs-keyword">return</span> countNodes(root.right) + (<span class="hljs-number">1</span> &lt;&lt; left);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> countNodes(root.left) + (<span class="hljs-number">1</span> &lt;&lt; right);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>二分算法</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月23日</title>
    <link href="/2020/11/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8823%E6%97%A5/"/>
    <url>/2020/11/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1295. 统计位数为偶数的数字,Lt1470. 重新排列数组</p><span id="more"></span><h1 id="1295-统计位数为偶数的数字"><a href="#1295-统计位数为偶数的数字" class="headerlink" title="1295. 统计位数为偶数的数字"></a><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">1295. 统计位数为偶数的数字</a></h1><p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [12,345,2,6,7896]<br>输出：2<br>解释：<br>12 是<span class="hljs-number"> 2 </span>位数字（位数为偶数）<br>345 是<span class="hljs-number"> 3 </span>位数字（位数为奇数）<br>2 是<span class="hljs-number"> 1 </span>位数字（位数为奇数）<br>6 是<span class="hljs-number"> 1 </span>位数字 位数为奇数）<br>7896 是<span class="hljs-number"> 4 </span>位数字（位数为偶数）<br>因此只有<span class="hljs-number"> 12 </span>和<span class="hljs-number"> 7896 </span>是位数为偶数的数字<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">555,901</span>,<span class="hljs-number">482,1771</span>]<br>输出：<span class="hljs-number">1</span><br>解释：<br>只有 <span class="hljs-number">1771</span> 是位数为偶数的数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 filter 筛选出位数为偶数的元素即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">String</span>(e).length % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>).length;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1470-重新排列数组"><a href="#1470-重新排列数组" class="headerlink" title="1470. 重新排列数组"></a><a href="https://leetcode-cn.com/problems/shuffle-the-array/">1470. 重新排列数组</a></h1><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x,x,...,x,y,y,...,y]</code> 的格式排列。<br>请你将数组按 <code>[x,y,x,y,...,x,y]</code> 格式重新排列，返回重排后的数组。<br><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [2,5,1,3,4,7], n = 3<br>输出：[2,3,5,4,1,7]<br>解释：由于 <span class="hljs-attribute">x1</span>=2, <span class="hljs-attribute">x2</span>=5, <span class="hljs-attribute">x3</span>=1, <span class="hljs-attribute">y1</span>=3, <span class="hljs-attribute">y2</span>=4, <span class="hljs-attribute">y3</span>=7 ，所以答案为 [2,3,5,4,1,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">4,3,2,1</span>], n = <span class="hljs-number">4</span><br>输出：[<span class="hljs-number">1,4,2,3</span>,<span class="hljs-number">3,2,4,1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,2,2</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,1,2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 500</code></li><li><code>nums.length == 2n</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="双数组"><a href="#双数组" class="headerlink" title="双数组"></a>双数组</h4><p>裁出头部元素，分为 x 数组和 y 数组，两个数组轮流出栈加入结果数组中。</p><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>节省出栈操作。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="双数组-1"><a href="#双数组-1" class="headerlink" title="双数组"></a>双数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> shuffle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> head = nums.splice(<span class="hljs-number">0</span>, nums.length / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (head.length) res.push(head.shift(), nums.shift());<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="空间优化-1"><a href="#空间优化-1" class="headerlink" title="空间优化"></a>空间优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> shuffle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length / <span class="hljs-number">2</span>; i++) &#123;<br>    res.push(nums[i], nums[i + nums.length / <span class="hljs-number">2</span>]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月22日</title>
    <link href="/2020/11/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8822%E6%97%A5/"/>
    <url>/2020/11/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>面试题 01.06. 字符串压缩、栈</p><span id="more"></span><h1 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a><a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a></h1><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a 至 z）。<br><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;aabcccccaaa&quot;</span><br> 输出：<span class="hljs-string">&quot;a2b1c5a3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;abbccd&quot;</span><br>输出：<span class="hljs-string">&quot;abbccd&quot;</span><br>解释：<span class="hljs-string">&quot;abbccd&quot;</span>压缩后为<span class="hljs-string">&quot;a1b2c2d1&quot;</span>，比原字符串长度更长。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>字符串长度在[0, 50000]范围内。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>使用栈记录出现的元素和个数，最后再转化为字符串</p><h4 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h4><p>很显然不需要栈进行维护，只需要判断是否是新的字符即可，使用一个 temp 数组，第一项是字符，第二个是连续出现的个数。遍历字符串，如果是新的字符就将临时记录的 temp 拼接加到结果字符串中，不是新的字符就继续计数。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> compressString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!S) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">const</span> stack = [[S[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> S) &#123;<br>    <span class="hljs-keyword">if</span> (stack[stack.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === arr) stack[stack.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]++;<br>    <span class="hljs-keyword">else</span> stack.push([arr, <span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">const</span> res = stack.map(<span class="hljs-function">(<span class="hljs-params">[a, b]</span>) =&gt;</span> a + b).join(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">return</span> res.length &gt;= S.length ? S : res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="优化空间-1"><a href="#优化空间-1" class="headerlink" title="优化空间"></a>优化空间</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> compressString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!S) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> temp = [S[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> S) &#123;<br>    <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">0</span>] === arr) temp[<span class="hljs-number">1</span>]++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      res += temp[<span class="hljs-number">0</span>] + temp[<span class="hljs-number">1</span>];<br>      temp = [arr, <span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>  res += temp[<span class="hljs-number">0</span>] + temp[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> res.length &gt;= S.length ? S : res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月21日</title>
    <link href="/2020/11/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8821%E6%97%A5/"/>
    <url>/2020/11/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt92. 反转链表 II</p><span id="more"></span><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。<br><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。<br><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL, m = <span class="hljs-number">2</span>, n = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>结合<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>的思路。将链表分割成三部分，头部尾部以及需要翻转的部分。</p><ol><li>使用 dummy 哑结点解决 m=1 的情况。首先进行一部分遍历，temp 为遍历的指针，直到当前 temp 节点的 next 为需要翻转节点的首节点。</li><li>再使用一个 cur 作为临时指针。此时问题就转化成了<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>，但是不需要完全翻转，只需要翻转 n-m+1 个元素即可，所以使用 for 再进行一次遍历，遍历次数为 n-m+1 次。例如<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 2, n = 4</code>这个用例，temp 为<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL</code>，cur 为<code>2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL</code>，对 4-2+1 三个元素：2、3、4 进行反转。建立一个 prev 作为记录上一个节点的指针，初始指向 null，执行以下过程。<ol><li>先使用<code>nextTemp</code>记录<code>cur.next</code></li><li><code>cur.next</code>指向<code>prev</code></li><li><code>prev</code>指向<code>cur</code></li><li><code>cur</code>指向<code>nextTemp</code></li></ol></li><li>执行完以上过程之后，会将链表划分为三段。<code>prev</code>指向已经翻转完毕的链表的开始<code>4-&gt;3-&gt;2-&gt;NULL</code>，cur 指向剩余的尾部链表<code>5-&gt;6-&gt;NULL</code>。因为修改过 2 的指向，所以<code>temp</code>会变成<code>1-&gt;2-&gt;NULL</code>。</li><li>现在要修改指向，2 的 next 应该指向尾部，1 的 next 应该指向翻转完毕链表。所以<code>temp.next.next</code>指向<code>cur</code>，<code>temp.next</code>指向<code>prev</code>，即可将三段重新拼接成一条链表。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, m, n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> ListNode();<br>  dummy.next = head;<br>  <span class="hljs-keyword">let</span> temp = dummy;<br>  <span class="hljs-keyword">let</span> tail = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) temp = temp.next;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> cur = temp.next;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - m + <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> nextTemp = cur.next;<br>    cur.next = prev;<br>    prev = cur;<br>    cur = nextTemp;<br>  &#125;<br>  temp.next.next = cur;<br>  temp.next = prev;<br>  <span class="hljs-keyword">return</span> dummy.next;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月20日</title>
    <link href="/2020/11/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8820%E6%97%A5/"/>
    <url>/2020/11/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt292. Nim 游戏。搬家找房休息几天，做几题简单题。</p><span id="more"></span><h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a></h1><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim 游戏</a>：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉  1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者。</li></ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。<br> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：false<br>解释：如果堆中有<span class="hljs-number"> 4 </span>块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走<span class="hljs-number"> 1 </span>块、2 块 还是<span class="hljs-number"> 3 </span>块石头，最后一块石头总是会被你的朋友拿走。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 - 1</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归纳总结规律可以看出，若想赢，需要先手取让剩余数目为 4 的倍数。所以判断 n 是否为 4 的倍数即可解题。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canWinNim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> !== <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>脑筋急转弯</tag>
      
      <tag>极小化极大</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月19日</title>
    <link href="/2020/11/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8819%E6%97%A5/"/>
    <url>/2020/11/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt283. 移动零</p><span id="more"></span><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<br><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="双层遍历（冒泡）"><a href="#双层遍历（冒泡）" class="headerlink" title="双层遍历（冒泡）"></a>双层遍历（冒泡）</h4><p>很显然可以得到一种解法，类似冒泡，遍历每一个元素，如果当前是 0 将它与它之后第一个非 0 元素交换位置。最后可以将 0 都冒泡到数组尾部。</p><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p>使用一个 index 记录非 0 的数要排在第几个，每次设置非 0 的元素都令 index++。遍历完数组以后，将剩余的位置全部设为 0 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="双层遍历（冒泡）-1"><a href="#双层遍历（冒泡）-1" class="headerlink" title="双层遍历（冒泡）"></a>双层遍历（冒泡）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> index = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (index &lt; nums.length &amp;&amp; nums[index] === <span class="hljs-number">0</span>) index++;<br>      <span class="hljs-keyword">if</span> (index &lt; nums.length) [nums[i], nums[index]] = [nums[index], nums[i]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="一次遍历-1"><a href="#一次遍历-1" class="headerlink" title="一次遍历"></a>一次遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (num) nums[index++] = num;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (index &lt; nums.length) nums[index++] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月17日</title>
    <link href="/2020/11/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8817%E6%97%A5/"/>
    <url>/2020/11/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1030. 距离顺序排列矩阵单元格，桶排序，BFS</p><span id="more"></span><h1 id="1030-距离顺序排列矩阵单元格"><a href="#1030-距离顺序排列矩阵单元格" class="headerlink" title="1030. 距离顺序排列矩阵单元格"></a><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">1030. 距离顺序排列矩阵单元格</a></h1><p>给出 <code>R</code> 行 <code>C</code> 列的矩阵，其中的单元格的整数坐标为 <code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code> 且 <code>0 &lt;= c &lt; C</code>。<br>另外，我们在该矩阵中给出了一个坐标为 <code>(r0, c0)</code> 的单元格。<br>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）<br> <strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：R = <span class="hljs-number">1</span>, C = <span class="hljs-number">2</span>, r0 = <span class="hljs-number">0</span>, c0 = <span class="hljs-number">0</span><br>输出：<span class="hljs-string">[[0,0],[0,1]]</span><br>解释：从 (r0, c0) 到其他单元格的距离为：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：R = 2, C = 2, r0 = 0, c0 = 1<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>解释：从 (r0, c0) 到其他单元格的距离为：<span class="hljs-comment">[0,1,1,2]</span><br><span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[1,0]</span>]</span> 也会被视作正确答案。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：R = 2, C = 3, r0 = 1, c0 = 2<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[0,0]</span>]</span><br>解释：从 (r0, c0) 到其他单元格的距离为：<span class="hljs-comment">[0,1,1,2,2,3]</span><br>其他满足题目要求的答案也会被视为正确，例如 <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[0,0]</span>]</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= R &lt;= 100</code></li><li><code>1 &lt;= C &lt;= 100</code></li><li><code>0 &lt;= r0 &lt; R</code></li><li><code>0 &lt;= c0 &lt; C</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h4><p>先生成一个所有点数组，再根据曼哈顿距离升序排序即可。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>使用桶排序，节省了排序的步骤。根据距离在 map 中放置元素，再遍历 map，默认就是从最小到最大距离来遍历。直接将对应的 value 连接上结果数组中即可。</p><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>BFS 思想，曼哈顿距离如以上矩阵所示。使用一个矩阵记录当前点是否已遍历过，将当前点加入结果数组，然后将当前点上下左右的点加入队列，并设为已访问过。加入结果数组的顺序根据 BFS 过程，一定符合曼哈顿距离从小到大的顺序。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="直接排序-1"><a href="#直接排序-1" class="headerlink" title="直接排序"></a>直接排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">C</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">r0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">c0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> allCellsDistOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">R, C, r0, c0</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> points = [];<br>  points.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(R * C));<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; R; x++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; C; y++) &#123;<br>      points[index++] = [x, y];<br>    &#125;<br>  &#125;<br>  points.sort(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span><br>      <span class="hljs-built_in">Math</span>.abs(r0 - a[<span class="hljs-number">0</span>]) +<br>      <span class="hljs-built_in">Math</span>.abs(c0 - a[<span class="hljs-number">1</span>]) -<br>      (<span class="hljs-built_in">Math</span>.abs(r0 - b[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">Math</span>.abs(c0 - b[<span class="hljs-number">1</span>]))<br>  );<br>  <span class="hljs-keyword">return</span> points;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="桶排序-1"><a href="#桶排序-1" class="headerlink" title="桶排序"></a>桶排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">C</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">r0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">c0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> allCellsDistOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">R, C, r0, c0</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getDistance = <span class="hljs-function">(<span class="hljs-params">point</span>) =&gt;</span><br>    <span class="hljs-built_in">Math</span>.abs(r0 - point[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">Math</span>.abs(c0 - point[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; R; x++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; C; y++) &#123;<br>      <span class="hljs-keyword">const</span> distance = getDistance([x, y]);<br>      <span class="hljs-keyword">if</span> (map[distance]) map[distance].push([x, y]);<br>      <span class="hljs-keyword">else</span> map[distance] = [[x, y]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(map).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.concat(b), []);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">R</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">C</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">r0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">c0</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> allCellsDistOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">R, C, r0, c0</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> visited = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(R)).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(C).fill(<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">const</span> queue = [[r0, c0]];<br>  visited[r0][c0] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> point = queue.shift();<br>    <span class="hljs-keyword">const</span> x = point[<span class="hljs-number">0</span>],<br>      y = point[<span class="hljs-number">1</span>];<br>    res.push(point);<br>    <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[x - <span class="hljs-number">1</span>][y]) &#123;<br>      queue.push([x - <span class="hljs-number">1</span>, y]);<br>      visited[x - <span class="hljs-number">1</span>][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[x][y - <span class="hljs-number">1</span>]) &#123;<br>      queue.push([x, y - <span class="hljs-number">1</span>]);<br>      visited[x][y - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; R &amp;&amp; !visited[x + <span class="hljs-number">1</span>][y]) &#123;<br>      queue.push([x + <span class="hljs-number">1</span>, y]);<br>      visited[x + <span class="hljs-number">1</span>][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; C &amp;&amp; !visited[x][y + <span class="hljs-number">1</span>]) &#123;<br>      queue.push([x, y + <span class="hljs-number">1</span>]);<br>      visited[x][y + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>桶排序</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月18日</title>
    <link href="/2020/11/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8818%E6%97%A5/"/>
    <url>/2020/11/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt134. 加油站,贪心算法</p><span id="more"></span><h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a></h1><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code>_ <em>升。<br>你有一辆油箱容量无限的的汽车，从第</em> i <em>个加油站开往第</em> i+1 <em>个加油站需要消耗汽油 <code>cost[i]</code></em> _升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br><strong>说明:</strong></p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例  1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:<br>gas  = [2,3,4]<br>cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><p>很容易可以想到一种方法，遍历每一个加油站，开始尝试行驶一圈，看获取和消耗的油量能达到的达到的加油站数量，如果等于加油站数量，说明可以行驶一圈。</p><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p>可以得出这么一个结论，<code>如果所有站点得到的油大于等于消耗的油，则一定存在一个起点可以行驶一圈</code>。<br>所以使用一个 sum 进行计数，最后判断是否小于 0，是的话返回-1，不存在一个点可以行驶一圈。<br>在一次遍历的过程中，使用 run 来记录当前油量，如果油量小于 0，说明要从当前点到下一个点需要耗费的油量太多了，之前 0-k 个点得到油不够消耗。说明从 0-k 中再取其他的点，一样不够使用。所以要从 k+1 开始，继续判断。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力遍历-1"><a href="#暴力遍历-1" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">gas</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">cost</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gas, cost</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> remainGas = gas[i];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (remainGas &gt; <span class="hljs-number">0</span> &amp;&amp; count &lt; gas.length) &#123;<br>      <span class="hljs-keyword">const</span> costIndex = (i + count) % gas.length;<br>      <span class="hljs-keyword">const</span> gasIndex = (i + count + <span class="hljs-number">1</span>) % gas.length;<br>      remainGas -= cost[costIndex];<br>      <span class="hljs-keyword">if</span> (remainGas &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>      count++;<br>      remainGas += gas[gasIndex];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count === gas.length) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="一次遍历-1"><a href="#一次遍历-1" class="headerlink" title="一次遍历"></a>一次遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">gas</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">cost</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gas, cost</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>,<br>    start = <span class="hljs-number">0</span>,<br>    run = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; gas.length; index++) &#123;<br>    sum += gas[index] - cost[index];<br>    run += gas[index] - cost[index];<br>    <span class="hljs-keyword">if</span> (run &lt; <span class="hljs-number">0</span>) &#123;<br>      start = index + <span class="hljs-number">1</span>;<br>      run = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : start;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月16日</title>
    <link href="/2020/11/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8816%E6%97%A5/"/>
    <url>/2020/11/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt406. 根据身高重建队列</p><span id="more"></span><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中<code>h</code>是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。<br><strong>注意：</strong><br>总人数少于 1100 人。<br><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>, <span class="hljs-comment">[4,4]</span>, <span class="hljs-comment">[7,1]</span>, <span class="hljs-comment">[5,0]</span>, <span class="hljs-comment">[6,1]</span>, <span class="hljs-comment">[5,2]</span>]</span><br>输出:<br><span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>, <span class="hljs-comment">[7,0]</span>, <span class="hljs-comment">[5,2]</span>, <span class="hljs-comment">[6,1]</span>, <span class="hljs-comment">[4,4]</span>, <span class="hljs-comment">[7,1]</span>]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关键是发现以下规律：<code>对已排好的高身高中插入矮身高得到的结果仍然是符合要求的</code><br>所以先执行排序，则可以保证之后遍历插入顺序符合先插高个子再插矮个子的要求：<code>按身高降序，相同升高按人数升序</code>。<br>排序后，k 是排在 h 前面且身高大于或等于 h 的人数 ，因为先插入了高个子。此时结果数组中所有人身高都大于等于当前人的身高，所以<code>k即为需要插入的位置的下标</code>。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">people</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reconstructQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">people</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  people.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a[<span class="hljs-number">0</span>] === b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] : b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]));<br>  people.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> res.splice(item[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, item));<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月15日</title>
    <link href="/2020/11/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8815%E6%97%A5/"/>
    <url>/2020/11/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt402. 移掉 K 位数字，单调栈</p><span id="more"></span><h1 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉 K 位数字</a></h1><p>给定一个以字符串表示的非负整数 _num_，移除这个数中的 <em>k *位数字，使得剩下的数字最小。<br>*</em>注意:**</p><ul><li><em>num</em> 的长度小于 10002 且  ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><p><strong>示例 1 :</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">num</span> = <span class="hljs-string">&quot;1432219&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">&quot;1219&quot;</span><br>解释: 移除掉三个数字 <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, 和 <span class="hljs-number">2</span> 形成一个新的最小的数字 <span class="hljs-number">1219</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">num</span> = <span class="hljs-string">&quot;10200&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">&quot;200&quot;</span><br>解释: 移掉首位的 <span class="hljs-number">1</span> 剩下的数字为 <span class="hljs-number">200</span>. 注意输出不能有任何前导零。<br></code></pre></td></tr></table></figure><p>示例** 3 :**</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">num</span> = <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出: <span class="hljs-string">&quot;0&quot;</span><br>解释: 从原数字移除所有的数字，剩余为空就是<span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>在完成删除数量前，要保证当前栈是一个单调增的栈。</code><br>转自：<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/wei-tu-jie-dan-diao-zhan-dai-ma-jing-jian-402-yi-d/">https://leetcode-cn.com/problems/remove-k-digits/solution/wei-tu-jie-dan-diao-zhan-dai-ma-jing-jian-402-yi-d/</a></p><ul><li>从左遍历，还不知道当前的数要不要删，先入栈暂存，保留对它的记忆</li><li>123531 这样<code>「高位递增」</code>的数，要删也删低位，不会考虑删高位的。</li><li>432135 这样<code>「高位递减」</code>的数，肯定想干掉高位，尽量变成「高位递增」</li><li>所以，如果当前数比栈顶更大，就还是递增态，是满意的，入栈。</li><li>如果当前数比栈顶更小，要删栈顶的数，为什么？也许后面还有更大的呢？<ul><li>因为栈顶的数在高位，删掉它，后面小的数顶上，高位变小比起低位变小，减小幅度更大。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-number">1432219</span>&quot;  <span class="hljs-number">3</span><br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1        ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">1</span>入（没有左侧相邻元素，无法丢弃）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 4      ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">4</span>入（<span class="hljs-number">4</span> 比左侧相邻的 <span class="hljs-number">1</span> 大。丢弃<span class="hljs-number">1</span>，那么会使数字更大。不丢弃。）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 3      ]</span><span class="hljs-attribute">top</span><span class="hljs-number">4</span>出<span class="hljs-number">3</span>入（<span class="hljs-number">3</span> 比左侧相邻的 <span class="hljs-number">4</span> 小。丢弃<span class="hljs-number">4</span>，那么会使数字更小。丢弃。）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 2      ]</span><span class="hljs-attribute">top</span><span class="hljs-number">3</span>出<span class="hljs-number">2</span>入（<span class="hljs-number">2</span> 比左侧相邻的 <span class="hljs-number">3</span> 小。丢弃<span class="hljs-number">3</span>，那么会使数字更小。丢弃。）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 2 2    ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">2</span>入  （<span class="hljs-number">2</span> 于左侧相邻的 <span class="hljs-number">2</span> 一样大。不丢弃。）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 2 1    ]</span><span class="hljs-attribute">top</span><span class="hljs-number">2</span>出<span class="hljs-number">1</span>入 （<span class="hljs-number">1</span> 比左侧相邻的 <span class="hljs-number">2</span> 小。丢弃<span class="hljs-number">2</span>，那么会使数字更小。丢弃。出栈满<span class="hljs-number">3</span>个，停止出栈。）<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[1 2 1 9  ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">9</span>入<br>照这么做，如果是 &quot;<span class="hljs-number">0432219</span>&quot;，如下，循环结束后，还得处理栈中的前导&quot;<span class="hljs-number">0</span>&quot;。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-number">0432219</span>&quot;  <span class="hljs-number">3</span><br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0        ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">0</span>入<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 4      ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">4</span>入<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 3      ]</span><span class="hljs-attribute">top</span><span class="hljs-number">4</span>出<span class="hljs-number">3</span>入<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 2      ]</span><span class="hljs-attribute">top</span><span class="hljs-number">3</span>出<span class="hljs-number">2</span>入<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 2 2    ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">2</span>入<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 2 1    ]</span><span class="hljs-attribute">top</span><span class="hljs-number">2</span>出<span class="hljs-number">1</span>入  出栈满<span class="hljs-number">3</span>个，停止出栈<br><span class="hljs-attribute">bottom</span><span class="hljs-selector-attr">[0 2 1 9  ]</span><span class="hljs-attribute">top</span>  <span class="hljs-number">9</span>入<br></code></pre></td></tr></table></figure><p>能不能限制不让前导 0 入栈？<br>加一个判断：栈为空且当前字符为 “0” 时，不入栈。取反，就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (number !== <span class="hljs-string">&quot;0&quot;</span> || stack.length &gt; <span class="hljs-number">0</span>) stack.push(number);<br></code></pre></td></tr></table></figure><p>遍历结束后，如果还没删够 k 个字符，开一个循环从栈中删栈顶。<br>如果栈变空了，返回 “0”，否则将栈中的字符转成字符串返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeKdigits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num, k</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num.length &lt;= k) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> number <span class="hljs-keyword">of</span> num) &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; stack.length &gt; <span class="hljs-number">0</span> &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>] &gt; number) &#123;<br>      stack.pop();<br>      k--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (number !== <span class="hljs-string">&quot;0&quot;</span> || stack.length &gt; <span class="hljs-number">0</span>) stack.push(number);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>    stack.pop();<br>    k--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> stack.length ? stack.join(<span class="hljs-string">&quot;&quot;</span>) : <span class="hljs-string">&quot;0&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>贪心算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现重试函数</title>
    <link href="/2020/11/14/yuque/%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%AF%95%E5%87%BD%E6%95%B0/"/>
    <url>/2020/11/14/yuque/%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%AF%95%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>实现重试函数，Promiseify</p><span id="more"></span><p>实现一个方法 useRetryable，当调用 retryableFn 时，它的调用方式要与原始函数（即 fn）保持一致。<br>同时还具备重试功能:</p><ol><li>如果 n 次内执行失败，进行重试;</li><li>一旦执行成功,就不再执行多余的次数了;</li><li>如果 n 次全部失败，抛出最后一次的异常。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实现一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useRetryable</span>(<span class="hljs-params">fn, time</span>) </span>&#123;&#125;<br><br><span class="hljs-keyword">const</span> retryableFn = useRetryable(fn, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *当调用retryableFn时，它的调用方式要与原始函数（即fn）保持一致。同时还具备重试功能:</span><br><span class="hljs-comment"> *1、如果n次内执行失败，进行重试;</span><br><span class="hljs-comment"> *2、一旦执行成功,就不再执行多余的次数了;</span><br><span class="hljs-comment"> *3、如果n次全部失败，抛出最后一次的异常。</span><br><span class="hljs-comment"> */</span><br><br>retryableFn();<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 Promiseify 的思想，返回一个 Promise，同时处理同步和异步方法：</p><ol><li>使用 try-catch 捕捉同步方法的错误。</li><li>使用 res 存储执行方法的 return 值，判断是否属于 Promise。<ol><li>是异步的方法，无法使用 try-catch 捕捉，使用 Promise 的 catch 进行错误处理</li></ol></li><li>两个错误处理中，判断当 time 是否大于 1，是的话继续返回 useRetryable 并立即执行，不是的话抛出错误。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实现一个方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useRetryable</span>(<span class="hljs-params">fn, time</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> res = fn.apply(globalThis, args);<br>        <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>          res.catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">1</span>) useRetryable(fn, --time)(...args);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(err);<br>          &#125;);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">1</span>) useRetryable(fn, --time)(...args);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(err);<br>      &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> asyncfn = <span class="hljs-keyword">async</span> (...args) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">console</span>.log(num);<br>  <span class="hljs-comment">// 模拟错误，小于3才成功</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(args);<br>      resolve(num);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      reject(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> syncfn = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span>);<br>  <span class="hljs-comment">// 模拟错误，小于3才成功</span><br>  <span class="hljs-built_in">console</span>.log(num);<br>  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(args);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> retryableFnAsync = useRetryable(asyncfn, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> retryableFnSync = useRetryable(syncfn, <span class="hljs-number">3</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *当调用retryableFn时，它的调用方式要与原始函数（即fn）保持一致。同时还具备重试功能:</span><br><span class="hljs-comment"> *1、如果n次内执行失败，进行重试;</span><br><span class="hljs-comment"> *2、一旦执行成功,就不再执行多余的次数了;</span><br><span class="hljs-comment"> *3、如果n次全部失败，抛出最后一次的异常。</span><br><span class="hljs-comment"> */</span><br>retryableFnAsync(<span class="hljs-number">222</span>, <span class="hljs-number">333</span>, <span class="hljs-number">444</span>);<br>retryableFnSync(<span class="hljs-number">222</span>, <span class="hljs-number">333</span>, <span class="hljs-number">444</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>工具</tag>
      
      <tag>函数</tag>
      
      <tag>异步</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月14日</title>
    <link href="/2020/11/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8814%E6%97%A5/"/>
    <url>/2020/11/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1122. 数组的相对排序</p><span id="more"></span><h1 id="1122-数组的相对排序"><a href="#1122-数组的相对排序" class="headerlink" title="1122. 数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></h1><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。<br><strong>示例：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr1 = [<span class="hljs-number">2,3,1,3</span>,<span class="hljs-number">2,4,6,7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">19</span>], arr2 = [<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">2,2,2,1</span>,<span class="hljs-number">4,3,3,9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>arr1.length, arr2.length &lt;= 1000</code></li><li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li><li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li><li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="遍历两次-额外空间存储数组"><a href="#遍历两次-额外空间存储数组" class="headerlink" title="遍历两次+额外空间存储数组"></a>遍历两次+额外空间存储数组</h4><p>遍历 arr2，统计 arr1 中出现的数量加入结果数组中，并删除 arr1 中对应的元素。返回结果数组和剩余按升序排列过的 arr1 数组。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>还是遍历两次，第二次遍历的是 arr1 排序后的数组。遍历后根据 map 的 key 和 value 生成新数组放回。</p><h4 id="改造-sort-函数"><a href="#改造-sort-函数" class="headerlink" title="改造 sort 函数"></a>改造 sort 函数</h4><p>如果 x 和 y 都不在 arr2 中，则返回 x-y，则是未出现的元素在数组最后升序排列的判断过程。<br>如果 x 在 y 中有一个不在 arr2 中，则直接返回大于等 0 的数，不改变顺序即可。<br>如果 x 和 y 都在 arr2 中吗，则返回 arr2.indexOf(x) - arr2.indexOf(y)，根据 arr2 中的顺序排序。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="遍历两次-额外空间存储数组-1"><a href="#遍历两次-额外空间存储数组-1" class="headerlink" title="遍历两次+额外空间存储数组"></a>遍历两次+额外空间存储数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> relativeSortArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> arr2) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr1[i] === arr) &#123;<br>        res.push(arr);<br>        arr1.splice(i, <span class="hljs-number">1</span>);<br>        i--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.concat(arr1.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> relativeSortArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> arr2) map.set(arr, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> arr1.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b))<br>    map.set(arr, map.has(arr) ? map.get(arr) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [...map.entries()].reduce(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.concat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(b[<span class="hljs-number">1</span>]).fill(b[<span class="hljs-number">0</span>])),<br>    []<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改造-sort-函数-1"><a href="#改造-sort-函数-1" class="headerlink" title="改造 sort 函数"></a>改造 sort 函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> relativeSortArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr1.sort(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr2.indexOf(x) === -<span class="hljs-number">1</span> &amp;&amp; arr2.indexOf(y) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x - y;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr2.indexOf(x) === -<span class="hljs-number">1</span> || arr2.indexOf(y) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> arr2.indexOf(x) - arr2.indexOf(y);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月13日</title>
    <link href="/2020/11/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8813%E6%97%A5/"/>
    <url>/2020/11/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt328. 奇偶链表</p><span id="more"></span><h1 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h1><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;NULL<br>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="额外数组-遍历两次"><a href="#额外数组-遍历两次" class="headerlink" title="额外数组+遍历两次"></a>额外数组+遍历两次</h4><p>空间复杂度 O(N)，时间复杂度 O(2*nodes)。<br>遍历一次，存储奇数偶数节点的值到奇数偶数数组中。再遍历一次，修改链表节点的值。</p><h4 id="遍历一次-无额外空间"><a href="#遍历一次-无额外空间" class="headerlink" title="遍历一次+无额外空间"></a>遍历一次+无额外空间</h4><p>设置一个 o 指向奇数节点，e 指向偶数节点，temp 指向第一个偶数节点用于记录第偶数节点链表。遍历一次链表：</p><ol><li>先将奇数节点的 next 指向偶数节点的 next 即下一个奇数节点，就将两个奇数节点连接到了一起，再令 o 指向 o.next。</li><li>然后将 e 的 next 指向 o 的 next，即将该节点连接上了第二个偶数节点，再令 e 指向 e.next。</li></ol><p>循环以上过程，遍历完成以后，分别形成了奇数和偶数的两条链表。将奇数节点链表的最后一个指向 temp，即连接上奇数和偶数链表。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="额外数组-遍历两次-1"><a href="#额外数组-遍历两次-1" class="headerlink" title="额外数组+遍历两次"></a>额外数组+遍历两次</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> oddEvenList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = head,<br>    count = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> oArr = [],<br>    eArr = [];<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      eArr.push(p.val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      oArr.push(p.val);<br>    &#125;<br>    count++;<br>    p = p.next;<br>  &#125;<br>  p = head;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (oArr.length) &#123;<br>      p.val = oArr.shift();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      p.val = eArr.shift();<br>    &#125;<br>    p = p.next;<br>    count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="遍历一次-无额外空间-1"><a href="#遍历一次-无额外空间-1" class="headerlink" title="遍历一次+无额外空间"></a>遍历一次+无额外空间</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> oddEvenList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;<br>  <span class="hljs-keyword">let</span> o = head,<br>    e = o.next,<br>    temp = e;<br>  <span class="hljs-keyword">while</span> (o &amp;&amp; o.next &amp;&amp; e &amp;&amp; e.next) &#123;<br>    o.next = e.next;<br>    o = o.next;<br>    e.next = o.next;<br>    e = e.next;<br>  &#125;<br>  o.next = temp;<br>  <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月12日</title>
    <link href="/2020/11/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8812%E6%97%A5/"/>
    <url>/2020/11/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt922. 按奇偶排序数组 II</p><span id="more"></span><h1 id="922-按奇偶排序数组-II"><a href="#922-按奇偶排序数组-II" class="headerlink" title="922. 按奇偶排序数组 II"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></h1><p>给定一个非负整数数组 <code>A</code>， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。<br>你可以返回任何满足上述条件的数组作为答案。<br><strong>示例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[4,2,5,7]</span><br>输出：<span class="hljs-selector-attr">[4,5,2,7]</span><br>解释：<span class="hljs-selector-attr">[4,7,2,5]</span>，<span class="hljs-selector-attr">[2,5,4,7]</span>，<span class="hljs-selector-attr">[2,7,4,5]</span> 也会被接受。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 20000</code></li><li><code>A.length % 2 == 0</code></li><li><code>0 &lt;= A[i] &lt;= 1000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="额外双数组"><a href="#额外双数组" class="headerlink" title="额外双数组"></a>额外双数组</h4><p>把原数组奇数偶数分别提取出来，再按偶数奇数的顺序添加回去。</p><h4 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h4><p>遍历一次数组，判断当前位置的元素是否符合要求。例如判断当前是否下标和数都为偶数，不符合就去之后元素中找一个，数为偶数，但是下标为奇数的数，将两个元素交换。</p><h4 id="单数组"><a href="#单数组" class="headerlink" title="单数组"></a>单数组</h4><p>使用单结果数组，分别使用奇数下标和偶数下标记录元素应该放置的位置，每次放置以后都令下标加 2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="额外双数组-1"><a href="#额外双数组-1" class="headerlink" title="额外双数组"></a>额外双数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> oddArr = A.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> evenArr = A.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (oddArr.length) &#123;<br>    res.push(evenArr.pop());<br>    res.push(oddArr.pop());<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="原地修改-1"><a href="#原地修改-1" class="headerlink" title="原地修改"></a>原地修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (A[i] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; A.length) &#123;<br>          <span class="hljs-keyword">if</span> (A[j] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>            [A[i], A[j]] = [A[j], A[i]];<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          j += <span class="hljs-number">2</span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (A[i] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; A.length) &#123;<br>          <span class="hljs-keyword">if</span> (A[j] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;<br>            [A[i], A[j]] = [A[j], A[i]];<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          j += <span class="hljs-number">2</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> A;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单数组-1"><a href="#单数组-1" class="headerlink" title="单数组"></a>单数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> eIndex = <span class="hljs-number">0</span>,<br>    oIndex = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> A) &#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      res[eIndex] = num;<br>      eIndex += <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res[oIndex] = num;<br>      oIndex += <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月11日</title>
    <link href="/2020/11/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8811%E6%97%A5/"/>
    <url>/2020/11/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>L34. 在排序数组中查找元素的第一个和最后一个位置</p><span id="more"></span><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。<br>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。<br><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出: <span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出: <span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分搜索，首先用二分法查出第一个和 target 相等的元素的下标。如果 index 仍然等于-1 则不存在该元素，返回[-1,-1]。<br>分别从该元素的左边和右边查到开始和结尾，看 target 元素出现的第一次和最后一次。有以下逻辑：<br>第一次二分查找左半边，查找第一个 target 元素，设置左右指针分别为 l 和 index。</p><ol><li>如果最左边的元素即 l 指向的元素就为 target，将 first 设为 l</li><li>计算 middle，如果 middle 等于 target，令 r–，继续判断右边下一个是否和 target 相等</li><li>如果 middle 指向的数小于目标值，令 l=middle+1，继续二分查找</li></ol><p>第二次二分查找右半边，查最后一个 target 元素，逻辑类似。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = nums.length - <span class="hljs-number">1</span>,<br>    index = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">parseInt</span>((l + r) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      index = middle;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) l = middle + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> r = middle - <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> first = -<span class="hljs-number">1</span>,<br>    last = -<span class="hljs-number">1</span>;<br>  (l = <span class="hljs-number">0</span>), (r = index);<br>  <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">parseInt</span>((l + r) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-keyword">if</span> (l === <span class="hljs-number">0</span> &amp;&amp; nums[l] === target) &#123;<br>        first = l;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middle &gt; <span class="hljs-number">0</span> &amp;&amp; nums[middle - <span class="hljs-number">1</span>] !== target) &#123;<br>        first = middle;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      r--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) l = middle + <span class="hljs-number">1</span>;<br>  &#125;<br>  (l = index), (r = nums.length - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">parseInt</span>((l + r) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] === target) &#123;<br>      <span class="hljs-keyword">if</span> (r === nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[r] === target) &#123;<br>        last = r;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middle &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[middle + <span class="hljs-number">1</span>] !== target) &#123;<br>        last = middle;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      l++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &gt; target) r = middle - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [first, last];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月10日</title>
    <link href="/2020/11/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8810%E6%97%A5/"/>
    <url>/2020/11/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt31. 下一个排列、字典排序</p><span id="more"></span><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**修改，只允许使用额外常数空间。<br>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先从倒数第二个元素开始遍历，找到第一个比右边数小的那个数 a（如果该数比右边的大，说明右边元素降序排序，无论如何交换，得到的数一定都比原来的小）。<br>再从最后一个元素开始找到第一个比 a 大的数，交换，使数变大。<br>交换之后右边的元素仍然是降序排序，所以将其反序可以使数变得更小一些。<br>如果 i==-1，即本身数组就是降序的，直接进行反序即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextPermutation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i = nums.length - <span class="hljs-number">2</span>,<br>    j = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) i--;<br>  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) j--;<br>    [nums[i], nums[j]] = [nums[j], nums[i]];<br>  &#125;<br>  <span class="hljs-keyword">let</span> l = i + <span class="hljs-number">1</span>,<br>    r = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    [nums[l], nums[r]] = [nums[r], nums[l]];<br>    l++;<br>    r--;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月9日</title>
    <link href="/2020/11/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%889%E6%97%A5/"/>
    <url>/2020/11/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt973. 最接近原点的 K 个点</p><span id="more"></span><h1 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h1><p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。<br>（这里，平面上两点之间的距离是欧几里德距离。）<br>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。<br> <strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,3],[-2,2]]</span>, K = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[-2,2]]</span><br>解释：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，<br>(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>)，<br>由于 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>) &lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 离原点更近。<br>我们只需要距离原点最近的 K = <span class="hljs-number">1</span> 个点，所以答案就是 <span class="hljs-string">[[-2,2]]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[3,3],[5,-1],[-2,4]]</span>, K = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[[3,3],[-2,4]]</span><br>（答案 <span class="hljs-string">[[-2,4],[3,3]]</span> 也会被接受。）<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code>-10000 &lt; points[i][0] &lt; 10000</code></li><li><code>-10000 &lt; points[i][1] &lt; 10000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>把数组按照据原点距离升序排序，取前 K 个元素即可</p><h4 id="模拟快排"><a href="#模拟快排" class="headerlink" title="模拟快排"></a>模拟快排</h4><p>模拟快排，快排有一个性质，一次快排确定的点，左边的数组一定比当前的点小。所以：<br><strong>当当前点为 K 即左边有 K 个元素时</strong>，题目所需要的解就已经求出来了，不需要继续进行排序。<br>当当前点比 K 大，说明左边元素大于 K 个，需要对左边继续进行排序。当当前点比 K 小，说明左边元素小于 K 个，需要对右边继续进行排序。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">points</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">K</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kClosest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">points, K</span>) </span>&#123;<br>  points.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + a[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span> - (b[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + b[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">return</span> points.splice(<span class="hljs-number">0</span>, K);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="模拟快排-1"><a href="#模拟快排-1" class="headerlink" title="模拟快排"></a>模拟快排</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">points</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">K</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kClosest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">points, K</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> getValue = <span class="hljs-function">(<span class="hljs-params">point</span>) =&gt;</span> point[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + point[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> quickSort = <span class="hljs-function">(<span class="hljs-params">start, end</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> left = start,<br>      right = end;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; getValue(points[right]) &gt;= getValue(points[start]))<br>        right--;<br>      <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; getValue(points[left]) &lt;= getValue(points[start]))<br>        left++;<br>      [points[left], points[right]] = [points[right], points[left]];<br>    &#125;<br>    [points[start], points[left]] = [points[left], points[start]];<br>    <span class="hljs-comment">// console.log(left)</span><br>    <span class="hljs-keyword">if</span> (left === K) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &lt; K) &#123;<br>      quickSort(left + <span class="hljs-number">1</span>, end);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      quickSort(start, left - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;;<br>  quickSort(<span class="hljs-number">0</span>, points.length - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> points.slice(<span class="hljs-number">0</span>, K);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月8日</title>
    <link href="/2020/11/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%888%E6%97%A5/"/>
    <url>/2020/11/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt122. 买卖股票的最佳时机 II、Lt144. 二叉树的前序遍历、Lt145. 二叉树的后序遍历</p><span id="more"></span><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例  3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>未限制购买次数，实际上只要当前的价格比前一天高就可以卖出。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)<br>    <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) sum += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>难度中等 446 收藏分享切换为英文接收动态反馈<br>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong>_ _遍历。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604826018065-a4c2d406-aa7d-44ad-b016-303f416b4477.jpeg#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604826018536-8fbce835-fe53-4aef-b2d1-6b89dd4f2508.jpeg#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604826017536-e26b1472-8835-4cbb-a6a5-059256f988c2.jpeg#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>二叉树普通递归即可</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>可以通过栈来模拟，要注意的先序遍历先访问左节点再访问右节点，所以入栈的时候应该先加入右节点，再加入左节点</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    res.push(node.val);<br>    traverse(node.left);<br>    traverse(node.right);<br>  &#125;;<br>  traverse(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> node = queue.shift();<br>    res.push(node.val);<br>    <span class="hljs-keyword">if</span> (node.right) queue.unshift(node.right);<br>    <span class="hljs-keyword">if</span> (node.left) queue.unshift(node.left);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h1><p>给定一个二叉树，返回它的 <em>后序  *遍历。<br>*</em>示例:**</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span><br>   1<br>    \<br>     2<br>    /<br>   3<br>输出: <span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><p>二叉树遍历常规递归即可</p><h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><p>设置一个 prev 用于记录上一个遍历完毕的节点。先将左子树都加入栈中，直到节点的左子树为空。出栈一个元素，<strong>判断其是否无右子树和是否为上一个遍历的节点</strong>，如果是的话，说明为叶子节点或左右子树都已经全部遍历完毕的节点，可以将当前节点的值加入结果数组了，加入后，将 prev 指向当前节点避免重复遍历右子树。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    traverse(node.left);<br>    traverse(node.right);<br>    res.push(node.val);<br>  &#125;;<br>  traverse(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (root || stack.length) &#123;<br>    <span class="hljs-keyword">while</span> (root) &#123;<br>      stack.push(root);<br>      root = root.left;<br>    &#125;<br>    <span class="hljs-keyword">const</span> node = stack.pop();<br>    <span class="hljs-keyword">if</span> (!node.right || node.right === prev) &#123;<br>      res.push(node.val);<br>      prev = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      stack.push(node);<br>      root = node.right;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>动态规划</tag>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月7日-二叉树两题</title>
    <link href="/2020/11/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%887%E6%97%A5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E9%A2%98/"/>
    <url>/2020/11/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%887%E6%97%A5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Lt102. 二叉树的层序遍历、Lt94. 二叉树的中序遍历</p><span id="more"></span><h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>复习，使用队列的 BFS</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> temp = queue.splice(<span class="hljs-number">0</span>, queue.length);<br>    <span class="hljs-keyword">const</span> val = [];<br>    <span class="hljs-keyword">while</span> (temp.length) &#123;<br>      <span class="hljs-keyword">const</span> node = temp.shift();<br>      val.push(node.val);<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>    res.push(val);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。<br> <strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604740041586-fb3f0114-24bb-469a-9c62-f55bb16982cc.jpeg#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604740041529-c9846867-e433-430d-ad9a-35ecc529934d.jpeg#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1604740041605-d3e2464c-04ec-407b-8ae7-bfbac75c923b.jpeg#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=202&size=0&status=done&style=none&width=202"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>常规递归即可</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>将指向 root 节点的所有左子树加入栈中，直到指针指向的节点左子树为 null。将栈中栈顶元素出栈，将对应的值加入结果数组，将 root 指向该元素的右子树，继续以上将左子树加入栈中的过程。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    traverse(root.left);<br>    res.push(root.val);<br>    traverse(root.right);<br>  &#125;;<br>  traverse(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> stack = [];<br><br>  <span class="hljs-keyword">while</span> (root || stack.length) &#123;<br>    <span class="hljs-keyword">if</span> (root) &#123;<br>      stack.push(root);<br>      root = root.left;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> node = stack.pop();<br>      res.push(node.val);<br>      root = node.right;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>队列</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月6日</title>
    <link href="/2020/11/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%886%E6%97%A5/"/>
    <url>/2020/11/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1356. 根据数字二进制下 1 的数目排序</p><span id="more"></span><h1 id="1356-根据数字二进制下-1-的数目排序"><a href="#1356-根据数字二进制下-1-的数目排序" class="headerlink" title="1356. 根据数字二进制下 1 的数目排序"></a><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">1356. 根据数字二进制下 1 的数目排序</a></h1><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。<br>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。<br>请你返回排序后的数组。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [0,1,2,3,4,5,6,7,8]<br>输出：[0,1,2,4,8,3,5,6,7]<br>解释：[0] 是唯一一个有<span class="hljs-number"> 0 </span>个<span class="hljs-number"> 1 </span>的数。<br>[1,2,4,8] 都有<span class="hljs-number"> 1 </span>个<span class="hljs-number"> 1 </span>。<br>[3,5,6] 有<span class="hljs-number"> 2 </span>个<span class="hljs-number"> 1 </span>。<br>[7] 有<span class="hljs-number"> 3 </span>个<span class="hljs-number"> 1 </span>。<br>按照<span class="hljs-number"> 1 </span>的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1024,512</span>,<span class="hljs-number">256,128,64</span>,<span class="hljs-number">32,16,8,4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1,2,4,8</span>,<span class="hljs-number">16,32,64,128</span>,<span class="hljs-number">256,512</span>,<span class="hljs-number">1024</span>]<br>解释：数组中所有整数二进制下都只有 <span class="hljs-number">1</span> 个 <span class="hljs-number">1</span> ，所以你需要按照数值大小将它们<br></code></pre></td></tr></table></figure><p>排序。<br><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[10000,10000]</span><br>输出：<span class="hljs-string">[10000,10000]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">2,3,5,7</span>,<span class="hljs-number">11,13,17,19</span>]<br>输出：[<span class="hljs-number">2,3,5,17</span>,<span class="hljs-number">7,11,13,19</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[10,100,1000,10000]</span><br>输出：<span class="hljs-string">[10,100,10000,1000]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="转二进制字符串-暴力-哈希"><a href="#转二进制字符串-暴力-哈希" class="headerlink" title="转二进制字符串+暴力+哈希"></a>转二进制字符串+暴力+哈希</h4><p>建立一个哈希表，计算每个字符串二进制的 1 的数量加入对应哈希表的数组中。哈希表转数组：先按 1 的长度升序，再将数组内的数组排序，扁平化组成结果数组返回。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>一行实现，通过 sort，先比较 1 的数量，如果相同再比较数值大小</p><h4 id="位运算计数方法优化"><a href="#位运算计数方法优化" class="headerlink" title="位运算计数方法优化"></a>位运算计数方法优化</h4><p>使用<code>num &amp;= (num-1)</code>代替 toString 转 2 进制再计数。过程如下例：<br>34520    ·1000011011011000<br>34519     1000011011010111<br>结果         1000011011010000<br><strong>可以看到，每进行一次，结果都会少一个 1</strong></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="转二进制字符串-暴力-哈希-1"><a href="#转二进制字符串-暴力-哈希-1" class="headerlink" title="转二进制字符串+暴力+哈希"></a>转二进制字符串+暴力+哈希</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortByBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">const</span> length = char.toString(<span class="hljs-number">2</span>).replace(<span class="hljs-regexp">/0/g</span>, <span class="hljs-string">&quot;&quot;</span>).length;<br>    <span class="hljs-keyword">if</span> (map.has(length)) &#123;<br>      map.get(length).push(char);<br>    &#125; <span class="hljs-keyword">else</span> map.set(length, [char]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...map.entries()]<br>    .sort(<span class="hljs-function">(<span class="hljs-params">[a], [b]</span>) =&gt;</span> a - b)<br>    .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e[<span class="hljs-number">1</span>])<br>    .reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.concat(b.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)), []);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortByBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.sort(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span><br>      a.toString(<span class="hljs-number">2</span>).replace(<span class="hljs-regexp">/0/g</span>, <span class="hljs-string">&quot;&quot;</span>).length -<br>        b.toString(<span class="hljs-number">2</span>).replace(<span class="hljs-regexp">/0/g</span>, <span class="hljs-string">&quot;&quot;</span>).length || a - b<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="位运算计数方法优化-1"><a href="#位运算计数方法优化-1" class="headerlink" title="位运算计数方法优化"></a>位运算计数方法优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortByBits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> bitCount = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num !== <span class="hljs-number">0</span>) &#123;<br>      num &amp;= num - <span class="hljs-number">1</span>;<br>      count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> bitCount(a) - bitCount(b) || a - b);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月5日</title>
    <link href="/2020/11/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%885%E6%97%A5/"/>
    <url>/2020/11/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt78. 子集、回溯算法<br>Lt1641. 统计字典序元音字符串的数目<br>Lt1640. 能否连接形成数组</p><span id="more"></span><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h1><p>给定一组<strong>不含重复元素</strong>的整数数组 _nums_，返回该数组所有可能的子集（幂集）。<br><strong>说明：</strong>解集不能包含重复的子集。<br><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>相当于对数组每一个长度求一次组合，例如求数组内 0、1、2…个元素的组合。在组合的基础上，在外层再加上一个循环即可。</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>其实求组合的过程的回溯中，其实本来就包含了求数组内 0、1、2…个元素的组合的过程。每次递归时直接添加 temp 种的值到结果数组中即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">x, n, temp</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (temp.length === n) &#123;<br>      res.push(temp.slice());<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = x; i &lt; nums.length; i++) &#123;<br>      temp.push(nums[i]);<br>      combine(i + <span class="hljs-number">1</span>, n, temp);<br>      temp.pop();<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length; i++) combine(<span class="hljs-number">0</span>, i, []);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">x, temp</span>) =&gt;</span> &#123;<br>    res.push(temp.slice());<br>    <span class="hljs-keyword">if</span> (temp.length === nums.length) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = x; i &lt; nums.length; i++) &#123;<br>      temp.push(nums[i]);<br>      combine(i + <span class="hljs-number">1</span>, temp);<br>      temp.pop();<br>    &#125;<br>  &#125;;<br>  combine(<span class="hljs-number">0</span>, []);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1641-统计字典序元音字符串的数目"><a href="#1641-统计字典序元音字符串的数目" class="headerlink" title="1641. 统计字典序元音字符串的数目"></a><a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">1641. 统计字典序元音字符串的数目</a></h1><p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。<br>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。<br><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5</span><br>解释：仅由元音组成的 <span class="hljs-number">5</span> 个字典序字符串为 [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">15</span><br>解释：仅由元音组成的 <span class="hljs-number">15</span> 个字典序字符串为<br>[<span class="hljs-meta"><span class="hljs-meta-string">&quot;aa&quot;</span>,<span class="hljs-meta-string">&quot;ae&quot;</span>,<span class="hljs-meta-string">&quot;ai&quot;</span>,<span class="hljs-meta-string">&quot;ao&quot;</span>,<span class="hljs-meta-string">&quot;au&quot;</span>,<span class="hljs-meta-string">&quot;ee&quot;</span>,<span class="hljs-meta-string">&quot;ei&quot;</span>,<span class="hljs-meta-string">&quot;eo&quot;</span>,<span class="hljs-meta-string">&quot;eu&quot;</span>,<span class="hljs-meta-string">&quot;ii&quot;</span>,<span class="hljs-meta-string">&quot;io&quot;</span>,<span class="hljs-meta-string">&quot;iu&quot;</span>,<span class="hljs-meta-string">&quot;oo&quot;</span>,<span class="hljs-meta-string">&quot;ou&quot;</span>,<span class="hljs-meta-string">&quot;uu&quot;</span></span>]<br>注意，<span class="hljs-string">&quot;ea&quot;</span> 不是符合题意的字符串，因为 <span class="hljs-string">&#x27;e&#x27;</span> 在字母表中的位置比 <span class="hljs-string">&#x27;a&#x27;</span> 靠后<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">33</span><br>输出：<span class="hljs-number">66045</span><br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>常规回溯法，只需要计数量，所以只需要常数空间即可，注意组合字符串可以是本身，所以每次递归传入的 x 不需要加一。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> countVowelStrings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>];<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">x, temp</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (temp === n) &#123;<br>      res += <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = x; i &lt; map.length; i++) &#123;<br>      temp++;<br>      combine(i, temp);<br>      temp--;<br>    &#125;<br>  &#125;;<br>  combine(<span class="hljs-number">0</span>, []);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1640-能否连接形成数组"><a href="#1640-能否连接形成数组" class="headerlink" title="1640. 能否连接形成数组"></a><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">1640. 能否连接形成数组</a></h1><p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <strong>互不相同</strong> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。<br>如果可以连接_ _<code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br> <strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：arr = [<span class="hljs-number">85</span>], pieces = <span class="hljs-string">[[85]]</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[15,88]</span>, pieces = <span class="hljs-comment">[<span class="hljs-comment">[88]</span>,<span class="hljs-comment">[15]</span>]</span><br>输出：true<br>解释：依次连接 <span class="hljs-comment">[15]</span> 和 <span class="hljs-comment">[88]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：arr = [<span class="hljs-number">49</span>,<span class="hljs-number">18</span>,<span class="hljs-number">16</span>], pieces = <span class="hljs-string">[[16,18,49]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：即便数字相符，也不能重新排列 pieces[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[91,4,64,78]</span>, pieces = <span class="hljs-comment">[<span class="hljs-comment">[78]</span>,<span class="hljs-comment">[4,64]</span>,<span class="hljs-comment">[91]</span>]</span><br>输出：true<br>解释：依次连接 <span class="hljs-comment">[91]</span>、<span class="hljs-comment">[4,64]</span> 和 <span class="hljs-comment">[78]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>], pieces = <span class="hljs-string">[[2,4,6,8]]</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li><li><code>sum(pieces[i].length) == arr.length</code></li><li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li><li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li><li><code>arr</code> 中的整数 <strong>互不相同</strong></li><li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先生成一个只由第一个元素组成的数组。当元素组长度大于 0 时执行以下步骤：</p><ol><li>取第一个数为当前元素，判断只由第一个元素组成的数组里是否包含该数，不包含返回 false</li><li>截取对应 pieces 内的数组，取得长度，根据长度在元素组中截取相应长度的数组，再删除第一个元素组成的数组对应的元素，<code>即有三个数组的内容需要截取变化</code>。比较截取的原数组和截取的 pieces 数组是否完全相同，不是的话返回 false。</li></ol><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">pieces</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canFormArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr, pieces</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> firstNumArr = pieces.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">while</span> (arr.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> num = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (!firstNumArr.includes(num)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> pIndex = firstNumArr.indexOf(num);<br>    <span class="hljs-keyword">const</span> pieceLen = pieces[pIndex].length;<br>    <span class="hljs-keyword">const</span> arrTemp = arr.splice(<span class="hljs-number">0</span>, pieceLen);<br>    firstNumArr.splice(pIndex, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> pieceTemp = pieces.splice(pIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (<br>      arrTemp.length === pieceTemp.length &amp;&amp;<br>      !arrTemp.every(<span class="hljs-function">(<span class="hljs-params">num, index2</span>) =&gt;</span> num === pieceTemp[index2])<br>    )<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>回溯算法</tag>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月4日</title>
    <link href="/2020/11/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%884%E6%97%A5/"/>
    <url>/2020/11/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt57. 插入区间</p><span id="more"></span><h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/">57. 插入区间</a></h1><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><strong>示例  1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例  2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[12,16]</span>]</span>, newInterval = <span class="hljs-comment">[4,8]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[12,16]</span>]</span><br>解释：这是因为新的区间 <span class="hljs-comment">[4,8]</span> 与 <span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span> 重叠。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假 hard，先在尾部插入新区间，再按起始端点升序排序，再做区间合并即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">intervals</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">newInterval</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">intervals, newInterval</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> mergeInterval = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> min = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> max = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; max) &#123;<br>        res.push([min, max]);<br>        min = intervals[i][<span class="hljs-number">0</span>];<br>        max = intervals[i][<span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        max = <span class="hljs-built_in">Math</span>.max(max, intervals[i][<span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>    res.push([min, max]);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br><br>  intervals.push(newInterval);<br>  intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">Number</span>(b[<span class="hljs-number">0</span>]));<br>  intervals = mergeInterval();<br><br>  <span class="hljs-keyword">return</span> intervals;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扁平化对象转普通对象</title>
    <link href="/2020/11/03/yuque/%E6%89%81%E5%B9%B3%E5%8C%96%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/11/03/yuque/%E6%89%81%E5%B9%B3%E5%8C%96%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>扁平化对象转普通对象</p><span id="more"></span><p>实现一个函数，将扁平化对象转换为“嵌套”字典对象的功能。<br><strong>输入</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;A&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">&quot;B.A&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">&quot;B.B&quot;</span>: <span class="hljs-number">4</span>,<br><span class="hljs-attr">&quot;CC.D.E&quot;</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">&quot;CC.D.F&quot;</span>: <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;A&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">&quot;B&quot;</span>: &#123;<br><span class="hljs-attr">&quot;A&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">&quot;B&quot;</span>: <span class="hljs-number">4</span><br>&#125;,<br><span class="hljs-attr">&quot;CC&quot;</span>: &#123;<br><span class="hljs-attr">&quot;D&quot;</span>: &#123;<br><span class="hljs-attr">&quot;E&quot;</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">&quot;F&quot;</span>: <span class="hljs-number">5</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> formatObject = (obj: <span class="hljs-built_in">object</span>): <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> res = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(obj);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;<br>    <span class="hljs-keyword">if</span> ((&lt;<span class="hljs-built_in">string</span>&gt;key).includes(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> keyArr = (&lt;<span class="hljs-built_in">string</span>&gt;key).split(<span class="hljs-string">&quot;.&quot;</span>);<br>      keyArr.reduce((a: <span class="hljs-built_in">object</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (index === keyArr.length - <span class="hljs-number">1</span>) a[b] = obj[key];<br>        <span class="hljs-keyword">if</span> (!a[b]) a[b] = &#123;&#125;;<br>        <span class="hljs-keyword">return</span> a[b];<br>      &#125;, res);<br>    &#125; <span class="hljs-keyword">else</span> res[key] = obj[key];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br>formatObject(&#123;<br>  <span class="hljs-attr">A</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;B.A&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;B.B&quot;</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-string">&quot;CC.D.E&quot;</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-string">&quot;CC.D.F&quot;</span>: <span class="hljs-number">5</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>工具</tag>
      
      <tag>对象</tag>
      
      <tag>扁平化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月3日</title>
    <link href="/2020/11/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%883%E6%97%A5/"/>
    <url>/2020/11/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt941. 有效的山脉数组</p><span id="more"></span><h1 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941. 有效的山脉数组"></a><a href="https://leetcode-cn.com/problems/valid-mountain-array/">941. 有效的山脉数组</a></h1><p>难度简单 63<br>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。<br>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><code>A.length &gt;= 3</code></li><li>在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：<ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1604364312585-4d06ec30-ea1c-474a-a539-fb98c29d4996.png#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=892&size=0&status=done&style=none&width=500"></p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000 </code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="上坡下坡计数（状态记录）"><a href="#上坡下坡计数（状态记录）" class="headerlink" title="上坡下坡计数（状态记录）"></a>上坡下坡计数（状态记录）</h4><p>使用一个 count 记录上坡下坡状态，为 1 时则为上坡，为 2 时则为下坡：</p><ol><li>可能直接开始下坡，所以要先判断第一二个元素是否上坡。</li><li>遍历元素，当下一个元素小于当前元素时，count++，开始下坡。</li><li>如果下一个元素大于等于当前元素，说明出现上坡或平地，返回 false。</li><li>遍历后如果 count 不等于 2，说明没有出现下坡，返回 false。</li></ol><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>找到最高峰，判断是否是数组最后一位，是的话返回 false。<br>两侧开始往下判断是否都是下坡，不是的话返回 false。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="上坡下坡计数（状态记录）-1"><a href="#上坡下坡计数（状态记录）-1" class="headerlink" title="上坡下坡计数（状态记录）"></a>上坡下坡计数（状态记录）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> validMountainArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (A[<span class="hljs-number">0</span>] &lt; A[<span class="hljs-number">1</span>]) count++;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (A[i + <span class="hljs-number">1</span>] &lt; A[i]) count++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">if</span> (A[i + <span class="hljs-number">1</span>] &gt;= A[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> validMountainArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> maxIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)<br>    maxIndex = A[maxIndex] &gt; A[i] ? maxIndex : i;<br>  <span class="hljs-keyword">if</span> (maxIndex === <span class="hljs-number">0</span> || maxIndex === A.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> p = maxIndex;<br>  <span class="hljs-keyword">while</span> (p &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (A[p - <span class="hljs-number">1</span>] &gt;= A[p]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p--;<br>  &#125;<br>  p = maxIndex;<br>  <span class="hljs-keyword">while</span> (p &lt; A.length) &#123;<br>    <span class="hljs-keyword">if</span> (A[p + <span class="hljs-number">1</span>] &gt;= A[p]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月2日</title>
    <link href="/2020/11/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%882%E6%97%A5/"/>
    <url>/2020/11/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt349.两个数组的交集</p><span id="more"></span><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>给定两个数组，编写一个函数来计算它们的交集。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>新建两个 set 集合，遍历其中一个，判断每个元素在另外一个集合里是否有，有则加入结果数组</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>对两个有序数组进行求交集，可以先对原数组排序，然后使用双指针分别指向两个数组的头部，执行以下逻辑：</p><ol><li>如果两个数相等，加入结果数组，然后再跳过和当前数相同的所有数</li><li>如果 p 指向的 nums1 中的元素小于 q 指向的 nums2 中的元素，说明当前 p 指向的元素不存在，令 p++，判断下一个元素</li><li>如果 q 指向的 nums2 中的元素小于 p 指向的 nums1 中的元素，说明当前 q 指向的元素不存在，令 q++，判断下一个元素</li><li>当 p 或 q 遍历完其中一个数组时，循环结束，返回结果数组</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums1);<br>  <span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums2);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> set1) &#123;<br>    <span class="hljs-keyword">if</span> (set2.has(num)) res.push(num);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  nums1.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  nums2.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>,<br>    q = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p &lt; nums1.length &amp;&amp; q &lt; nums2.length) &#123;<br>    <span class="hljs-keyword">if</span> (nums1[p] === nums2[q]) &#123;<br>      res.push(nums1[p]);<br>      <span class="hljs-keyword">while</span> (p &lt; nums1.length - <span class="hljs-number">1</span> &amp;&amp; nums1[p + <span class="hljs-number">1</span>] === nums1[p]) p++;<br>      <span class="hljs-keyword">while</span> (q &lt; nums2.length - <span class="hljs-number">1</span> &amp;&amp; nums2[q + <span class="hljs-number">1</span>] === nums2[q]) q++;<br>      p++;<br>      q++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p] &lt; nums2[q]) &#123;<br>      p++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      q++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年11月1日</title>
    <link href="/2020/11/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%881%E6%97%A5/"/>
    <url>/2020/11/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B411%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt55.跳跃游戏、贪心算法</p><span id="more"></span><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。<br><strong>示例  1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳<span class="hljs-number"> 1 </span>步，从位置<span class="hljs-number"> 0 </span>到达 位置 1, 然后再从位置<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个位置。<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,0,4]</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="划片区间"><a href="#划片区间" class="headerlink" title="划片区间"></a>划片区间</h4><p>类似于主站 1024 题。进行以下步骤：<br>将跳的长度转化为区间例如[2,3,1,1,4]，转化为[[0,2],[1,4],[2,3],[3,4],[4,8]]。<br>进行区间合并，判断能否达到最后一个区间即可。<br>其实这种做法类似 24 题，应该是用来求最小跳跃次数的。题目没有要求，所以有更优化的贪心算法。</p><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>转自：<a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/">https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/</a></p><ol><li>如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。</li><li>可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。</li><li>如果可以一直跳到最后，就成功了。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="划片区间-1"><a href="#划片区间-1" class="headerlink" title="划片区间"></a>划片区间</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums = nums.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> [index, item + index]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i === nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> arrMin = nums[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> arrMax = nums[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp; i &lt;= arrMax &amp;&amp; nums[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;= arrMax) i++;<br>    <span class="hljs-keyword">if</span> (i === nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; arrMax) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    k = <span class="hljs-built_in">Math</span>.max(k, i + nums[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月31日</title>
    <link href="/2020/10/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8831%E6%97%A5/"/>
    <url>/2020/10/31/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt22.括号生成、回溯算法</p><span id="more"></span><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h1><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的  **括号组合。<br> **示例：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<br>       <span class="hljs-string">&quot;((()))&quot;</span>,<br>       <span class="hljs-string">&quot;(()())&quot;</span>,<br>       <span class="hljs-string">&quot;(())()&quot;</span>,<br>       <span class="hljs-string">&quot;()(())&quot;</span>,<br>       <span class="hljs-string">&quot;()()()&quot;</span><br>     ]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置一个递归函数，传入当前括号字符串，已有的左括号数及右括号数。<br>如果左括号数等于右括号数等于 0，说明已经是一个有效的括号组合字符串，将字符串结果加入结果数组中，进行回溯。<br>如果左括号数等于右括号数，<code>为了括号有效，下一个必须是左括号</code>，所以字符串传入左括号，同时传入 left-1。<br>如果左右不相等，优先深度，先判断 left 是否大于 0，优先添加左括号。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> generateParenthesis = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> generate = <span class="hljs-function">(<span class="hljs-params">str, left, right</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (left === <span class="hljs-number">0</span> &amp;&amp; right === <span class="hljs-number">0</span>) &#123;<br>      res.push(str);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left === right) generate(str + <span class="hljs-string">&quot;(&quot;</span>, left - <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) generate(str + <span class="hljs-string">&quot;(&quot;</span>, left - <span class="hljs-number">1</span>, right);<br>      generate(str + <span class="hljs-string">&quot;)&quot;</span>, left, right - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;;<br>  generate(<span class="hljs-string">&quot;&quot;</span>, n, n);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月30日</title>
    <link href="/2020/10/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8830%E6%97%A5/"/>
    <url>/2020/10/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt463.岛屿的周长、dfs</p><span id="more"></span><h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h1><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地  0 表示水域。<br>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1604021939791-47b7300e-568a-40aa-abaa-ca8b46cc56a2.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&originHeight=213&originWidth=221&size=0&status=done&style=none&width=221"><br> <strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[<span class="hljs-comment">[0,1,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,1,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[0,1,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,0,0]</span>]</span><br>输出: 16<br>解释: 它的周长是下面图片中的 16 个黄色的边：<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h4><p>对每一个节点，如果为陆地，计数先加上 4，然后判断他上下左右是否为陆地，为陆地则将边减去，如果是最靠外一圈，说明边一定存在，会跳过其靠外的那个边减的过程。根据 i 是否大于 0 小于 grid.length，j 是否大于 0，小于 grid[i].length 来判断。</p><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>只有一个岛屿，所以找到第一个陆地开始深度遍历。<br>当 x，y 在边界之外时，表示上一个节点的一条边在边界上，边加一。<br>当 x，y 为 0，表示为水域，边加一。<br>当 x，y 为 2，表示为陆地且已经遍历过，直接返回 0。<br>当 x，y 为 1，表示还未遍历过的陆地，对该点的上下左右进行深度遍历。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="双重遍历-1"><a href="#双重遍历-1" class="headerlink" title="双重遍历"></a>双重遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> islandPerimeter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">1</span>) &#123;<br>        count += <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] === <span class="hljs-number">1</span>) count--;<br>        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) count--;<br>        <span class="hljs-keyword">if</span> (j &lt; grid[i].length - <span class="hljs-number">1</span> &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) count--;<br>        <span class="hljs-keyword">if</span> (i &lt; grid.length - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] === <span class="hljs-number">1</span>) count--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> islandPerimeter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; grid.length - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (grid[x][y] === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[x][y] === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> grid[x][y] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> dfs(x + <span class="hljs-number">1</span>, y) + dfs(x - <span class="hljs-number">1</span>, y) + dfs(x, y + <span class="hljs-number">1</span>) + dfs(x, y - <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dfs(i, j);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月29日</title>
    <link href="/2020/10/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8829%E6%97%A5/"/>
    <url>/2020/10/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt129.求根到叶子节点数字之和、dfs、回溯、二叉树</p><span id="more"></span><h1 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a></h1><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。<br>计算从根到叶子节点生成的所有数字之和。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例 1:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-number">25</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12</span>.<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13</span>.<br>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br>    <span class="hljs-number">4</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>   <span class="hljs-number">0</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">5</span>   <span class="hljs-number">1</span><br>输出: <span class="hljs-number">1026</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40.</span><br>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026.</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="数组做法-深度遍历加回溯"><a href="#数组做法-深度遍历加回溯" class="headerlink" title="数组做法-深度遍历加回溯"></a>数组做法-深度遍历加回溯</h4><p>使用一个临时数组作为存储一条从根节点到叶子节点的路径，当是叶子节点时，将数组结果加入结果数组中。遍历过程中使用回溯法，遍历完当前一条路线后，出栈上一个叶子节点，判断下一条路径，避免反复添加。</p><h4 id="非数组"><a href="#非数组" class="headerlink" title="非数组"></a>非数组</h4><p>遍历时多传入一个值，记录之前所有节点组成的数字，当是叶子节点时 sum 加上该数。避免使用了数组，也不需要进行回溯，降低了空间复杂度。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="数组做法-深度遍历加回溯-1"><a href="#数组做法-深度遍历加回溯-1" class="headerlink" title="数组做法-深度遍历加回溯"></a>数组做法-深度遍历加回溯</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    temp.push(root.val);<br>    <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;<br>      res.push(<span class="hljs-built_in">Number</span>(temp.join(<span class="hljs-string">&quot;&quot;</span>)));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left) &#123;<br>      dfs(root.left);<br>      temp.pop();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.right) &#123;<br>      dfs(root.right);<br>      temp.pop();<br>    &#125;<br>  &#125;;<br>  dfs(root);<br>  <span class="hljs-keyword">return</span> res.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="非数组-1"><a href="#非数组-1" class="headerlink" title="非数组"></a>非数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> temp = value * <span class="hljs-number">10</span> + root.val;<br>    <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;<br>      sum += temp;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left) dfs(root.left, temp);<br>    <span class="hljs-keyword">if</span> (root.right) dfs(root.right, temp);<br>  &#125;;<br>  dfs(root, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>回溯算法</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月28日</title>
    <link href="/2020/10/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8828%E6%97%A5/"/>
    <url>/2020/10/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1207. 独一无二的出现次数、hash、排序、数组</p><span id="more"></span><h1 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207. 独一无二的出现次数"></a><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">1207. 独一无二的出现次数</a></h1><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了<span class="hljs-number"> 3 </span>次，2 出现了<span class="hljs-number"> 2 </span>次，3 只出现了<span class="hljs-number"> 1 </span>次。没有两个数的出现次数相同。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：arr = [<span class="hljs-string">-3</span>,0,1,<span class="hljs-string">-3</span>,1,1,1,<span class="hljs-string">-3</span>,10,0]<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="hash-数组去重"><a href="#hash-数组去重" class="headerlink" title="hash+数组去重"></a>hash+数组去重</h4><p>很显然很暴力的一种解法，使用哈希记录元素出现个数，转为数组，再去重比较前后数组长度是否发生变化</p><h4 id="hash-排序"><a href="#hash-排序" class="headerlink" title="hash+排序"></a>hash+排序</h4><p>排序后计算每一个元素出现的数量，判断对应数字在哈希表中是否已有，已有即可返回 false</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="hash-数组去重-1"><a href="#hash-数组去重-1" class="headerlink" title="hash+数组去重"></a>hash+数组去重</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniqueOccurrences = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>    map.set(num, map.has(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    [...map.values()].length === [...new <span class="hljs-built_in">Set</span>(map.values()).values()].length<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">arr</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniqueOccurrences = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= arr.length - <span class="hljs-number">1</span> &amp;&amp; arr[i + <span class="hljs-number">1</span>] === arr[i]) &#123;<br>      i++;<br>      num++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (map[num]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    map[num] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月27日</title>
    <link href="/2020/10/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8827%E6%97%A5/"/>
    <url>/2020/10/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt144. 二叉树的前序遍历、递归</p><span id="more"></span><h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>给定一个二叉树，返回它的 <em>前序  *遍历。<br>*</em>示例:**</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span><br>   1<br>    \<br>     2<br>    /<br>   3<br>输出: <span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>常规递归即可</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>队列解决</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> preOrder = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    res.push(root.val);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>  &#125;;<br>  preOrder(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> queue = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">if</span> (root) queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> root = queue.shift();<br>    res.push(root.val);<br>    <span class="hljs-keyword">if</span> (root.right) queue.unshift(root.right);<br>    <span class="hljs-keyword">if</span> (root.left) queue.unshift(root.left);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月26日</title>
    <link href="/2020/10/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8826%E6%97%A5/"/>
    <url>/2020/10/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1365. 有多少小于当前数字的数字、哈希、计数排序</p><span id="more"></span><h1 id="1365-有多少小于当前数字的数字"><a href="#1365-有多少小于当前数字的数字" class="headerlink" title="1365. 有多少小于当前数字的数字"></a><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/">1365. 有多少小于当前数字的数字</a></h1><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。<br>以数组形式返回答案。<br> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[8,1,2,2,3]</span><br>输出：<span class="hljs-comment">[4,0,1,1,3]</span><br>解释：<br>对于 nums<span class="hljs-comment">[0]</span>=8 存在四个比它小的数字：（1，2，2 和 3）。<br>对于 nums<span class="hljs-comment">[1]</span>=1 不存在比它小的数字。<br>对于 nums<span class="hljs-comment">[2]</span>=2 存在一个比它小的数字：（1）。<br>对于 nums<span class="hljs-comment">[3]</span>=2 存在一个比它小的数字：（1）。<br>对于 nums<span class="hljs-comment">[4]</span>=3 存在三个比它小的数字：（1，2 和 2）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">6,5,4,8</span>]<br>输出：[<span class="hljs-number">2,1,0,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">7,7,7,7</span>]<br>输出：[<span class="hljs-number">0,0,0,0</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><p>有一种很显而易见的双重遍历方法，选取一个数字，再从头逐个判断是否比当前数字小，计数加入结果。时间复杂度 O(N^2)，空间复杂度 O(1)</p><h4 id="哈希-排序"><a href="#哈希-排序" class="headerlink" title="哈希+排序"></a>哈希+排序</h4><p>使用哈希表记录原先数组的下标，再使用 sort 排序，计算当前数字前有几个数字比它小，再通过哈表表得到原来的下标，设置对应结果数组的值。时间复杂度 O(NlogN)，空间复杂度 O(N)</p><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>可以得知 nums 内数字的值范围在 0-100 之间，并不是很大，所以可以通过计数排序的方法得到结果：</p><ol><li>首先创建一个 100 长度的数组，填充 0</li><li>遍历一次数组，将相应的位数计数添加</li><li>可知比当前数小的是当前数之前每一位数计数之和，所以遍历一次临时数组，每一位等于当前位加前一位</li><li>再遍历一次原数组，将临时数组对应的下标的值加入结果数组。这里需要注意，临时数组的意义是，小于等于当前数的数量，所以根据题意应该取的是当前数的上一个，也就是下标减一的那个数对应的值。为了防止 0 这个数下标-1 取到 undefined，需要单独处理。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力遍历-1"><a href="#暴力遍历-1" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallerNumbersThanCurrent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num1 <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num2 <span class="hljs-keyword">of</span> nums) &#123;<br>      <span class="hljs-keyword">if</span> (num1 &gt; num2) count++;<br>    &#125;<br>    res.push(count);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希-排序-1"><a href="#哈希-排序-1" class="headerlink" title="哈希+排序"></a>哈希+排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallerNumbersThanCurrent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(nums[i])) map.set(nums[i], [i]);<br>    <span class="hljs-keyword">else</span> map.set(nums[i], [...map.get(nums[i]), i]);<br>  &#125;<br>  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">let</span> preCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[i + <span class="hljs-number">1</span>] == nums[i]) &#123;<br>      i++;<br>      count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preCount &gt; <span class="hljs-number">0</span>) &#123;<br>      map.get(nums[i]).forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        res[e] = preCount;<br>      &#125;);<br>    &#125;<br>    preCount += count;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="计数排序-1"><a href="#计数排序-1" class="headerlink" title="计数排序"></a>计数排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallerNumbersThanCurrent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    temp[num]++;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    temp[i] += temp[i - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    res.push(nums[i] ? temp[nums[i] - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月25日</title>
    <link href="/2020/10/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8825%E6%97%A5/"/>
    <url>/2020/10/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt845. 数组中的最长山脉</p><span id="more"></span><h1 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a></h1><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “_山脉”_：</p><ul><li><code>B.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li></ul><p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）<br>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em> 的长度。<br>如果不含有 “<em>山脉” *则返回 <code>0</code>。<br>*</em>示例 1：**</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,1,4,7,3,2,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：最长的 “山脉” 是 <span class="hljs-string">[1,4,7,3,2]</span>，长度为 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,2,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：不含 “山脉”。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力遍历-状态记录（数组）"><a href="#暴力遍历-状态记录（数组）" class="headerlink" title="暴力遍历+状态记录（数组）"></a>暴力遍历+状态记录（数组）</h4><p>设置一个 max 储存最大山脉子集长度，一个 temp 存储子集，一个 status 记录上坡还是下坡状态。有以下逻辑：</p><ol><li>当 status===0，即上坡时：<ol><li>如果数组内无元素或者当前元素比临时数组最后一个元素来得大，说明可以继续上坡，将元素加入临时数组</li><li>山脉最小长度为 3，所以当临时数组长度大于等于 2，且当前元素比临时数组最后一个元素来得小，说明进入下坡状态，将元素加入临时数组。这里可能已经是数组的最后一个元素，判断是否是，是的话计算一下 max</li><li>其他情况说明山脉不合法，从该元素开始重新计算山脉，将 temp 重新设置，仅包含当前元素</li></ol></li><li>当 status===1，即下坡时：<ol><li>当前元素比临时数组最后一个元素来得小，说明可以继续下坡，将元素加入临时数组。这里可能已经是数组的最后一个元素，判断是否是，是的话计算一下 max</li><li>其他情况说明，下坡状态结束，将状态设为上坡。这里注意，要令–i，从当前元素的上一个元素开始判断。</li></ol></li></ol><h4 id="无数组优化"><a href="#无数组优化" class="headerlink" title="无数组优化"></a>无数组优化</h4><p>可以看到，山脉判断仅和临时的最后一个元素有关，所以可以使用一个 pre 和 length 来代替 temp 临时数组，节省空间复杂度</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力遍历-状态记录（数组）-1"><a href="#暴力遍历-状态记录（数组）-1" class="headerlink" title="暴力遍历+状态记录（数组）"></a>暴力遍历+状态记录（数组）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestMountain = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> temp = [];<br>  <span class="hljs-keyword">let</span> status = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!temp.length || A[i] &gt; temp[temp.length - <span class="hljs-number">1</span>]) temp.push(A[i]);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp.length &gt;= <span class="hljs-number">2</span> &amp;&amp; A[i] &lt; temp[temp.length - <span class="hljs-number">1</span>]) &#123;<br>        temp.push(A[i]);<br>        status = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i === A.length - <span class="hljs-number">1</span>) max = <span class="hljs-built_in">Math</span>.max(temp.length, max);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        temp = [A[i]];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (A[i] &lt; temp[temp.length - <span class="hljs-number">1</span>]) &#123;<br>        temp.push(A[i]);<br>        <span class="hljs-keyword">if</span> (i === A.length - <span class="hljs-number">1</span>) max = <span class="hljs-built_in">Math</span>.max(temp.length, max);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        max = <span class="hljs-built_in">Math</span>.max(temp.length, max);<br>        status = <span class="hljs-number">0</span>;<br>        temp = [A[--i]];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="无数组优化-1"><a href="#无数组优化-1" class="headerlink" title="无数组优化"></a>无数组优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestMountain = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> status = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!length || A[i] &gt; pre) &#123;<br>        pre = A[i];<br>        length++;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (length &gt;= <span class="hljs-number">2</span> &amp;&amp; A[i] &lt; pre) &#123;<br>        pre = A[i];<br>        length++;<br>        status = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i === A.length - <span class="hljs-number">1</span>) max = <span class="hljs-built_in">Math</span>.max(length, max);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        pre = A[i];<br>        length = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (A[i] &lt; pre) &#123;<br>        pre = A[i];<br>        length++;<br>        <span class="hljs-keyword">if</span> (i === A.length - <span class="hljs-number">1</span>) max = <span class="hljs-built_in">Math</span>.max(length, max);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        max = <span class="hljs-built_in">Math</span>.max(length, max);<br>        status = <span class="hljs-number">0</span>;<br>        pre = A[--i];<br>        length = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月24日-1024快乐</title>
    <link href="/2020/10/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8824%E6%97%A5-1024%E5%BF%AB%E4%B9%90/"/>
    <url>/2020/10/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8824%E6%97%A5-1024%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<p>Lt1024. 视频拼接,贪心算法</p><span id="more"></span><h1 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a></h1><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。<br>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。<br>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：clips = <span class="hljs-comment">[<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[1,9]</span>,<span class="hljs-comment">[1,5]</span>,<span class="hljs-comment">[5,9]</span>]</span>, T = 10<br>输出：3<br>解释：<br>我们选中 <span class="hljs-comment">[0,2]</span>, <span class="hljs-comment">[8,10]</span>, <span class="hljs-comment">[1,9]</span> 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 <span class="hljs-comment">[1,9]</span> 再剪辑为 <span class="hljs-comment">[1,2]</span> + <span class="hljs-comment">[2,8]</span> + <span class="hljs-comment">[8,9]</span> 。<br>现在我们手上有 <span class="hljs-comment">[0,2]</span> + <span class="hljs-comment">[2,8]</span> + <span class="hljs-comment">[8,10]</span>，而这些涵盖了整场比赛 <span class="hljs-comment">[0, 10]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：clips = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,2]</span>]</span>, T = 5<br>输出：-1<br>解释：<br>我们无法只用 <span class="hljs-comment">[0,1]</span> 和 <span class="hljs-comment">[1,2]</span> 覆盖 <span class="hljs-comment">[0,5]</span> 的整个过程。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：clips = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[6,8]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[0,3]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,5]</span>,<span class="hljs-comment">[2,6]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[5,7]</span>,<span class="hljs-comment">[6,9]</span>]</span>, T = 9<br>输出：3<br>解释：<br>我们选取片段 <span class="hljs-comment">[0,4]</span>, <span class="hljs-comment">[4,7]</span> 和<span class="hljs-comment">[6,9]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：clips = <span class="hljs-string">[[0,4],[2,8]]</span>, T = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>注意，你可能录制超过比赛结束时间的视频。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= clips.length &lt;= 100</code></li><li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li><li><code>0 &lt;= T &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>注意到对于所有<strong>左端点相同</strong>的子区间，其<strong>右端点越远越有利</strong>。<br>贪心算法，执行以下过程：</p><ol><li>首先将数组按照区间大小降序排序</li><li>求是否存在以 0 开始的区间，不存在则返回-1</li><li>当 max&lt;T，持续进行区间选取，循环具体逻辑：<ol><li>使用一个临时数组等于排序之后的数组。</li><li>使用 filter 取到左端点在上一个已取区间内，右端点在已取区间外的所有区间。</li><li>令这些区间的左端点都为上一个已取区间的右端点，这样所有左端点子区间都相同了。</li><li>按区间大小降序排序，其实就是取右端点最远的那个区间。</li><li>如果存在这样的区间，则取该区间，将最左最右端点设为区间的端点。</li><li>如果不存在则返回-1。</li></ol></li><li>返回 count 结果</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">clips</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">T</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> videoStitching = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clips, T</span>) </span>&#123;<br>  clips.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b[<span class="hljs-number">1</span>] - b[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">1</span>] - a[<span class="hljs-number">0</span>]));<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> [min, max] = [<span class="hljs-number">0</span>, -<span class="hljs-literal">Infinity</span>];<br>  <span class="hljs-keyword">const</span> arr = clips.filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e[<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (arr.length) &#123;<br>    min = arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    max = arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    count++;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (max &lt; T) &#123;<br>    <span class="hljs-keyword">const</span> temp = clips<br>      .concat()<br>      .filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e[<span class="hljs-number">1</span>] &gt; max &amp;&amp; e[<span class="hljs-number">0</span>] &lt;= max)<br>      .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> [max, e[<span class="hljs-number">1</span>]])<br>      .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b[<span class="hljs-number">1</span>] - b[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">1</span>] - a[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">if</span> (temp.length) &#123;<br>      min = temp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>      max = temp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>      count++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月23日</title>
    <link href="/2020/10/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8823%E6%97%A5/"/>
    <url>/2020/10/23/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt234. 回文链表,快慢指针</p><span id="more"></span><h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>请判断一个链表是否为回文链表。<br><strong>示例 1:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span><br>输出: <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span><br>输出: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用  O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="数组存储结果反向对比"><a href="#数组存储结果反向对比" class="headerlink" title="数组存储结果反向对比"></a>数组存储结果反向对比</h4><p>遍历链表，将节点的值加入结果数组，将数组和反向数组转换成字符串进行比较</p><h4 id="改造为双向链表"><a href="#改造为双向链表" class="headerlink" title="改造为双向链表"></a>改造为双向链表</h4><p>改变了数据结构，其实应该不符合题意，将链表改造为双向链表，从首尾开始判断是否相同，直到两个指针相遇。</p><h4 id="快慢指针-反向链表"><a href="#快慢指针-反向链表" class="headerlink" title="快慢指针+反向链表"></a>快慢指针+反向链表</h4><p>使用快慢指针找到链表中点，将后半部分链表反向，从头和中间节点开始判断每一位是否相等。<br>反向链表的过程如下：</p><ol><li>设置一个 prev 存储上一个节点</li><li>tempNext 存储当前节点的下一个节点</li><li>将当前节点的下一个节点设置为 prev</li><li>将 prev 指向当前节点</li><li>将当前指针指向 tempNext</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="数组存储结果反向对比-1"><a href="#数组存储结果反向对比-1" class="headerlink" title="数组存储结果反向对比"></a>数组存储结果反向对比</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    res.push(head.val);<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">&quot;&quot;</span>) === res.reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="改造为双向链表-1"><a href="#改造为双向链表-1" class="headerlink" title="改造为双向链表"></a>改造为双向链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> temp = head;<br>  <span class="hljs-keyword">while</span> (temp &amp;&amp; temp.next) &#123;<br>    prev = temp;<br>    temp = temp.next;<br>    temp.prev = prev;<br>  &#125;<br>  <span class="hljs-keyword">let</span> left = head,<br>    right = temp;<br>  <span class="hljs-keyword">while</span> (left !== right &amp;&amp; left &amp;&amp; right) &#123;<br>    <span class="hljs-keyword">if</span> (left.val !== right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    left = left.next;<br>    right = right.prev;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="快慢指针-反向链表-1"><a href="#快慢指针-反向链表-1" class="headerlink" title="快慢指针+反向链表"></a>快慢指针+反向链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> fast = head,<br>    slow = head;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) &#123;<br>    slow = slow.next;<br>    fast = fast.next.next;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (slow) &#123;<br>    <span class="hljs-keyword">let</span> nextTemp = slow.next;<br>    slow.next = prev;<br>    prev = slow;<br>    slow = nextTemp;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (prev &amp;&amp; head) &#123;<br>    <span class="hljs-keyword">if</span> (prev.val !== head.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    prev = prev.next;<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月22日</title>
    <link href="/2020/10/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8822%E6%97%A5/"/>
    <url>/2020/10/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt763. 划分字母区间、哈希表<br>L56. 合并区间</p><span id="more"></span><h1 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h1><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。<br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用 map 记录字符串第一次出现和最后一次出现的下标，再转化为数组，例如 ababcbacadefegdehijhklij 处理后会转为： [[0, 8], [1, 5], [4, 7], [9, 14], [10, 15], [11, 11], [13, 13], [16, 19], [17, 22], [18, 23], [20, 20], [21, 21]]，问题转换为<a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a>。<br>合并区间的思路看下一题。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> partitionLabels = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(S[i])) map.set(S[i], &#123; <span class="hljs-attr">start</span>: i &#125;);<br>    <span class="hljs-keyword">else</span> map.set(S[i], &#123; <span class="hljs-attr">start</span>: map.get(S[i]).start, <span class="hljs-attr">end</span>: i &#125;);<br>  &#125;<br>  <span class="hljs-keyword">const</span> mapArr = [...map.values()].map(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> [<br>    a.start,<br>    a.end ? a.end : a.start,<br>  ]);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> [min, max] = mapArr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; mapArr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (mapArr[i][<span class="hljs-number">0</span>] &gt; max) &#123;<br>      res.push(max - min + <span class="hljs-number">1</span>);<br>      min = mapArr[i][<span class="hljs-number">0</span>];<br>      max = mapArr[i][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mapArr[i][<span class="hljs-number">1</span>] &gt; max) max = mapArr[i][<span class="hljs-number">1</span>];<br>  &#125;<br>  res.push(max - min + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h1><p>给出一个区间的集合，请合并所有重叠的区间。<br> <strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出: <span class="hljs-string">[[1,5]]</span><br>解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>输入类型已于 2019 年 4 月 15 日更改。 请重置默认代码定义以获取新方法签名。<br> <strong>提示：</strong></p><ul><li><code>intervals[i][0] &lt;= intervals[i][1]</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先确保数组有元素且按每个元素的区间的 start 升序排序。<br>先令元素第一个成为标识值，确定一个区间的初始起始和结束下标。遍历每一个元素，有以下逻辑：</p><ol><li>如果该区间的起始值就大于合并区间的结束值，那么说明两个区间没有交集，需要新建一个合并区间，当前的合并区间可以结束了，将合并区间加入结果数组，同时将起始和结束下标设为改元素的起始结束下标。</li><li>如果该区间的结束值大于合并区间的结束值，说明两个区间有交集，需要将合并区间的结束值设为该区间的结束值，使其成为子集。</li><li>都没有，说明该区间在合并区间内，直接跳过，判断下一个。</li></ol><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">intervals</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">intervals</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!intervals.length) <span class="hljs-keyword">return</span> [];<br>  intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-built_in">Number</span>(b[<span class="hljs-number">0</span>]));<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> [min, max] = intervals[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; max) &#123;<br>      res.push([min, max]);<br>      min = intervals[i][<span class="hljs-number">0</span>];<br>      max = intervals[i][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; max) max = intervals[i][<span class="hljs-number">1</span>];<br>  &#125;<br>  res.push([min, max]);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月21日</title>
    <link href="/2020/10/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8821%E6%97%A5/"/>
    <url>/2020/10/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 11. 旋转数组的最小数字、二分算法</p><span id="more"></span><h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为 1。  <br><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="找第一个非递增值"><a href="#找第一个非递增值" class="headerlink" title="找第一个非递增值"></a>找第一个非递增值</h4><p>设定一个 index，遍历数组元素，若第 i+1 个元素小于第 i 个元素，那么这个元素就是第一个非递增值，即为最小值。</p><h4 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h4><p>可以假定数组第一个为最小元素。分为左右递增数列，第 1 个元素在左边递增数列一定是最小的，在右边递增数列一定是最大的，只要当一个元素大于第一个元素说明他就是右边递增数列的第一个元素即最小的元素，返回该元素即可。若遍历完数组都不存在比第一个元素小的元素，就返回第一个元素。</p><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>参考题解：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">旋转数组的最小数字</a><br>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1603242463742-626bcc93-c8df-4a35-88cd-be7ced184e1a.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&originHeight=913&originWidth=2000&size=0&status=done&style=none&width=2000"><br>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要旋转的目标。<br>我们考虑数组中的最后一个元素 xx：在最小值右侧的元素，它们的值一定都小于等于 xx；而在最小值左侧的元素，它们的值一定都大于等于 xx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1603242471612-0d064083-fbc7-4a10-98de-4717124e8325.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&originHeight=913&originWidth=2000&size=0&status=done&style=none&width=2000"><br>在二分查找的每一步中，左边界为 low，右边界为 high，区间的中点为 pivot，最小值就在该区间内。我们将中轴元素 numbers[pivot] 与右边界元素 numbers[high] 进行比较，可能会有以下的三种情况：<br>第一种情况是 numbers[pivot]&lt;numbers[high]。如下图所示，这说明 numbers[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1603242488882-b1006e1e-d863-47cb-bdc8-ce2fb72a6378.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&originHeight=913&originWidth=2000&size=0&status=done&style=none&width=2000"><br>第二种情况是 numbers[pivot]&gt;numbers[high]。如下图所示，这说明 numbers[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1603242608148-ad39ba2d-635d-4fc0-80a0-a74287434760.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&originHeight=913&originWidth=2000&size=0&status=done&style=none&width=2000"><br>第三种情况是 numbers[pivot]==numbers[high]。如下图所示，由于重复元素的存在，我们并不能确定 numbers[pivot] 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 numbers[high] 是不是最小值，都有一个它的「替代品」numbers[pivot]，因此我们可以忽略二分查找区间的右端点。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1603242614694-d4221264-3d95-4ca9-92d0-cb1140fd3642.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&originHeight=913&originWidth=2000&size=0&status=done&style=none&width=2000"><br>当二分查找结束时，我们就得到了最小值所在的位置。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="找第一个非递增值-1"><a href="#找第一个非递增值-1" class="headerlink" title="找第一个非递增值"></a>找第一个非递增值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">numbers</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (numbers[i + <span class="hljs-number">1</span>] &lt; numbers[i]) &#123;<br>      index = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> numbers[index];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="进一步思考-1"><a href="#进一步思考-1" class="headerlink" title="进一步思考"></a>进一步思考</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">numbers</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; numbers.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (numbers[i] &lt; numbers[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二分-1"><a href="#二分-1" class="headerlink" title="二分"></a>二分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">numbers</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = numbers.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((left + right) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (numbers[right] &gt; numbers[mid]) r = mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number[right] &lt; numbers[mid]) l = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> r--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> numbers[left];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月20日</title>
    <link href="/2020/10/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8820%E6%97%A5/"/>
    <url>/2020/10/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<ol start="48"><li>旋转图像、数学矩阵规律<span id="more"></span></li></ol><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 <em>n *× <em>n</em> 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。<br>*</em>说明：**<br>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a><strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。</strong>请不要<strong>使用另一个矩阵来旋转图像。<br>**示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 matrix =<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,5,6]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[7,8,9]</span></span><br><span class="hljs-comment">]</span>,<br>原地旋转输入矩阵，使其变为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[7,4,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[8,5,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,6,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 matrix =<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[ 5, 1, 9,11]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[ 2, 4, 8,10]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[13, 3, 6, 7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,14,12,16]</span></span><br><span class="hljs-comment">]</span>,<br>原地旋转输入矩阵，使其变为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,13, 2, 5]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[14, 3, 4, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[12, 6, 8, 9]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[16, 7,10,11]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="规律旋转"><a href="#规律旋转" class="headerlink" title="规律旋转"></a>规律旋转</h4><p>先交换 4 个顶点的值，再看下一个需要交换点有规律存在：</p><ol><li>左上角的点，取右边的点</li><li>右上角的点，取下边的点</li><li>右下角的点，取左边的点</li><li>左下角的点，取上边的点</li></ol><p>按这个规律可以交换完该边上的所有点，就完成了最外一层的交换。<br>那么现在可以写一个递归函数，传入 start（该层最左上的点的横纵坐标，例如第一层为(0,0)，第二层则为(1,1) ），end（该层最右下点的横纵左边，例如 matrix 的边长为 4，第一层应该为(3,3)，第二层则为(2,2) ），num（该层的需要交换的节点数量，例如 matrix 的边长为 4，则第一层 num 应该交换 3 个节点，num=3，第二层 num=1）<br>所以可以得到递归的规律：<br>传入的参数每层，start+1，end-1，num-2，当 num&lt;=0 的时候表示没有需要交换的点，退出递归</p><h4 id="转置矩阵镜像"><a href="#转置矩阵镜像" class="headerlink" title="转置矩阵镜像"></a>转置矩阵镜像</h4><p>先将矩阵上下水平翻转，再求转置矩阵即对角线翻转即可得到结果</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="规律旋转-1"><a href="#规律旋转-1" class="headerlink" title="规律旋转"></a>规律旋转</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> r = <span class="hljs-function">(<span class="hljs-params">start, end, num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>      <span class="hljs-keyword">let</span> temp = matrix[start][start + i];<br>      matrix[start][start + i] = matrix[end - i][start];<br>      matrix[end - i][start] = matrix[end][end - i];<br>      matrix[end][end - i] = matrix[start + i][end];<br>      matrix[start + i][end] = temp;<br>    &#125;<br>    r(start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>, num - <span class="hljs-number">2</span>);<br>  &#125;;<br>  r(<span class="hljs-number">0</span>, matrix.length - <span class="hljs-number">1</span>, matrix.length - <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="转置矩阵镜像-1"><a href="#转置矩阵镜像-1" class="headerlink" title="转置矩阵镜像"></a>转置矩阵镜像</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">parseInt</span>(matrix.length / <span class="hljs-number">2</span>); i++) &#123;<br>    [matrix[i], [matrix[matrix.length - <span class="hljs-number">1</span> - i]]] = [<br>      matrix[matrix.length - <span class="hljs-number">1</span> - i],<br>      [matrix[i]],<br>    ];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; matrix.length; j++) &#123;<br>      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月19日</title>
    <link href="/2020/10/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8819%E6%97%A5/"/>
    <url>/2020/10/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt844. 比较含退格的字符串、双指针</p><span id="more"></span><h1 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h1><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。<br><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。<br> <strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：S = <span class="hljs-string">&quot;ab<span class="hljs-subst">#c</span>&quot;</span>, T = <span class="hljs-string">&quot;ad<span class="hljs-subst">#c</span>&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：S 和 T 都会变成 “ac”。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ab##&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;c#d#&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：S 和 T 都会变成 “”。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：S = <span class="hljs-string">&quot;a#<span class="hljs-subst">#c</span>&quot;</span>, T = <span class="hljs-string">&quot;<span class="hljs-subst">#a</span><span class="hljs-subst">#c</span>&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：S 和 T 都会变成 “c”。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;a#c&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：S 会变成 “c”，但 T 仍然是 “b”。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 200</code></li><li><code>1 &lt;= T.length &lt;= 200</code></li><li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li></ol><p><strong>进阶：</strong></p><ul><li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="栈储存结果"><a href="#栈储存结果" class="headerlink" title="栈储存结果"></a>栈储存结果</h4><p>时间复杂度、空间复杂度都为 O(n)。使用一个 isDelete 计数退格符的数量，遍历字符串每一个字符，如果是退格符则计数加一跳过当前循环，如果非退格符且 isDelete 计数大于 0 则计数减一，跳过当前循环，相当于删除当前字符</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>使用两个指针分别指向两个字符串尾部，当两个指针其中一个还指向有效位数前，进行循环：</p><ol><li>对 S 进行循环，如果是退格符，skip1 计数加一，l1–；如果非退格符但 skip1&gt;0，说明是需要删除的字符，skip1–，l1–；如果非退格符，且 skip1===0，说明是需要判断的字符串，退出循环。</li><li>对 T 进行同上循环。</li><li>如果两个指针都是有效下标，则判断两个指针指向的字符是否相等，不相等则返回 false；如果其中一个是无效下标，即该字符串已退格完毕，如果另外一个字符串的下标仍大于等于 0，说明还存在字符串未退格，两个字符串的长度不相等，返回 false；</li><li>如果字符串相等的且下标有效的情况下，判断以后另两个指针都减一，判断下一个字符</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="栈储存结果-1"><a href="#栈储存结果-1" class="headerlink" title="栈储存结果"></a>栈储存结果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">T</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> backspaceCompare = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S, T</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> compare = <span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">let</span> isDelete = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = s.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">const</span> arr = s[i];<br>      <span class="hljs-keyword">if</span> (arr === <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>        isDelete++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (arr !== <span class="hljs-string">&quot;#&quot;</span> &amp;&amp; isDelete &gt; <span class="hljs-number">0</span>) &#123;<br>        isDelete--;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      res.unshift(arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> compare(S) === compare(T);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">T</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> backspaceCompare = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">S, T</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> l1 = S.length - <span class="hljs-number">1</span>,<br>    l2 = T.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> skip1 = <span class="hljs-number">0</span>,<br>    skip2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (l1 &gt;= <span class="hljs-number">0</span> || l2 &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">while</span> (l1 &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (S[l1] === <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>        skip1++;<br>        l1--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skip1 &gt; <span class="hljs-number">0</span>) &#123;<br>        skip1--;<br>        l1--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l2 &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (T[l2] === <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>        skip2++;<br>        l2--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skip2 &gt; <span class="hljs-number">0</span>) &#123;<br>        skip2--;<br>        l2--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 &gt;= <span class="hljs-number">0</span> &amp;&amp; l2 &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (S[l1] !== T[l2]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (l1 &gt;= <span class="hljs-number">0</span> || l2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    l1--;<br>    l2--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月18日</title>
    <link href="/2020/10/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8818%E6%97%A5/"/>
    <url>/2020/10/18/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt11. 盛最多水的容器、双指针</p><span id="more"></span><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>给你 <em>n</em> 个非负整数 <em>a_，_a</em>…，<em>a</em>每个数代表坐标中的一个点  (<em>i</em>, <em>a</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为  (<em>i</em>, <em>a</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。<br><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1603012321222-faa071b7-27df-4c1a-9759-83fcc7bdfcb7.jpeg#align=left&display=inline&height=287&margin=%5Bobject%20Object%5D&originHeight=383&originWidth=801&size=0&status=done&style=none&width=600"><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为  49。<br><strong>示例：</strong><br><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<br><strong>输出：</strong>49</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>有一种显而易见的暴力解答，遍历每个元素，该元素再和之前的每个元素求可以容纳的体积，体积公式为：<code>底(i-j)乘高( Math.min(height[i],height[j]) )</code>取最大的即可。时间复杂度为 O(n^2）</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>实际上，并不是每个元素都需要重新计算，存在下面一种逻辑：</p><ol><li>使用左右双指针时，容器的底部已经是最大的了，若要移动指针，必定底部变小，所以要保留最高的那个边，移动最短的那个边</li><li>移动左右指针的时候，如果相邻的下一个高度小于当前的高度，可以直接跳过，判断下一个。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">height</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> maxV = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; height.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      maxV = <span class="hljs-built_in">Math</span>.max(maxV, (i - j) * <span class="hljs-built_in">Math</span>.min(height[i], height[j]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxV;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">height</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = height.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    max = <span class="hljs-built_in">Math</span>.max(max, (right - left) * <span class="hljs-built_in">Math</span>.min(height[left], height[right]));<br>    <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>      <span class="hljs-keyword">while</span> (height[right - <span class="hljs-number">1</span>] &lt; height[--right]) right--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span> (height[left + <span class="hljs-number">1</span>] &lt; height[++left]) left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月17日-回溯法三题</title>
    <link href="/2020/10/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8817%E6%97%A5-%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%A2%98/"/>
    <url>/2020/10/17/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8817%E6%97%A5-%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Lt46. 全排列、77. 组合、17. 电话号码的字母组合</p><span id="more"></span><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h1><p>给定一个**  没有重复** 数字的序列，返回其所有可能的全排列。<br><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用回溯法，当临时数组长度等于 k 时，得到了一种排列方式，将 temp 加入结果 res 数组。<br>每次 dfs 都会从下标 0 开始找起，使用一个 visited 数组判断，求一种排列方式的过程中，数组内的元素的访问状态，在 temp 中有的数据，会被设为 true。下一个 dfs 会跳过 temp 中已有的元素。<br>dfs 完成后，将 temp 出栈，同时将 visited 设回未访问状态。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">let</span> visited = <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (temp.length === nums.length) &#123;<br>      res.push(temp.slice());<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;<br>        visited[i] = <span class="hljs-literal">true</span>;<br>        temp.push(nums[i]);<br>        dfs(temp);<br>        visited[i] = <span class="hljs-literal">false</span>;<br>        temp.pop();<br>      &#125;<br>    &#125;<br>  &#125;;<br>  dfs();<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h1><p>给定两个整数 <em>n</em> 和 <em>k_，返回 1 … *n *中所有可能的 _k</em> 个数的组合。<br><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: n = 4, k = 2<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和全排列方法类似，但是组合不需要从 0 开始找起，之前的元素是已经在当前组合或其他情况组合里的，所以 dfs 可以传入当前元素下标，从当前元素的下一个开始进行组合。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, k</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (temp.length === k) &#123;<br>      res.push(temp.slice());<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = x + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        temp.push(i);<br>        dfs(i);<br>        temp.pop();<br>      &#125;<br>    &#125;<br>  &#125;;<br>  dfs(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602934469221-473b266d-f2ff-4d7e-921f-30fdeab17287.png#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=452&originWidth=499&size=0&status=done&style=none&width=200"><br><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>, <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;af&quot;</span>, <span class="hljs-string">&quot;bd&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;bf&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;ce&quot;</span>, <span class="hljs-string">&quot;cf&quot;</span>].<br></code></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="两两组合-BFS"><a href="#两两组合-BFS" class="headerlink" title="两两组合-BFS"></a>两两组合-BFS</h4><p>本质上是 BFS 实现的回溯，一层一层得到每层可以组合的结果，可以使用队列再优化。写一个两个数组的组合的方法，再将结果和下一个数组进行求组合。先删除字符串中的 1，之后如果没有长度或字符等于 1 返回空数组，其他情况返回对应的 map 里的数组。长度大于 2 的进行组合求解。</p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>使用一个 x，x 表示使用原字符串的指针下标，其实也可以不使用，直接使用临时数组长度 temp.length 代替 x。使用<code>map[digits[x]]</code>得到当前指针下标对应 map 里的数组，按顺序选取一个字符插入临时数组中，再进行 dfs 传入 x+1，对下一位进行处理，如果 x 等于 digits 长度则处理完成，将结果添加到 res 中，返回。处理完以后将当前字符出栈，选取下一个字符加入。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="两两组合-BFS-1"><a href="#两两组合-BFS-1" class="headerlink" title="两两组合-BFS"></a>两两组合-BFS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">digits</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">digits</span>) </span>&#123;<br>  digits = digits.replace(<span class="hljs-regexp">/1/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!digits.length || digits === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> map = &#123;<br>    <span class="hljs-number">2</span>: [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>],<br>    <span class="hljs-number">3</span>: [<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>],<br>    <span class="hljs-number">4</span>: [<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>],<br>    <span class="hljs-number">5</span>: [<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>],<br>    <span class="hljs-number">6</span>: [<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>],<br>    <span class="hljs-number">7</span>: [<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>],<br>    <span class="hljs-number">8</span>: [<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>],<br>    <span class="hljs-number">9</span>: [<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>],<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (digits.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> map[digits];<br>  <span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">arr1, arr2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> temp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>      temp.push(arr1[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr2.length; j++) &#123;<br>        temp.push(arr2[j]);<br>        res.push(temp.slice().join(<span class="hljs-string">&quot;&quot;</span>));<br>        temp.pop();<br>      &#125;<br>      temp.pop();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> digits.split(<span class="hljs-string">&quot;&quot;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) <span class="hljs-keyword">return</span> combine(a, map[b]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> [].concat(combine(map[a], map[b]));<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">digits</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">digits</span>) </span>&#123;<br>  digits = digits.replace(<span class="hljs-regexp">/1/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!digits.length || digits === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> map = &#123;<br>    <span class="hljs-number">2</span>: [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>],<br>    <span class="hljs-number">3</span>: [<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>],<br>    <span class="hljs-number">4</span>: [<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>],<br>    <span class="hljs-number">5</span>: [<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>],<br>    <span class="hljs-number">6</span>: [<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>],<br>    <span class="hljs-number">7</span>: [<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>],<br>    <span class="hljs-number">8</span>: [<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>],<br>    <span class="hljs-number">9</span>: [<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>],<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (digits.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> map[digits];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (x === digits.length) &#123;<br>      res.push(temp.slice().join(<span class="hljs-string">&quot;&quot;</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; map[digits[x]].length; i++) &#123;<br>        temp.push(map[digits[x]][i]);<br>        dfs(x + <span class="hljs-number">1</span>);<br>        temp.pop();<br>      &#125;<br>    &#125;<br>  &#125;;<br>  dfs(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>回溯算法</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月16日</title>
    <link href="/2020/10/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8816%E6%97%A5/"/>
    <url>/2020/10/16/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt977. 有序数组的平方、双指针</p><span id="more"></span><h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h1><p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。<br><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[-4,-1,0,3,10]</span><br>输出：<span class="hljs-selector-attr">[0,1,9,16,100]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[-7,-3,2,3,11]</span><br>输出：<span class="hljs-selector-attr">[4,9,9,49,121]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>A</code> 已按非递减顺序排序。</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h4><p>直接对平方后的数组进行排序得到结果</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>使用双指针可以在得到平方和的同时就得到有序的结果序列，减少一次排序过程</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力排序-1"><a href="#暴力排序-1" class="headerlink" title="暴力排序"></a>暴力排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedSquares = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> A.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e ** <span class="hljs-number">2</span>).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedSquares = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = A.length - <span class="hljs-number">1</span>,<br>    index = A.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">if</span> (A[left] ** <span class="hljs-number">2</span> &gt;= A[right] ** <span class="hljs-number">2</span>) &#123;<br>      res[index--] = A[left++] ** <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res[index--] = A[right--] ** <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月15日</title>
    <link href="/2020/10/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8815%E6%97%A5/"/>
    <url>/2020/10/15/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt116. 填充每个节点的下一个右侧节点指针、dfs、队列、递归</p><span id="more"></span><h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h1><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。<br>初始状态下，所有  next 指针都被设置为 <code>NULL</code>。<br> <strong>示例：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602722674377-6bc59ef9-34d7-4386-898f-3e13ca976a95.png#align=left&display=inline&height=218&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=1058&size=0&status=done&style=none&width=640"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">4</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">6</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">7</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">1</span>&#125;<br>输出：&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">7</span>&#125;,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">6</span>&#125;,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-string">&quot;right&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">4</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$id</span>&quot;</span>:<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;left&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$ref</span>&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$ref</span>&quot;</span>:<span class="hljs-string">&quot;6&quot;</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$ref</span>&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">&quot;next&quot;</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;right&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-subst">$ref</span>&quot;</span>:<span class="hljs-string">&quot;7&quot;</span>&#125;,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-number">1</span>&#125;<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="非常数空间-队列实现"><a href="#非常数空间-队列实现" class="headerlink" title="非常数空间-队列实现"></a>非常数空间-队列实现</h4><p>按不符合提议的非常数空间，可以有一种很简单的实现方式，队列层次遍历，只需要借用一个记录前一个节点地址的变量，每次遍历将上一个节点的 next 设为当前节点即可。</p><h4 id="递归-dfs"><a href="#递归-dfs" class="headerlink" title="递归-dfs"></a>递归-dfs</h4><p>参考<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/shou-hua-tu-jie-dfs-di-gui-yi-yu-li-jie-by-xiao_be/">「手画图解」DFS 递归 | 易于理解</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602724218468-19dc1626-7f7b-44f8-9e9c-ce18ccf5bd32.png#align=left&display=inline&height=679&margin=%5Bobject%20Object%5D&originHeight=679&originWidth=2249&size=0&status=done&style=none&width=2249"><br>如图所示，只有两种情况需要处理：</p><ol><li>该节点存在 next，为左孩子，如 2，将左孩子的 next 指向右孩子，还需要将右孩子的 next 指向当前节点 next 的左孩子</li><li>该节点不存在 next，为 root 或右孩子，如 1，3，将左孩子的 next 指向右孩子</li></ol><p>当为叶子节点，不存在左右孩子时跳出递归</p><h4 id="最左指针-dfs"><a href="#最左指针-dfs" class="headerlink" title="最左指针-dfs"></a>最左指针-dfs</h4><p>和上一个方法类似，使用一个最左指针，指向每一层的最左边的节点，之后进行每层层次遍历，处理逻辑基本同上：</p><ol><li>当前节点存在 next，为左孩子，如 2，将左孩子的 next 指向右孩子，还需要将右孩子的 next 指向当前节点 next 的左孩子</li><li>当前节点不存在 next，为 root 或右孩子，如 1，3，将左孩子的 next 指向右孩子</li><li>遍历该层下一个节点，指向该节点的 next</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="非常数空间-队列实现-1"><a href="#非常数空间-队列实现-1" class="headerlink" title="非常数空间-队列实现"></a>非常数空间-队列实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> queue = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">let</span> temp = queue.splice(<span class="hljs-number">0</span>, queue.length);<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (temp.length) &#123;<br>      <span class="hljs-keyword">const</span> node = temp.shift();<br>      <span class="hljs-keyword">if</span> (pre) pre.next = node;<br>      pre = node;<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="递归-dfs-1"><a href="#递归-dfs-1" class="headerlink" title="递归-dfs"></a>递归-dfs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) <span class="hljs-keyword">return</span>;<br>    root.left.next = root.right;<br>    <span class="hljs-keyword">if</span> (root.next) root.right.next = root.next.left;<br>    dfs(root.left);<br>    dfs(root.right);<br>  &#125;;<br>  dfs(root);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最左指针-dfs-1"><a href="#最左指针-dfs-1" class="headerlink" title="最左指针-dfs"></a>最左指针-dfs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> leftMost = root;<br>  <span class="hljs-keyword">while</span> (leftMost.left) &#123;<br>    <span class="hljs-keyword">let</span> temp = leftMost;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>      temp.left.next = temp.right;<br>      <span class="hljs-keyword">if</span> (temp.next) temp.right.next = temp.next.left;<br>      temp = temp.next;<br>    &#125;<br>    leftMost = leftMost.left;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
      <tag>队列</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月14日</title>
    <link href="/2020/10/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8814%E6%97%A5/"/>
    <url>/2020/10/14/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1002. 查找常用字符、461. 汉明距离、543. 二叉树的直径</p><span id="more"></span><h1 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. 查找常用字符</a></h1><p>给定仅有小写字母组成的字符串数组 <code>A</code>，返回列表中的每个字符串中都显示的全部字符（<strong>包括重复字符</strong>）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。<br>你可以按任意顺序返回答案。<br><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;bella&quot;</span>,<span class="hljs-string">&quot;label&quot;</span>,<span class="hljs-string">&quot;roller&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;cool&quot;</span>,<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;cook&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 100</code></li><li><code>1 &lt;= A[i].length &lt;= 100</code></li><li><code>A[i][j]</code> 是小写字母</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>相当于每次都是求两个字符串的交集，可以使用哈希表求解。每次循环设置一个新的哈希表，得到一个相同的字符后，将原来的哈希表里对应元素减一直到删除，再添加到新的哈希表中，全部遍历以后就得到了两个字符串的交集。再对每一个字符串都如此操作可以得到所有字符串的交集。</p><h4 id="Array-方法-every、filter"><a href="#Array-方法-every、filter" class="headerlink" title="Array 方法 every、filter"></a>Array 方法 every、filter</h4><p>将 A[0]设为标准，遍历 A[0]中的每一个字符。使用 every 判断在每一个字符串中都包含该字符，如果都包含，删除该字符，并将该字符加入结果数组中</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> commonChars = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  A[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;&quot;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> map.set(e, map.has(e) ? map.get(e) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; A.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; A[i].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (map.has(A[i][j])) &#123;<br>        map.get(A[i][j]) === <span class="hljs-number">1</span><br>          ? map.delete(A[i][j])<br>          : map.set(A[i][j], map.get(A[i][j]) - <span class="hljs-number">1</span>);<br>        temp.set(A[i][j], temp.has(A[i][j]) ? temp.get(A[i][j]) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    map = temp;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> [...map.entries()].reduce(<br>    <span class="hljs-function">(<span class="hljs-params">arr, [e, count]</span>) =&gt;</span> arr.concat(<span class="hljs-built_in">Array</span>(count).fill(e)),<br>    []<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Array-方法-every、filter-1"><a href="#Array-方法-every、filter-1" class="headerlink" title="Array 方法 every、filter"></a>Array 方法 every、filter</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">A</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> commonChars = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ans = [],<br>    word = A[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> word) &#123;<br>    <span class="hljs-keyword">if</span> (A.every(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.includes(s))) &#123;<br>      A = A.map(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.replace(s, <span class="hljs-string">&quot;&quot;</span>));<br>      ans.push(s);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h1><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。<br>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。<br><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 2.<br><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: x = 1, y = 4</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释:</span><br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br></code></pre></td></tr></table></figure><p>上面的箭头指出了对应二进制位不同的位置。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="padStart"><a href="#padStart" class="headerlink" title="padStart"></a>padStart</h4><p>将 x 和 y 转化为字符串，并在短的那个字符串前补 0。对每一位进行判断是否相等，不相等则计数加一。</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602658653874-fe336707-5e06-45ea-b588-2ec2483b833e.png#align=left&display=inline&height=516&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=1674&size=0&status=done&style=none&width=1674"></h4><blockquote><p>计算 <code>x</code> 和 <code>y</code> 之间的汉明距离，可以先计算 <code>x XOR y</code>，然后统计结果中等于 1 的位数。</p></blockquote><p>先求 x^y，再对结果的 1 计数即为汉明距离，可以使用 x&amp;1 判断最右的一位是否为 1，再使用 x&gt;&gt;1 使得位数向右移动一位，直到 x==0 为止</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="padStart-1"><a href="#padStart-1" class="headerlink" title="padStart"></a>padStart</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">y</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  x = x.toString(<span class="hljs-number">2</span>);<br>  y = y.toString(<span class="hljs-number">2</span>);<br>  length = <span class="hljs-built_in">Math</span>.max(x.length, y.length);<br>  x = x.padStart(length, <span class="hljs-string">&quot;0&quot;</span>);<br>  y = y.padStart(length, <span class="hljs-string">&quot;0&quot;</span>);<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (x[i] ^ y[i]) count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">y</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;<br>  x ^= y;<br>  <span class="hljs-keyword">while</span> (x !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) &#123;<br>      ans++;<br>    &#125;<br>    x &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者  [5,2,1,3]。<br><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>编写一个计算树深度的函数，遍历树，计算当前节点左右深度之和，更新最大的深度之和即为结果</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> getDepth = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(getDepth(root.left), getDepth(root.right));<br>  &#125;;<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    res = <span class="hljs-built_in">Math</span>.max(res, getDepth(root.left) + getDepth(root.right));<br>    visit(root.left);<br>    visit(root.right);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月13日</title>
    <link href="/2020/10/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8813%E6%97%A5/"/>
    <url>/2020/10/13/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt24. 两两交换链表中的节点</p><span id="more"></span><h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。<br> <strong>示例:</strong><br>给定 <code>1-&gt;2-&gt;3-&gt;4</code>, 你应该返回 <code>2-&gt;1-&gt;4-&gt;3</code>.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个哑节点简单化问题，执行以下步骤：</p><ol><li>dummy.next 为第一个节点 first，dummy.next.next 为第二个节点 second</li><li>将当前节点的下一个节点设为第二个节点即 dummy.next = second</li><li>将第一个节点的 next 设为第二个节点的 next 即 first.next = second.next</li><li>将第二个节点的 next 设为第一个节点即 second.next = first</li><li>前两个节点交换完毕，将指针指向第二个元素即 dummy = dummy.next.next</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> swapPairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> ListNode();<br>  dummy.next = head;<br>  <span class="hljs-keyword">const</span> res = dummy;<br>  <span class="hljs-keyword">while</span> (dummy &amp;&amp; dummy.next &amp;&amp; dummy.next.next) &#123;<br>    <span class="hljs-keyword">let</span> first = dummy.next;<br>    <span class="hljs-keyword">let</span> second = dummy.next.next;<br>    dummy.next = second;<br>    first.next = second.next;<br>    second.next = first;<br>    dummy = dummy.next.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月12日</title>
    <link href="/2020/10/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8812%E6%97%A5/"/>
    <url>/2020/10/12/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt530. 二叉搜索树的最小绝对差</p><span id="more"></span><h1 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。<br><strong>示例：</strong><br><strong>输入：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>   <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span><br>   /<br>  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong><br>1<br><strong>解释：</strong><br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。<br><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li><li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="数组做法"><a href="#数组做法" class="headerlink" title="数组做法"></a>数组做法</h4><p>考点<strong>二叉搜索树的中序遍历是一个递增数组</strong>。得到遍历结果以后，再遍历判断当前值和上一值得绝对值大小，求出最小的差距两个值即可。</p><h4 id="遍历时求出"><a href="#遍历时求出" class="headerlink" title="遍历时求出"></a>遍历时求出</h4><p>相比于上一种方式不需要一个数组来储存中序遍历结果。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="数组做法-1"><a href="#数组做法-1" class="headerlink" title="数组做法"></a>数组做法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getMinimumDifference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    visit(node.left);<br>    res.push(node.val);<br>    visit(node.right);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">if</span> (res.length == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(res[<span class="hljs-number">0</span>] - res[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Math</span>.abs(res[<span class="hljs-number">0</span>] - res[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; res.length; i++) &#123;<br>    min = <span class="hljs-built_in">Math</span>.min(min, <span class="hljs-built_in">Math</span>.abs(res[i] - res[i - <span class="hljs-number">1</span>]));<br>  &#125;<br>  <span class="hljs-keyword">return</span> min;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="遍历时求出-1"><a href="#遍历时求出-1" class="headerlink" title="遍历时求出"></a>遍历时求出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getMinimumDifference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;<br>  <span class="hljs-keyword">let</span> preNode = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> inorder = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    inorder(node.left);<br>    <span class="hljs-keyword">if</span> (preNode) &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.abs(node.val - preNode.val), min);<br>    &#125;<br>    preNode = node;<br>    inorder(node.right);<br>  &#125;;<br>  inorder(root);<br>  <span class="hljs-keyword">return</span> min;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月11日</title>
    <link href="/2020/10/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8811%E6%97%A5/"/>
    <url>/2020/10/11/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt416. 分割等和子集,动态规划</p><span id="more"></span><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]<br>输出: true<br>解释: 数组可以分割成 [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>] 和 [<span class="hljs-number">11</span>].<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1, 2, 3, 5]</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 数组不能分割成两个元素和相等的子集.</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="动态规划-二维矩阵"><a href="#动态规划-二维矩阵" class="headerlink" title="动态规划-二维矩阵"></a>动态规划-二维矩阵</h4><p>具体过程可以参考官方题解<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">分割等和子集</a></p><ol><li>如果数组长度小于等于 1，直接返回 false</li><li>求数组的和及数组内元素的最大值，求和完毕，求出 target=sum/2，<strong>将问题转化为求数组中是否存在一个子集的和为 target</strong><ol><li>如果 target 不能整除 2，则不存在结果，返回 false</li><li>如果 target 比数组内元素的最大值小，则不存在结果，返回 false</li></ol></li><li>设置一个二维矩阵，用于动态规划，问题现在变成了<strong>0-1 背包问题</strong>，横坐标为 target 值，纵坐标为原数组下标的取值范围（可以为 0 个）<ol><li>首先将第一列，即 target=0，不管哪一行都可以取 0 个得到 target=0，所以第一列都设为 true</li><li>对第一行来说，即只有 nums[0]这一个元素，target 只能取到 0 或者 nums[0]本身，所以将<code>dp[0][nums[0]]</code>设为 true</li><li>遍历剩余的行及元素，从第二行开始，相当于背包问题添加了新的物品再来判断情况，及原数组的第二个元素，之后的每行都设当前的元素为<code>num=nums[i]</code>，再对每一列 j，即能否取到当前列的值进行判断：<ol><li>如果 num&gt;j，则说明不能取当前的元素，能否取到当前 j 的值，只看前一行对应的位置的值，直接令 <code>dp[i][j]= dp[i-1][j]</code>即可。</li><li>如果 num&lt;=j，这说明可以取到当前的元素，能否取到当前 j 的值，取决于<strong>前一行对应的位置是否可取</strong>或者<strong>取了当前数值以后，剩下的值在前一行是否可取</strong>，所以对应的表达式为 <code>dp[i][j]= dp[i-1][j] || dp[i-1][j-num]</code></li></ol></li></ol></li><li>dp 矩阵生成完毕以后，直接返回矩阵右下角的值即可，右下角的值即意味着转化后的问题<strong>数组中是否存在一个子集的和为 target</strong></li></ol><h4 id="动态规划-一维矩阵优化"><a href="#动态规划-一维矩阵优化" class="headerlink" title="动态规划-一维矩阵优化"></a>动态规划-一维矩阵优化</h4><p>具体过程可以参考官方题解<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">分割等和子集</a></p><ol><li>如果数组长度小于等于 1，直接返回 false</li><li>求数组的和及数组内元素的最大值，求和完毕，求出 target=sum/2，<strong>将问题转化为求数组中是否存在一个子集的和为 target</strong><ol><li>如果 target 不能整除 2，则不存在结果，返回 false</li><li>如果 target 比数组内元素的最大值小，则不存在结果，返回 false</li></ol></li><li>由之前可以看到，当前行的情况只取决于上一行，所以可以对矩阵进行优化，简化为一维矩阵，从尾部开始判断，就不会产生影响<ol><li>对于任何元素都可取 0 个令 target=0，所以先令<code>dp[0]=true</code></li><li>遍历每个元素，对于每个元素来说，<strong>都从 dp 的最后一个开始判断，到当前元素的值为止即可，小于当前元素的值是不会发生变化的</strong></li></ol></li><li>dp 矩阵生成完毕以后，直接返回矩阵最后一个元素的值即可</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="动态规划-二维矩阵-1"><a href="#动态规划-二维矩阵-1" class="headerlink" title="动态规划-二维矩阵"></a>动态规划-二维矩阵</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canPartition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> sum = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    max = <span class="hljs-built_in">Math</span>.max(max, b);<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> || max &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length)<br>    .fill(<span class="hljs-number">0</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(target).fill(<span class="hljs-literal">false</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> num = nums[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>      <span class="hljs-keyword">if</span> (num &gt; j) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>      <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - num];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>][target];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="动态规划-一维矩阵优化-1"><a href="#动态规划-一维矩阵优化-1" class="headerlink" title="动态规划-一维矩阵优化"></a>动态规划-一维矩阵优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canPartition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> sum = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    max = <span class="hljs-built_in">Math</span>.max(max, b);<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> || max &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(target + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);<br>  dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> num = nums[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= num; j--) &#123;<br>      dp[j] = dp[j] || dp[j - num];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[target];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth2.0规范简介</title>
    <link href="/2020/10/10/yuque/OAuth2.0%E8%A7%84%E8%8C%83%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/10/10/yuque/OAuth2.0%E8%A7%84%E8%8C%83%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://blog.csdn.net/chenleiking/article/details/80412500">https://blog.csdn.net/chenleiking/article/details/80412500</a></p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>一个简单的例子来说明 oauth 是什么：<br>现在很多网站在登录时可以选择使用第三方账号登陆，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602213218406-30441197-468c-467f-9244-4086e3f5a9f3.png#align=left&display=inline&height=2278&margin=%5Bobject%20Object%5D&originHeight=2278&originWidth=3584&size=0&status=done&style=none&width=3584"><br>你可以选择一个现有的账号来登了，比如 GitHub。然后就会跳转到 GitHub 的登陆界面，要求你输入账号密码登陆 GitHub，像这样：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602213218363-60acdb9f-7791-4657-a2f6-c6416eae6996.png#align=left&display=inline&height=2278&margin=%5Bobject%20Object%5D&originHeight=2278&originWidth=3584&size=0&status=done&style=none&width=3584"><br>当你登陆 GitHub 之后，会提示你：之前的网站需要访问你的信息，需要为之授权，像这样：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602213218364-8f21bd2d-fe16-4044-920a-1ac67226225f.png#align=left&display=inline&height=2278&margin=%5Bobject%20Object%5D&originHeight=2278&originWidth=3584&size=0&status=done&style=none&width=3584"><br>一旦你同意授权之后，就可以自动跳转到博客，并且使用 GitHub 账号登陆博客。<br>这是一个典型的 OAuth 认证授权过程，在这个过程中，涉及到以下角色：</p><ul><li>资源所有者：GitHub 账号所有者，也就是我</li><li>第三方应用：CSDN 博客服务</li><li>授权服务器：GitHub 服务</li><li>资源服务器：GitHub 服务，这里的授权服务器和资源服务器是同一个，但这并不是必须的</li><li>代理客户端：浏览器</li></ul><p>整个认证授权过程中，你并没有向 CSDN 提供你的 GitHub 密码，而是在 GitHub 上为 CSDN 授予访问你在 GitHub 上的资源（Account、Public data）的访问权限。你可以在所有支持 GitHub 账号登陆的网站上使用 GitHub 授权登陆，而这些第三方网站也可以根据你的授权范围访问你在 GitHub 上的资源。如果某天你不希望这些第三方网站中的一些继续访问你在 GitHub 上的资源，你可以移除对应的授权，同时不会对其他第三方网站产生影响：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602213218412-8f10d368-e565-4415-bccd-6c62318a2fff.png#align=left&display=inline&height=2278&margin=%5Bobject%20Object%5D&originHeight=2278&originWidth=3584&size=0&status=done&style=none&width=3584"></p><h2 id="2、授权流程"><a href="#2、授权流程" class="headerlink" title="2、授权流程"></a>2、授权流程</h2><p>OAuth2.0 定义了四种授权许可类型，分别是：授权码、隐式许可、资源所有者密码凭据和客户端凭据。这里仅介绍授权码类型。授权码类型是功能最完整、流程最严密的授权模式，简化流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602213218400-d38802f4-942d-423d-a59c-e05f3bb08f1a.png#align=left&display=inline&height=1144&margin=%5Bobject%20Object%5D&originHeight=1144&originWidth=1752&size=0&status=done&style=none&width=1752"></p><ul><li>用户通过浏览器访问互联网网站，比如 CSDN</li><li>在浏览器输入 CSDN 地址，打开登陆节点，准备通过 GitHub 账号登陆</li><li>CSDN 给浏览器返回 GitHub 授权地址，授权地址参数范围：<ul><li>response_type：必选项，常量 <code>code</code></li><li>client_id：必选项，客户端注册时参数的客户端唯一标识符</li><li>redirect_uri：可选性，授权成功后的跳转地址</li><li>scope：可选项，授权范围，授权服务器定义的字符串常量，多个值使用空格分隔</li><li>state：推荐项，用于维护请求和回调之间的状态的不透明的值，可用于防止 CSRF 攻击</li></ul></li><li>浏览器根据 CSDN 的响应内容，跳转到 GitHub 授权地址，完成：登陆、授权、返回<ul><li>登陆：用户输入凭据登陆 GitHub</li><li>授权：通常包括资源范围、有效时限等（比如：访问 QQ 空间、发布状态等）</li><li>返回：在上一步的 redirect_uri 上最佳 code 和 state 参数后返回浏览器</li><li>code：根据用户授权参数到授权码</li><li>state：上一步的 state 原样返回</li></ul></li><li>浏览器根据 GitHub 的响应内容，跳转到 CSDN 服务端，跳转地址中包括 code 和 state</li><li>CSDN 服务端获取 URL 中的 code，然后 CSDN 服务端访问 GitHub 服务端，请求参数范围：<ul><li>grant_type：必选项，常量 <code>authorization_code</code></li><li>code：必选项，GitHub 返回的 code</li><li>redirect_uri：必选项，必须和之前的 redirect_uri 完全一致</li><li>client_id：必选项，通常 CSDN 会和 GitHub 协商（注册），GitHub 给 CSDN 一个唯一标识符</li><li>client_secret：可选项，GitHub 以此来验证 CSDN 的真实性</li></ul></li><li>GitHub 服务端验证成功后响应 CSDN 服务端，响应内容包括：<ul><li>access_token：必选项，授权服务器颁发的访问令牌，CSDN 凭此访问资源</li><li>token_type：必选项，指令牌类型，大小写敏感</li><li>expires_in：推荐项，令牌有效期，单位：秒</li><li>refresh_token：必选项，access_token 过期后从新获取新值时的凭据，access_token 的有效期可能比 expires_in 短</li></ul></li><li>CSDN 服务端使用 access_token 向资源服务器（这里还是 GitHub）发出资源访问请求</li><li>资源服务器验证 access_token 是否合法（过期、超范围访问等），响应请求</li><li>CSDN 向浏览器响应资源访问成功（这里是使用 GitHub 账号登陆成功，有可能还会获得用户头像等公开信息）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月10日</title>
    <link href="/2020/10/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8810%E6%97%A5/"/>
    <url>/2020/10/10/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt3. 无重复字符的最长子串、滑动窗口、回溯算法</p><span id="more"></span><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串  **的长度。<br>**示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="借助-map-的回溯"><a href="#借助-map-的回溯" class="headerlink" title="借助 map 的回溯"></a>借助 map 的回溯</h4><p>设置一个临时数组存储结果，设置一个 map 存储字符及其下标。遍历字符串，每次遍历都要判断 temp 的 size 是不是比 max 的最大值大，大的话更新 max。如果 temp 中不存在该字符，加入 map。如果存在，将 i 设置为 map 中对应字符的下标加一，将 temp 清空。</p><h4 id="滑动窗口及-set"><a href="#滑动窗口及-set" class="headerlink" title="滑动窗口及 set"></a>滑动窗口及 set</h4><p>设置滑动窗口的左右边界、窗口最大尺寸记录字段 max、temp Set 记录非重复的子串。<br>以<code>abcabcbb</code>为例<br>以 <strong>(a)bcabcbb</strong> 开始的最长字符串为** (abc)abcbb**<br>以 <strong>a(b)cabcbb</strong> 开始的最长字符串为** a(bca)bcbb**<br>以 <strong>ab(c)abcbb</strong> 开始的最长字符串为** ab(cab)cbb**<br>以 <strong>abc(a)bcbb</strong> 开始的最长字符串为** abc(abc)bb**<br>以 <strong>abca(b)cbb</strong> 开始的最长字符串为** abca(bc)bb**<br>以 <strong>abcab(c)bb</strong> 开始的最长字符串为** abcab(cb)b**<br>以 <strong>abcabc(b)b</strong> 开始的最长字符串为** abcabc(b)b**<br>以 <strong>abcabcb(b)</strong> 开始的最长字符串为** abcabcb(b)**<br><strong>算法过程如下：</strong></p><ol><li>每次循环如果非第一个字符，都将 temp 中的当前下标的上一个字符删除。如：指向 a 求得 temp 为 abc，下一次循环指向 b，删除 temp 中的 a 得到 temp 为 bc。</li><li>如果 right 小于字符串长度，且 right 指向的字符不在 temp 中，就不断增加右边界的值。直到出现重复字符串或者到达字符串长度。</li><li>判断 temp 的 size 是不是比 max 的最大值大，大的话更新 max。</li></ol><p>相较上一个方法，可以减少很多不必要的设值、设空、判断最大值过程。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="借助-map-的回溯-1"><a href="#借助-map-的回溯-1" class="headerlink" title="借助 map 的回溯"></a>借助 map 的回溯</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (temp.has(s[i])) &#123;<br>      i = temp.get(s[i]) + <span class="hljs-number">1</span>;<br>      temp.clear();<br>    &#125;<br>    temp.set(s[i], i);<br>    max = <span class="hljs-built_in">Math</span>.max(temp.size, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="滑动窗口及-set-1"><a href="#滑动窗口及-set-1" class="headerlink" title="滑动窗口及 set"></a>滑动窗口及 set</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>,<br>    left = <span class="hljs-number">0</span>,<br>    right = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i !== <span class="hljs-number">0</span>) temp.delete(s[i - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span> (right &lt; s.length &amp;&amp; !temp.has(s[right])) &#123;<br>      temp.add(s[right]);<br>      right++;<br>    &#125;<br>    max = <span class="hljs-built_in">Math</span>.max(temp.size, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>回溯算法</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Egg实现基于JWT的RESTful API</title>
    <link href="/2020/10/09/yuque/%E5%9F%BA%E4%BA%8EEgg%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJWT%E7%9A%84RESTful%20API/"/>
    <url>/2020/10/09/yuque/%E5%9F%BA%E4%BA%8EEgg%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJWT%E7%9A%84RESTful%20API/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将基于 Egg.js，使用 Typescript，实现基于 JWT 的 RESTful API。使用到的插件有：<code>egg-mysql</code>、<code>egg-sequelize</code>、<code>egg-validate-joi</code>、<code>egg-jwt</code>、<code>egg-cors</code>、<code>egg-router-plus</code>、<code>egg-swagger-doc</code><br>项目源码请访问：<a href="https://github.com/HaisawaEtsu/egg-test-demo">https://github.com/HaisawaEtsu/egg-test-demo</a></p><h2 id="相关插件配置"><a href="#相关插件配置" class="headerlink" title="相关插件配置"></a>相关插件配置</h2><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>相关 ts 目录规范、插件安装及配置教程请参考官网及 npmjs 文档：<br><a href="https://eggjs.org/zh-cn/tutorials/typescript.html">egg-typescript</a><br><a href="https://eggjs.org/zh-cn/tutorials/mysql.html">egg-mysql</a><br><a href="https://eggjs.org/zh-cn/tutorials/sequelize.html">egg-sequelize</a><br><a href="https://eggjs.org/zh-cn/tutorials/restful.html">RESTFul API</a><br><a href="https://www.npmjs.com/package/egg-validate-joi">egg-validate-joi</a><br><a href="https://www.npmjs.com/package/egg-router-plus">egg-router-plus</a><br><a href="https://www.npmjs.com/package/egg-swagger-doc">egg-swagger-doc</a></p><h3 id="egg-jwt"><a href="#egg-jwt" class="headerlink" title="egg-jwt"></a>egg-jwt</h3><p>1.使用 npm 安装<code>egg-cors</code>及<code>egg-jwt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install egg-cors egg-jwt --save<br></code></pre></td></tr></table></figure><p>2.<code>config/plugin.ts</code>中添加相应的配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// config/plugin.ts</span><br>...<br>  <span class="hljs-attr">jwt</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&#x27;egg-jwt&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&#x27;egg-cors&#x27;</span>,<br>  &#125;,<br>...<br></code></pre></td></tr></table></figure><p>3. <code>config/config.default.ts</code>  添加相应的配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// config/config.default.ts</span><br>...<br>config.jwt = &#123;<br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;r1Wp3kxj3TmaUrruPwyZzNgkaxepMHyo&#x27;</span>, <span class="hljs-comment">// 自定义token secret</span><br>&#125;;<br><br>config.security = &#123;<br>  <span class="hljs-attr">csrf</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">ignoreJSON</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">domainWhiteList</span>: [ <span class="hljs-string">&#x27;http://localhost&#x27;</span> ], <span class="hljs-comment">// 接口白名单</span><br>&#125;;<br>config.cors = &#123;<br>  <span class="hljs-attr">origin</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>  <span class="hljs-attr">allowMethods</span>: <span class="hljs-string">&#x27;GET,HEAD,PUT,POST,DELETE,PATCH&#x27;</span>,<br>&#125;;<br>...<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>config/plugin.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// config/plugin.ts</span><br><span class="hljs-keyword">import</span> &#123; EggPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;egg&quot;</span>;<br><br><span class="hljs-keyword">const</span> plugin: EggPlugin = &#123;<br>  <span class="hljs-attr">static</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">mysql</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-mysql&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">sequelize</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-sequelize&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">validate</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-validate&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">jwt</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-jwt&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-cors&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">routerPlus</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-router-plus&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">swaggerdoc</span>: &#123;<br>    <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">package</span>: <span class="hljs-string">&quot;egg-swagger-doc&quot;</span>,<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> plugin;<br></code></pre></td></tr></table></figure><h2 id="路由及路由映射建立"><a href="#路由及路由映射建立" class="headerlink" title="路由及路由映射建立"></a>路由及路由映射建立</h2><p>使用<a href="https://github.com/eggjs/egg-router-plus">egg-router-plus</a>进行路由拆分，这个插件会自动读取<code>app/router</code>下的分路由 ts 文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// app/router/authorization.ts</span><br><span class="hljs-keyword">import</span> &#123; Application &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;egg&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app: Application</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; controller, router &#125; = app;<br>  router.resources(<br>    <span class="hljs-string">&quot;authorization&quot;</span>,<br>    <span class="hljs-string">&quot;/api/v1/authorization&quot;</span>,<br>    controller.authorization<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>再需要权限验证的路由，引入 jwt 中间件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// app/router/user.ts</span><br><span class="hljs-keyword">import</span> &#123; Application &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;egg&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app: Application</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; controller, router, jwt &#125; = app;<br>  router.resources(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;/api/v1/user&quot;</span>, jwt, controller.user);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="登录鉴权接口的实现"><a href="#登录鉴权接口的实现" class="headerlink" title="登录鉴权接口的实现"></a>登录鉴权接口的实现</h1><h2 id="Controller-及-Service-的编写"><a href="#Controller-及-Service-的编写" class="headerlink" title="Controller 及 Service 的编写"></a>Controller 及 Service 的编写</h2><p>本项目中同时引入了<a href="https://www.npmjs.com/package/egg-swagger-doc">egg-swagger-doc</a>建立 api 接口文档，具体前置操作可以查看文档。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>使用<code>egg-swagger-doc</code>，可以使用 jsDoc 的形式，结合<code>egg-swagger-doc</code>在<code>contract</code>中定义的规则，可以在页面中自动生成接口文档相关信息。<br>同时使用了<code>/extend/helper.js/</code>统一封装了正确及错误返回方法，使用<code>ctx.helper.success</code>以及<code>ctx.helper.fail</code>来调用，具体实现请查看源码。<br>使用了<code>egg-validate-joi</code> 进行参数合法校验，如果参数不合法使用<code>ctx.helper.validateError</code>返回错误结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Controller &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;egg&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Controller <span class="hljs-variable">authorization</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@summary </span>用户登录</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>用户登录，获取用户token</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@router </span>post /api/v1/authorization</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@request </span>body authorizationUserRequest *body</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@response </span>200 baseResponse 用户token</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx, app &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> &#123; loginName, password &#125; = ctx.request.body;<br>    <span class="hljs-keyword">const</span> &#123; Joi &#125; = app;<br>    <span class="hljs-keyword">const</span> errors = ctx.validateJoi(&#123;<br>      <span class="hljs-attr">body</span>: &#123;<br>        <span class="hljs-attr">loginName</span>: Joi.string().required(),<br>        <span class="hljs-attr">password</span>: Joi.string().required(),<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (errors) &#123;<br>      ctx.helper.validateError(ctx, errors);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断用户名密码是否正确</span><br>    <span class="hljs-keyword">const</span> validUser = <span class="hljs-keyword">await</span> ctx.service.user.validUser(loginName, password);<br>    <span class="hljs-keyword">if</span> (validUser.isValid) &#123;<br>      <span class="hljs-keyword">const</span> &#123; user &#125; = validUser;<br>      <span class="hljs-comment">// 生成用户token</span><br>      <span class="hljs-keyword">const</span> token = app.jwt.sign(<br>        &#123;<br>          <span class="hljs-attr">username</span>: user.username,<br>          <span class="hljs-attr">u_id</span>: user.u_id,<br>        &#125;,<br>        app.config.jwt.secret<br>      );<br><br>      <span class="hljs-comment">// 返回token</span><br>      ctx.helper.success(ctx, <span class="hljs-string">&quot;ok&quot;</span>, &#123; token &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Service &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;egg&quot;</span>;<br><span class="hljs-keyword">import</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;crypto&quot;</span>);<br><br><span class="hljs-keyword">type</span> validUser = &#123;<br>  <span class="hljs-attr">isValid</span>: <span class="hljs-built_in">boolean</span>;<br>  user?: <span class="hljs-built_in">any</span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> validUser(<br>    loginName: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span><br>  ): <span class="hljs-built_in">Promise</span>&lt;validUser&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.findByLoginName(loginName);<br><br>    <span class="hljs-keyword">if</span> (user) &#123;<br>      <span class="hljs-keyword">const</span> pwd = crypto.createHash(<span class="hljs-string">&quot;md5&quot;</span>).update(password).digest(<span class="hljs-string">&quot;hex&quot;</span>);<br>      <span class="hljs-keyword">const</span> u = user.get();<br>      <span class="hljs-keyword">if</span> (u.password === pwd) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">isValid</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">user</span>: u,<br>        &#125;;<br>      &#125;<br>      ctx.helper.fail(ctx, &#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;密码错误&quot;</span>,<br>      &#125;);<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,<br>      &#125;;<br>    &#125;<br>    ctx.helper.fail(ctx, &#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;用户名不存在&quot;</span>,<br>    &#125;);<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">findByLoginName</span>(<span class="hljs-params">loginName: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> ctx.model.User.findOne(&#123;<br>      <span class="hljs-attr">where</span>: &#123;<br>        <span class="hljs-attr">login_name</span>: loginName,<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (res) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">findByUsername</span>(<span class="hljs-params">username: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> ctx.model.User.findOne(&#123;<br>      <span class="hljs-attr">where</span>: &#123;<br>        username,<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (res) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-swagger-进行测试"><a href="#使用-swagger-进行测试" class="headerlink" title="使用 swagger 进行测试"></a>使用 swagger 进行测试</h2><p>默认地址为<a href="http://localhost:7001/swagger-ui.html">http://localhost:7001/swagger-ui.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月9日</title>
    <link href="/2020/10/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%889%E6%97%A5/"/>
    <url>/2020/10/09/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt141. 环形链表、142. 环形链表 II，快慢指针</p><span id="more"></span><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>进阶：</strong><br>你能用 _O(1)_（即，常量）内存解决此问题吗？</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602205279018-4189e883-e215-4533-b43a-89fd20010200.png#align=left&display=inline&height=97&margin=%5Bobject%20Object%5D&originHeight=171&originWidth=531&size=0&status=done&style=none&width=300"><br><strong>输入：</strong>head = [3,2,0,-4], pos = 1<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例  2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602205279017-b7f72048-b340-4bc4-9125-5b8fee73cb06.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=201&size=0&status=done&style=none&width=141"><br><strong>输入：</strong>head = [1,2], pos = 0<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p><p><strong>示例 3：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602205279209-f7faceb6-a860-419b-a145-d124058b5ba3.png#align=left&display=inline&height=45&margin=%5Bobject%20Object%5D&originHeight=65&originWidth=65&size=0&status=done&style=none&width=45"><br><strong>输入：</strong>head = [1], pos = -1<br><strong>输出：</strong>false<br><strong>解释：</strong>链表中没有环。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 10]</code></li><li><code>-10 &lt;= Node.val &lt;= 10</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用快慢指针，如果快指针指向的节点和慢指针相同则存在环，若快指针已到链表结尾，不存在环</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> fast = head,<br>    slow = head;<br>  <span class="hljs-keyword">while</span> (fast) &#123;<br>    <span class="hljs-keyword">if</span> (fast &amp;&amp; fast.next) fast = fast.next.next;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    slow = slow.next;<br>    <span class="hljs-keyword">if</span> (fast === slow) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="142-环形链表-II（求环形链表的交点）"><a href="#142-环形链表-II（求环形链表的交点）" class="headerlink" title="142. 环形链表 II（求环形链表的交点）"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>（求环形链表的交点）</h1><p>给定一个链表，返回链表开始入环的第一个节点。  如果链表无环，则返回 <code>null</code>。<br>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<br><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong><br><strong>输入：</strong>head = [3,2,0,-4], pos = 1<br><strong>输出：</strong>tail connects to node index 1<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602289623952-054a84fd-180e-4b39-9bb8-9aa70f392b8e.png#align=left&display=inline&height=97&margin=%5Bobject%20Object%5D&originHeight=171&originWidth=531&size=0&status=done&style=none&width=300"><br><strong>示例  2：</strong><br><strong>输入：</strong>head = [1,2], pos = 0<br><strong>输出：</strong>tail connects to node index 0<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602289623967-27757892-2133-4df0-9514-5bded44814b2.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=201&size=0&status=done&style=none&width=141"><br><strong>示例 3：</strong><br><strong>输入：</strong>head = [1], pos = -1<br><strong>输出：</strong>no cycle<br><strong>解释：</strong>链表中没有环。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602289623933-3bf59bf1-c5a9-44d8-b087-d42ecd690981.png#align=left&display=inline&height=45&margin=%5Bobject%20Object%5D&originHeight=65&originWidth=65&size=0&status=done&style=none&width=45"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用快慢指针，可以得到以下逻辑：</p><ol><li>慢指针走的路程为：a+c</li><li>快指针走的路程为：两倍慢指针的路程 = a 的长度加 k(k&gt;=1)圈的环加 c 的长度，等价于 2(a+c) = a+kb + c =&gt; a+c = kb =&gt; a+c = b =&gt; b-c = a</li><li>由 b-c = a 可以推出，当相交时让另一个指针指向头结点再走 a 的路程可以刚好达到环形链表的交点。</li><li>可以令慢指针指向头结点，快指针指向不变，两个指针速度相同，等再相遇时，就刚好处于交点处</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1602206286757-5233f80a-ac26-4468-8c96-d5d384715988.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&name=image.png&originHeight=565&originWidth=651&size=14640&status=done&style=none&width=325.5" alt="image.png"></p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> fast = head,<br>    slow = head;<br>  <span class="hljs-keyword">while</span> (fast) &#123;<br>    <span class="hljs-keyword">if</span> (fast &amp;&amp; fast.next) fast = fast.next.next;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    slow = slow.next;<br>    <span class="hljs-keyword">if</span> (fast === slow) &#123;<br>      <span class="hljs-keyword">let</span> slow = head;<br>      <span class="hljs-keyword">while</span> (slow !== fast) &#123;<br>        slow = slow.next;<br>        fast = fast.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月8日</title>
    <link href="/2020/10/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%888%E6%97%A5/"/>
    <url>/2020/10/08/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt344. 反转字符串</p><span id="more"></span><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。<br>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组<strong>、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符。<br> **示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：[<span class="hljs-comment">&quot;H&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;h&quot;</span>]<br>输出：[<span class="hljs-comment">&quot;h&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;H&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>左右指针，不断交换即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[]&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = s.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    [s[left], s[right]] = [s[right], s[left]];<br>    left++;<br>    right--;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月7日</title>
    <link href="/2020/10/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%887%E6%97%A5/"/>
    <url>/2020/10/07/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt75. 颜色分类</p><span id="more"></span><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色，一共 <em>n *个元素的数组，<code>原地</code>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>*</em>注意:**<br>不能使用代码库中的排序函数来解决这道题。<br><strong>示例:</strong><br><strong>输入:</strong> [2,0,2,1,1,0]<br><strong>输出:</strong> [0,0,1,1,2,2]<br><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出 0、1 和 2 元素的个数，然后按照 0、1、2 的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="计数两次遍历"><a href="#计数两次遍历" class="headerlink" title="计数两次遍历"></a>计数两次遍历</h4><p>使用一个数组记录颜色出现个数，再重新修改</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>使用左右双指针，将 0 放到前面，将 2 放到后面即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="计数两次遍历-1"><a href="#计数两次遍历-1" class="headerlink" title="计数两次遍历"></a>计数两次遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> colorCount = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>    colorCount[nums[i]]++;<br>  &#125;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">while</span> (colorCount[count] === <span class="hljs-number">0</span>) &#123;<br>      count++;<br>    &#125;<br>    nums[i] = count;<br>    colorCount[count]--;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,<br>    right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= right; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">0</span>) &#123;<br>      [nums[left], nums[i]] = [nums[i], nums[left]];<br>      left++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">2</span>) &#123;<br>      [nums[right], nums[i]] = [nums[i], nums[right]];<br>      right--;<br>      <span class="hljs-comment">//i--的原因是，可能将2交换回来，需要重新判断</span><br>      i--;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月6日</title>
    <link href="/2020/10/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%886%E6%97%A5/"/>
    <url>/2020/10/06/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt19. 删除链表的倒数第 N 个节点、快慢指针</p><span id="more"></span><h1 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19. 删除链表的倒数第 N 个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个节点</a></h1><p>给定一个链表，删除链表的倒数第 <em>n *个节点，并且返回链表的头结点。<br>*</em>示例：**</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 n = <span class="hljs-number">2.</span><br>当删除了倒数第二个节点后，链表变为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong><br>给定的 <em>n</em> 保证是有效的。<br><strong>进阶：</strong><br>你能尝试使用一趟扫描实现吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="反向链表"><a href="#反向链表" class="headerlink" title="反向链表"></a>反向链表</h4><p>得到链表的反向链表值数组，再重新生成链表即可，其实上不符合题目删除的要求</p><h4 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h4><p>一次遍历得到链表长度，第二次遍历的时候删除，使用一个哑结点处理删除首节点的问题，删除点的下标为<code>length + 1 - n</code></p><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>使用一个哑结点处理删除首节点的问题，先令快指针走 n+1 步，再令快慢指针同时走，当快指针指向 null 时，说明到达链表尾部，将慢指针的 next 指向下下个节点即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="反向链表-1"><a href="#反向链表-1" class="headerlink" title="反向链表"></a>反向链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> list = [];<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    list.push(head.val);<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> deleteIndex = list.length + <span class="hljs-number">1</span> - n;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();<br>  <span class="hljs-keyword">let</span> temp = res;<br>  <span class="hljs-keyword">while</span> (list.length) &#123;<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> ListNode(list.shift());<br>    <span class="hljs-keyword">if</span> (++count !== deleteIndex) &#123;<br>      temp.next = node;<br>      temp = temp.next;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二次遍历"><a href="#二次遍历" class="headerlink" title="二次遍历"></a>二次遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();<br>  res.next = head;<br>  <span class="hljs-keyword">let</span> temp = head;<br>  <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (temp) &#123;<br>    length++;<br>    temp = temp.next;<br>  &#125;<br>  <span class="hljs-keyword">const</span> deleteIndex = length + <span class="hljs-number">1</span> - n;<br>  length = <span class="hljs-number">0</span>;<br>  temp = res;<br>  <span class="hljs-keyword">while</span> (++length !== deleteIndex &amp;&amp; temp) &#123;<br>    temp = temp.next;<br>  &#125;<br>  temp.next = temp.next.next;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();<br>  res.next = head;<br>  <span class="hljs-keyword">let</span> slow = res;<br>  <span class="hljs-keyword">let</span> fast = res;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>    fast = fast.next;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (fast) &#123;<br>    fast = fast.next;<br>    slow = slow.next;<br>  &#125;<br>  slow.next = slow.next.next;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月5日</title>
    <link href="/2020/10/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%885%E6%97%A5/"/>
    <url>/2020/10/05/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt15. 三数之和、18. 四数之和</p><span id="more"></span><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 _a + b + c = _0 ？请你找出所有满足条件且不重复的三元组。<br><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，<br>满足要求的三元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用排序加双指针解决。</p><ol><li>将数组由小到大排序。</li><li>首先判断第一个元素是否小于 0，<strong>如果小于 0 则不存在解</strong>。</li><li>再判断数组是否同符号，即第一个小于等于 0，最后一个大于等于 0，<strong>如果同符号，则不存在解</strong>。</li><li>进行循环，设置左指针为当前指针加一，右指针为数组最后一个数，<strong>如果当前的数和上一个数相等，跳过该数，避免重复</strong>。</li><li>while 循环，计算当前指针，左指针，右指针的和：<ol><li>等于 0，加入结果数组，并将左、右指针分别向右移、左移，直到指向下一个不同的数</li><li>大于 0，将右指针向左移，直到指向下一个不同的数</li><li>小于 0，将左指针向右移，直到指向下一个不同的数</li><li>当左指针和右指针相遇时，跳出循环</li></ol></li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">0</span> &amp;&amp; nums[nums.length - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span> &amp;&amp; nums[i] &lt;= <span class="hljs-number">0</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">let</span> sum = nums[i] + nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) &#123;<br>          res.push([nums[i], nums[left], nums[right]]);<br>          <span class="hljs-keyword">while</span> (nums[left] === nums[++left] &amp;&amp; left &lt; right) &#123;&#125;<br>          <span class="hljs-keyword">while</span> (nums[right] === nums[--right] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">while</span> (nums[left] === nums[++left] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt; right) &#123;<br>          <span class="hljs-keyword">while</span> (nums[right] === nums[--right] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。<br><strong>注意：</strong><br>答案中不可以包含重复的四元组。<br><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[1, 0, -1, 0, -2, 2]</span>，和 target = 0。<br>满足要求的四元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1,  0, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2, -1, 1, 2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2,  0, 0, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将 4 数之和的问题转为 3 数之和，再采用 3 数之和的排序加双指针来解决。重点和难点是<strong>如何进行 4 数之和的减枝操作，避免超时</strong>。</p><ol><li>判断数组个数，小于 4 的话返回空数组。</li><li>将数组由小到大排序。</li><li>确认第一个数，<code>减枝过程</code>如下：<ol><li>如果当前的数和上一个数相等，跳过该数，避免重复</li><li>如果排序后<strong>前四个数之和大于 target</strong>，不存在结果，直接返回空数组</li><li>如果<strong>当前数和最后三个数之和小于 target</strong>，则中间不可能存在一个组合等于 target，跳过该数，求下一个数</li></ol></li><li>减枝后，则确定取该数为第一个数，确定新的<strong>newTarget</strong>值为<code>target - nums[i]</code>，j 为 i+1</li><li><strong>接下来的操作和求 3 数之和相同</strong>：进行循环，设置左指针为当前指针加一，右指针为数组最后一个数，<strong>如果当前的数和上一个数相等，跳过该数，避免重复</strong>。</li><li>while 循环，计算当前指针，左指针，右指针的和：<ol><li>等于 0，加入结果数组，并将左、右指针分别向右移、左移，直到指向下一个不同的数</li><li>大于 0，将右指针向左移，直到指向下一个不同的数</li><li>小于 0，将左指针向右移，直到指向下一个不同的数</li><li>当左指针和右指针相遇时，跳出循环</li></ol></li><li>进行循环，设置左指针为当前指针加一，右指针为数组最后一个数，<strong>如果当前的数和上一个数相等，跳过该数，避免重复</strong>。</li><li>while 循环，计算当前指针，左指针，右指针的和：<ol><li>等于 0，加入结果数组，并将左、右指针分别向右移、左移，直到指向下一个不同的数</li><li>大于 0，将右指针向左移，直到指向下一个不同的数</li><li>小于 0，将左指针向右移，直到指向下一个不同的数</li><li>当左指针和右指针相遇时，跳出循环</li></ol></li></ol><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fourSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> res;<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (<br>      nums[i] +<br>        nums[nums.length - <span class="hljs-number">3</span>] +<br>        nums[nums.length - <span class="hljs-number">2</span>] +<br>        nums[nums.length - <span class="hljs-number">1</span>] &lt;<br>      target<br>    )<br>      <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-keyword">const</span> newTarget = target - nums[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">let</span> sum = nums[j] + nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum === newTarget) &#123;<br>          res.push([nums[i], nums[j], nums[left], nums[right]]);<br>          <span class="hljs-keyword">while</span> (nums[left] === nums[++left] &amp;&amp; left &lt; right) &#123;&#125;<br>          <span class="hljs-keyword">while</span> (nums[right] === nums[--right] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; newTarget) &#123;<br>          <span class="hljs-keyword">while</span> (nums[left] === nums[++left] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; newTarget &amp;&amp; left &lt; right) &#123;<br>          <span class="hljs-keyword">while</span> (nums[right] === nums[--right] &amp;&amp; left &lt; right) &#123;&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月4日</title>
    <link href="/2020/10/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%884%E6%97%A5/"/>
    <url>/2020/10/04/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt2. 两数相加</p><span id="more"></span><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0  开头。<br><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模拟加法，链表版。使用一个 isAdd 判断是否进位即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> temp1 = l1;<br>  <span class="hljs-keyword">let</span> temp2 = l2;<br>  <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode();<br>  <span class="hljs-keyword">let</span> res = head;<br>  <span class="hljs-keyword">let</span> isAdd = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (temp1 || temp2) &#123;<br>    head.next = <span class="hljs-keyword">new</span> ListNode(<br>      (temp1 ? temp1.val : <span class="hljs-number">0</span>) + (temp2 ? temp2.val : <span class="hljs-number">0</span>) + (isAdd ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)<br>    );<br>    isAdd = <span class="hljs-literal">false</span>;<br>    head = head.next;<br>    <span class="hljs-keyword">if</span> (head.val &gt;= <span class="hljs-number">10</span>) &#123;<br>      isAdd = <span class="hljs-literal">true</span>;<br>      head.val = head.val % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (temp1) temp1 = temp1.next;<br>    <span class="hljs-keyword">if</span> (temp2) temp2 = temp2.next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!temp1 &amp;&amp; !temp2 &amp;&amp; isAdd) &#123;<br>    head.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月3日</title>
    <link href="/2020/10/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%883%E6%97%A5/"/>
    <url>/2020/10/03/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt1. 两数之和</p><span id="more"></span><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9<br>因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9<br>所以返回 <span class="hljs-comment">[0, 1]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>梦开始的地方，map 存所有数字，再循环遍历数组，map 里是否存在目标数字减去当前数字即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> numMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  nums.map(<span class="hljs-function">(<span class="hljs-params">num, i</span>) =&gt;</span> &#123;<br>    numMap.set(num, i);<br>  &#125;);<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (<br>    nums.some(<span class="hljs-function">(<span class="hljs-params">num, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> needNum = target - num;<br>      <span class="hljs-keyword">if</span> (numMap.has(needNum) &amp;&amp; numMap.get(needNum) !== index) &#123;<br>        result = [index, numMap.get(needNum)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;)<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的之字形层序遍历"><a href="#二叉树的之字形层序遍历" class="headerlink" title="二叉树的之字形层序遍历"></a>二叉树的之字形层序遍历</h1><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601726451458-f833d9b6-746e-4e2d-9b68-3075190ed09b.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&originHeight=289&originWidth=272&size=0&status=done&style=none&width=190"><br>该二叉树之字形层序遍历的结果是</p><blockquote><p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p></blockquote><p>示例 1<br><strong>输入</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<span class="hljs-number">1</span>,<span class="hljs-meta">#,2&#125;</span><br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在普通层次遍历上添加判断 res 数组中个数即可，如果是偶数则反向。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function TreeNode(x) &#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.left = null;</span><br><span class="hljs-comment"> *   this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>root TreeNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型二维数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zigzagLevelOrder</span>(<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  <span class="hljs-keyword">let</span> row = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    row = row.concat(queue.splice(<span class="hljs-number">0</span>, queue.length));<br>    <span class="hljs-keyword">const</span> temp = [];<br>    <span class="hljs-keyword">while</span> (row.length) &#123;<br>      <span class="hljs-keyword">const</span> node = row.shift();<br>      temp.unshift(node.val);<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (res.length % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      res.push(temp.reverse());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(temp);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">zigzagLevelOrder</span>: zigzagLevelOrder,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月2日</title>
    <link href="/2020/10/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%882%E6%97%A5/"/>
    <url>/2020/10/02/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt771. 宝石与石头<br>hello world!国庆快乐!</p><span id="more"></span><h1 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a><a href="https://leetcode-cn.com/problems/jewels-and-stones/">771. 宝石与石头</a></h1><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。<br><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。<br><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">J</span> = <span class="hljs-string">&quot;aA&quot;</span>, <span class="hljs-attr">S</span> = <span class="hljs-string">&quot;aAAbbbb&quot;</span><br>输出: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">J</span> = <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ZZ&quot;</span><br>输出: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有 50 个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>set 存储，计数即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">J</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numJewelsInStones = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">J, S</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(J);<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> S) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(arr)) count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年10月1日</title>
    <link href="/2020/10/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%881%E6%97%A5/"/>
    <url>/2020/10/01/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B410%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 35. 复杂链表的复制、深拷贝、哈希表</p><span id="more"></span><p>写前吐槽，希望十月不是 dp 月，今天的每日一题已放弃。</p><h1 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h1><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601548405761-41a04306-0ded-457f-b96f-2814617b2977.png#align=left&display=inline&height=386&margin=%5Bobject%20Object%5D&originHeight=386&originWidth=1900&size=0&status=done&style=none&width=1900"><br><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br><strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p><strong>示例 2：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601548405736-93da2215-dd9a-4a63-a592-35b80697ad17.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=1670&size=0&status=done&style=none&width=1670"><br><strong>输入：</strong>head = [[1,1],[2,1]]<br><strong>输出：</strong>[[1,1],[2,1]]</p><p><strong>示例 3：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601548405765-6d77768e-6b9a-4c68-b7cd-94d24c18487f.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&originHeight=330&originWidth=1890&size=0&status=done&style=none&width=1890"></strong><br><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]<br><strong>输出：</strong>[[3,null],[3,0],[3,null]]</p><p><strong>示例 4：</strong><br><strong>输入：</strong>head = []<br><strong>输出：</strong>[]<br><strong>解释：</strong>给定的链表为空（空指针），因此返回 null。</p><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>注意：</strong>本题与主站 138 题相同：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和 js 用递归手动实现深拷贝是一种思路，使用 weakmap 存储节点，避免重复递归。需要注意的是，这里 val 也不能直接赋值，应该也再递归调用，再判断是不是非对象类型，是的话直接返回。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, next, random) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.next = next;</span><br><span class="hljs-comment"> *    this.random = random;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> copyRandomList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<br>  <span class="hljs-keyword">const</span> deepCopy = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> node;<br>    <span class="hljs-keyword">if</span> (map.has(node)) <span class="hljs-keyword">return</span> map.get(node);<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> res = &#123;&#125;;<br>    map.set(node, res);<br>    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(node)) &#123;<br>      res[key] = deepCopy(node[key]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> deepCopy(head);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月30日</title>
    <link href="/2020/09/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8830%E6%97%A5/"/>
    <url>/2020/09/30/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt701. 二叉搜索树中的插入操作</p><span id="more"></span><h1 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。<br>  例如,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉搜索树:<br>        <span class="hljs-number">4</span><br>       / <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>   <span class="hljs-number">7</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>和 插入的值: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>你可以返回这个二叉搜索树:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">4</span><br>   /   \<br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> <span class="hljs-regexp">/ \   /</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>或者这个树也是有效的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">5</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想复杂了，认为要插入节点，同时保持平衡二叉树。该题简单递归设置即可，不断递归，直到要设值的点为 null，就可以插入值了。如果保持有序数组的平衡二叉树，需要中序遍历后获得数组，插入目标数组，再重新生成树。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> insertIntoBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    root = <span class="hljs-keyword">new</span> TreeNode(val);<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (root.val &gt; val) &#123;<br>    <span class="hljs-keyword">if</span> (root.left) &#123;<br>      insertIntoBST(root.left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      root.left = <span class="hljs-keyword">new</span> TreeNode(val);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (root.right) &#123;<br>      insertIntoBST(root.right, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      root.right = <span class="hljs-keyword">new</span> TreeNode(val);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月29日</title>
    <link href="/2020/09/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8829%E6%97%A5/"/>
    <url>/2020/09/29/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt145. 二叉树的后序遍历</p><span id="more"></span><h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h1><p>给定一个二叉树，返回它的 <em>后序  *遍历。<br>*</em>示例:**</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span><br>   1<br>    \<br>     2<br>    /<br>   3<br>输出: <span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>正常递归后序遍历即可</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">二叉树的后序遍历</a><br>如果有左子树，就先一直将左节点放入栈中，直到出现左子树为空。出栈一个元素，判断右子树是不是也为空：如果右子树不为空，将当前节点重新加入栈中，并将 root 指向右子树，重新进行以上过程；如果为空，则是叶子节点，将其加入结果数组，将 root 设为空，表示跳过向左遍历的过程；并将 prev 设为该节点，防止当前节点重复进入右子树。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    visit(root.left);<br>    visit(root.right);<br>    res.push(root.val);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  temp.push(root);<br>  root = root.left;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (root || temp.length) &#123;<br>    <span class="hljs-keyword">while</span> (root) &#123;<br>      temp.push(root);<br>      root = root.left;<br>    &#125;<br><br>    root = temp.pop();<br>    <span class="hljs-keyword">if</span> (!root.right || root.right === prev) &#123;<br>      res.push(root.val);<br>      prev = root;<br>      root = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      temp.push(root);<br>      root = root.right;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月28日</title>
    <link href="/2020/09/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8828%E6%97%A5/"/>
    <url>/2020/09/28/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt117. 填充每个节点的下一个右侧节点指针 II</p><span id="more"></span><h1 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h1><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。<br>初始状态下，所有  next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601255347755-5fb2fd0c-fcb8-4f3c-bdf8-f10598e6422a.png#align=left&display=inline&height=218&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=1058&size=0&status=done&style=none&width=640"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="队列-BFS"><a href="#队列-BFS" class="headerlink" title="队列 BFS"></a>队列 BFS</h4><p>常规 BFS，空间复杂度最大应该为满二叉树，最后一层占用队列长度应该为，<img src="https://cdn.nlark.com/yuque/__latex/1b751f591858d0d4ef2b56a2bf1384f4.svg#card=math&code=2%5E%7Bk%7D%20%3D%202%5E%7B%5Clog_%7B2%7D%28n%2B1%29-1%7D&height=20&width=116">，n 为节点数。<br>和普通层次遍历不同的是，在遍历当前层节点时，将当前节点的 next 指向下一个节点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="队列-BFS-1"><a href="#队列-BFS-1" class="headerlink" title="队列 BFS"></a>队列 BFS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><br><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><br><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><br><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><br><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> temp = [];<br>  temp.push(root);<br>  <span class="hljs-keyword">while</span> (temp.length) &#123;<br>    <span class="hljs-keyword">const</span> temp2 = temp.splice(<span class="hljs-number">0</span>, temp.length);<br>    <span class="hljs-keyword">while</span> (temp2.length) &#123;<br>      <span class="hljs-keyword">const</span> node = temp2.shift();<br>      node.next = temp2.length &gt; <span class="hljs-number">0</span> ? temp2[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (node &amp;&amp; node.left) temp.push(node.left);<br>      <span class="hljs-keyword">if</span> (node &amp;&amp; node.right) temp.push(node.right);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>队列</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月27日</title>
    <link href="/2020/09/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8827%E6%97%A5/"/>
    <url>/2020/09/27/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt235. 二叉搜索树的最近公共祖先</p><span id="more"></span><h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601169097743-72b94d35-a4d3-43a1-9911-cb3c3e6159ef.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=200&size=0&status=done&style=none&width=200"></p><p><strong>示例 1:</strong><br><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>输出:</strong> 6 <br><strong>解释: **节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code><br>**示例 2:</strong><br><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>输出:</strong> 2<br><strong>解释: **节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。<br> **说明:</strong></p><ul><li><code>所有节点的值都是唯一的</code>。</li><li><code>p、q 为不同节点且均存在于给定的二叉搜索树中</code>。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每日一题，复习。因为在树中一定存在给定的节点，所以可以用二叉搜索树的性质进行判断，不需要遍历完整棵树。二叉搜索树的左节点一定小于当前节点，右节点一定大于当前节点。对当前节点和 pq 的值进行比较，如果节点的值都小于当前的值，说明在当前节点的左子树里，都大于当前的值，说明在当前节点的右子树里，递归进行查询，直到当前节点值在两个给定目标值范围内，返回当前节点。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月26日</title>
    <link href="/2020/09/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8826%E6%97%A5/"/>
    <url>/2020/09/26/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt113. 路径总和 II</p><span id="more"></span><h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">5<br>      / \<br>    <span class="hljs-number"> 4 </span>  8<br>    /   / \<br>  <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br>  /  \    / \<br><span class="hljs-number"> 7 </span>  <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1<br></code></pre></td></tr></table></figure><p>返回:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>],<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每日一题，LeetCode 回溯月。dfs 求根节点路径，如果是根节点，再判断 temp 数组求和是否等于 sum 即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">sum</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> pathSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, sum</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> temp = [];<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    temp.push(root.val);<br>    <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right &amp;&amp; temp.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b) === sum) &#123;<br>      res.push([].concat(temp));<br>      temp.pop();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    visit(root.left);<br>    visit(root.right);<br>    temp.pop();<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月25日</title>
    <link href="/2020/09/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8825%E6%97%A5/"/>
    <url>/2020/09/25/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt116. 填充每个节点的下一个右侧节点指针、dfs、递归<br>剑指 Offer 47. 礼物的最大价值、动态规划</p><span id="more"></span><h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。<br><strong>注意:</strong><br>你可以假设树中没有重复的元素。<br>例如，给出<br>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转自力扣评论：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/comments/">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/comments/</a><br>首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。<br>看一下中序和后序有什么特点，中序<code>[9,3,15,20,7]</code> ，后序<code>[9,15,7,20,3]</code>；<br>有如下特征：</p><ol><li>后序中右起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li><li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root-&gt;left = pre_order(中序左子树序列，后序左子树序列);</code>；</li><li>右子树：<code>root-&gt;right = pre_order(中序右子树序列，后序右子树序列);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">inorder</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">postorder</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inorder, postorder</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!inorder.length || !postorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(postorder.pop());<br>  <span class="hljs-keyword">const</span> index = inorder.indexOf(node.val);<br>  <span class="hljs-keyword">const</span> leftTree = inorder.slice(<span class="hljs-number">0</span>, index);<br>  <span class="hljs-keyword">const</span> rightTree = inorder.slice(index + <span class="hljs-number">1</span>);<br>  node.left = buildTree(<br>    inorder.slice(<span class="hljs-number">0</span>, index),<br>    postorder.slice(<span class="hljs-number">0</span>, leftTree.length)<br>  );<br>  node.right = buildTree(<br>    inorder.slice(index + <span class="hljs-number">1</span>),<br>    postorder.slice(leftTree.length)<br>  );<br>  <span class="hljs-keyword">return</span> node;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,5,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,2,1]</span></span><br><span class="hljs-comment">]</span><br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>经典动态规划问题，新建一个矩阵，记录每一个点可以拿到的最大价值，每一个点能拿到的最大价值是取本身，左边的点，上面的点的最大值。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> m = grid.length;<br>  <span class="hljs-keyword">let</span> n = grid[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">const</span> maxGrid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxGrid.length; i++) &#123;<br>    maxGrid[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-keyword">let</span> num1 = i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : maxGrid[i - <span class="hljs-number">1</span>][j] + grid[i][j];<br>      <span class="hljs-keyword">let</span> num2 = j - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : maxGrid[i][j - <span class="hljs-number">1</span>] + grid[i][j];<br>      maxGrid[i][j] = <span class="hljs-built_in">Math</span>.max(grid[i][j], num1, num2);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>动态规划</tag>
      
      <tag>dfs</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月24日</title>
    <link href="/2020/09/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8824%E6%97%A5/"/>
    <url>/2020/09/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 07. 重建二叉树</p><span id="more"></span><h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出<br>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>注意</strong>：本题与主站 105 题重复：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>知识点：<code>前序遍历的第一个节点一定根节点，中序遍历的根节点左边的树一定在左子树，右边的数一定在右子树上</code>。<br>根据以上知识可以得到一个思路。移除前序遍历数组的第一个元素为根节点，找到根节点在中序遍历数组的下标，分为两个左右两个数组，将前序遍历数组以及左右子树数组递归调用，可以得到结果</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">preorder</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">inorder</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">preorder, inorder</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!preorder.length || !inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(preorder.shift());<br>  <span class="hljs-keyword">const</span> index = inorder.indexOf(node.val);<br>  node.left = buildTree(preorder, inorder.slice(<span class="hljs-number">0</span>, index));<br>  node.right = buildTree(preorder, inorder.slice(index + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> node;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月23日</title>
    <link href="/2020/09/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8823%E6%97%A5/"/>
    <url>/2020/09/24/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt617. 合并二叉树<br>Lt108. 将有序数组转换为二叉搜索树</p><span id="more"></span><p>昨天忘记发了，今天补上，对之前的复习</p><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为  **NULL 的节点将直接作为新二叉树的节点。<br>**示例  1:</strong><br><strong>输入:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">Tree<span class="hljs-number"> 1 </span>                    Tree 2<br>     <span class="hljs-number"> 1 </span>                        2<br>     / \                       / \<br>   <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span>  3<br>   /                           \   \<br> <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span>  7<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">合并后的树:<br>      <span class="hljs-number">3</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>  <span class="hljs-number">5</span>   <span class="hljs-number">4</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只看根节点，合并根节点的值，再对左右节点进行合并赋值。return 的时候如果没有 t1，返回的是 t2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t1, t2</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (t1 &amp;&amp; t2) &#123;<br>    t1.val += t2.val;<br>    t1.left = mergeTrees(t1.left, t2.left);<br>    t1.right = mergeTrees(t1.right, t2.right);<br>  &#125;<br>  <span class="hljs-keyword">return</span> t1 || t2;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点  *的左右两个子树的高度差的绝对值不超过 1。<br>*</em>示例:**<br>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">0</span><br>    / \<br>  -<span class="hljs-number">3</span>   <span class="hljs-number">9</span><br>  <span class="hljs-regexp">/   /</span><br>-<span class="hljs-number">10</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>每次都取中间的点设为节点，并递归，将中点左边数组传给左子树，右边的数组传给右子树</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedArrayToBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>  node.left = sortedArrayToBST(nums.slice(<span class="hljs-number">0</span>, mid));<br>  node.right = sortedArrayToBST(nums.slice(mid + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> node;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次某大厂面经及复盘</title>
    <link href="/2020/09/24/yuque/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9F%90%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F%E5%8F%8A%E5%A4%8D%E7%9B%98/"/>
    <url>/2020/09/24/yuque/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9F%90%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F%E5%8F%8A%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍及项目介绍、项目难点"><a href="#自我介绍及项目介绍、项目难点" class="headerlink" title="自我介绍及项目介绍、项目难点"></a>自我介绍及项目介绍、项目难点</h2><h2 id="介绍一下响应式布局、移动端的自适应方案"><a href="#介绍一下响应式布局、移动端的自适应方案" class="headerlink" title="介绍一下响应式布局、移动端的自适应方案"></a>介绍一下响应式布局、移动端的自适应方案</h2><p>讲了 flex，rem，rm，vw、vh、微信小程序的 rpx、viewport、阿里的 flexible.js。<br>还学习到还有 CSS3 新增标签</p><h2 id="从零开始写网页，如何写一个脚本实现自适应"><a href="#从零开始写网页，如何写一个脚本实现自适应" class="headerlink" title="从零开始写网页，如何写一个脚本实现自适应"></a>从零开始写网页，如何写一个脚本实现自适应</h2><p>没有答上来，我猜想问的是阿里 flexible.js 的原理，根据设备 windows.devicePixelRatio 获得一个 dpr 值，如 ios 是 2 或 3。<br>然后设置 html 根节点的 font-size 如<code>doc.body.style.fontSize = 12 * dpr + ``&#39;px&#39;``;</code><br>然后再页面中使用 rem，这里可以用插件自动将 px 转为 rem。如设计稿 750px，一个 button 宽 100px，rem 应该为 100 / 75 rem</p><p>事实上 flexible.js 做了下面三件事：</p><ul><li>动态改写标签</li><li>给<html>元素添加 data-dpr 属性，并且动态改写 data-dpr 的值</li><li>给<html>元素添加 font-size 属性，并且动态改写 font-size 的值</li></ul><h2 id="介绍一下-ViewPort"><a href="#介绍一下-ViewPort" class="headerlink" title="介绍一下 ViewPort"></a>介绍一下 ViewPort</h2><p>讲了一下用于移动端响应式，讲了一下基本属性，初始放大，最大放大，最小放大，是否允许用户放大缩小等属性。</p><h2 id="前端性能优化的指标，如何知道优化不是正向优化"><a href="#前端性能优化的指标，如何知道优化不是正向优化" class="headerlink" title="前端性能优化的指标，如何知道优化不是正向优化"></a>前端性能优化的指标，如何知道优化不是正向优化</h2><p>不知道这些指标，说到了一个白屏时间，然后试图改变问题，讲到了 JS 放在头部会造成阻塞渲染，放一个小的 css 到顶部实现 loading 和骨架屏等，被面试官拉回来了。</p><ul><li><strong>白屏时间</strong></li><li>HTML 加载完成时间</li><li>首屏图片加载完成时间</li><li>首屏接口完成加载完成时间</li><li>各资源耗时(主要统计 css/js 资源耗时)</li><li>FP(首次绘制时间)</li><li>FCP(首次内容渲染时间)</li><li>onload 时间</li></ul><hr><p>转自：<a href="https://blog.csdn.net/c_kite/article/details/104237256">https://blog.csdn.net/c_kite/article/details/104237256</a></p><h4 id="★FP-First-Paint-首次绘制"><a href="#★FP-First-Paint-首次绘制" class="headerlink" title="★FP (First Paint) 首次绘制"></a>★FP (First Paint) 首次绘制</h4><p><code>FP (First Paint) 首次绘制</code>: 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点.</p><h4 id="★FCP-First-Contentful-Paint-首次内容绘制"><a href="#★FCP-First-Contentful-Paint-首次内容绘制" class="headerlink" title="★FCP (First Contentful Paint) 首次内容绘制"></a>★FCP (First Contentful Paint) 首次内容绘制</h4><p><code>FCP (First Contentful Paint) 首次内容绘制</code> 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素.</p><h4 id="LCP-Largest-Contentful-Paint-最大内容渲染"><a href="#LCP-Largest-Contentful-Paint-最大内容渲染" class="headerlink" title="LCP (Largest Contentful Paint) 最大内容渲染"></a>LCP (Largest Contentful Paint) 最大内容渲染</h4><p><code>LCP (Largest Contentful Paint) 最大内容渲染</code>: 代表在 viewport 中最大的页面元素加载的时间. LCP 的数据会通过 PerformanceEntry 对象记录, 每次出现更大的内容渲染, 则会产生一个新的 PerformanceEntry 对象.(2019 年 11 月新增)</p><h4 id="★DCL-DomContentloaded"><a href="#★DCL-DomContentloaded" class="headerlink" title="★DCL (DomContentloaded)"></a>★DCL (DomContentloaded)</h4><p><code>DCL (DomContentloaded)</code>: 当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，<strong>无需等待样式表、图像和子框架的完成加载</strong>.</p><h4 id="★FMP-First-Meaningful-Paint-首次有效绘制"><a href="#★FMP-First-Meaningful-Paint-首次有效绘制" class="headerlink" title="★FMP(First Meaningful Paint) 首次有效绘制"></a>★FMP(First Meaningful Paint) 首次有效绘制</h4><p><code>FMP(First Meaningful Paint) 首次有效绘制</code>: 例如，在 YouTube 观看页面上，主视频就是<code>主角元素</code>. 看这个 csdn 的网站不是很明显, 这几个都成一个时间线了, 截个 weibo 的看下. 下面的示例图可以看到, 微博的博文是主要元素.<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601125924233-3855397d-e17b-423c-bc81-1d8c999c6162.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=700&size=0&status=done&style=none&width=700"></p><h4 id="L-onLoad"><a href="#L-onLoad" class="headerlink" title="L (onLoad)"></a>L (onLoad)</h4><p><code>L (onLoad)</code>, 当依赖的资源, 全部加载完毕之后才会触发.</p><hr><p>再来说几个, 这个 performance panel 上没画的名词, 但用的上的:</p><h4 id="★TTI-Time-to-Interactive-可交互时间"><a href="#★TTI-Time-to-Interactive-可交互时间" class="headerlink" title="★TTI (Time to Interactive) 可交互时间"></a>★TTI (Time to Interactive) 可交互时间</h4><p><code>TTI (Time to Interactive) 可交互时间</code>: 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点.</p><h4 id="★TBT-Total-Blocking-Time-页面阻塞总时长"><a href="#★TBT-Total-Blocking-Time-页面阻塞总时长" class="headerlink" title="★TBT (Total Blocking Time) 页面阻塞总时长"></a>★TBT (Total Blocking Time) 页面阻塞总时长</h4><p><code>TBT (Total Blocking Time) 页面阻塞总时长</code>: TBT 汇总所有加载过程中阻塞用户操作的时长，在 FCP 和 TTI 之间任何 long task 中阻塞部分都会被汇总.<br>来个例子说明一下:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601125924057-8e5354f8-35f2-4337-a488-602d2a32ceef.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=854&size=0&status=done&style=none&width=854"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601125924042-69b5cbbd-9fc5-4919-a13e-d38f920f09f2.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=866&size=0&status=done&style=none&width=866"><br>在主线程上运行任务所花费的总时间为 560 毫秒，但只有 345(200 + 40 + 105)毫秒的时间被视为阻塞时间(超过 50ms 的 Task 都会被记录).</p><h4 id="FID-First-Input-Delay-首次输入延迟"><a href="#FID-First-Input-Delay-首次输入延迟" class="headerlink" title="FID (First Input Delay) 首次输入延迟"></a>FID (First Input Delay) 首次输入延迟</h4><p><code>FID (First Input Delay) 首次输入延迟</code>: 指标衡量的是从用户首次与您的网站进行交互（即当他们单击链接，点击按钮等）到浏览器实际能够访问之间的时间, 下面来张图来解释 FID 和 TTI 的区别:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601125924089-d00f2c2a-f530-49a8-b8e4-ccc5d76d4417.png#align=left&display=inline&height=496&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=1093&size=0&status=done&style=none&width=1093"></p><h4 id="CLS-Cumulative-Layout-Shift-累积布局偏移"><a href="#CLS-Cumulative-Layout-Shift-累积布局偏移" class="headerlink" title="CLS (Cumulative Layout Shift) 累积布局偏移"></a>CLS (Cumulative Layout Shift) 累积布局偏移</h4><p><code>CLS (Cumulative Layout Shift) 累积布局偏移</code>: 总结起来就是一个元素初始时和其 hidden 之间的任何时间如果元素偏移了, 则会被计算进去, 具体的计算方法可看这篇文章 <a href="https://web.dev/cls/">https://web.dev/cls/</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1601125924082-e1176073-4a5d-42ff-9d3f-bfb43d9102bd.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&originHeight=600&originWidth=710&size=0&status=done&style=none&width=710"></p><h4 id="SI-Speed-Index"><a href="#SI-Speed-Index" class="headerlink" title="SI (Speed Index)"></a>SI (Speed Index)</h4><p><code>SI (Speed Index)</code>: 指标用于显示页面可见部分的显示速度, 单位是时间,</p><h3 id="前端优化相关"><a href="#前端优化相关" class="headerlink" title="前端优化相关"></a>前端优化相关</h3><p><a href="https://segmentfault.com/a/1190000020690092">https://segmentfault.com/a/1190000020690092</a></p><h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h2><p>只知道 CSS 树和 DOM 树的加载和渲染过程。看了一下以下视频，了解了许多。<a href="https://www.bilibili.com/video/BV1dt411W7Y4?t=147">https://www.bilibili.com/video/BV1dt411W7Y4?t=147</a></p><h3 id="浏览器如何解析-HTML"><a href="#浏览器如何解析-HTML" class="headerlink" title="浏览器如何解析 HTML"></a>浏览器如何解析 HTML</h3><p>整理，参考于：<a href="https://juejin.im/post/6844903745730396174">https://juejin.im/post/6844903745730396174</a></p><ol><li>整个<code>dom</code>的解析过程是<code>顺序</code>，并且<code>渐进式</code>的。<code>顺序</code>指的是从第一行开始，<code>一行一行</code>依次解析；</li><li>阻塞型的资源为阻塞<code>dom</code>的<code>解析</code>，包括以下：<ul><li>内联 css</li><li>内联 javascript</li><li>外联普通 javascript</li><li><strong>外联 defer javascript</strong></li></ul></li></ol><p><code>defer</code>外联 defer js 与普通 js 不同的是 defer js 的下载不阻塞 dom 解析，<code>但是它的执行会阻塞dom</code>，虽然说是 html 已经解析完了，但<code>dom的解析完成取决于html和阻塞js的完成</code>，defer js，内联 js，普通外联 js 这三种就属于阻塞 js。所以说 defer js 是会阻塞 dom 解析的。</p><ul><li>javascript 标签之前的外联 css</li></ul><p>非阻塞的资源包括以下：</p><ul><li>javascript 标签之后的外联 css</li><li>image</li><li>iframe</li><li>外联 async javascript</li></ul><p>浏览器发现 img，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码<br>服务器返回图片文件，由于图片占用了一定面积，影响了页面排布,浏览器需要回过头来重新渲染这部分代码;</p><ol start="3"><li>这些<code>阻塞型</code>的资源请求并执行完之后<code>dom树</code>的解析便完成了，这时<code>document</code>对象就会派发<code>DOMContentLoaded</code>事件，表示<code>dom树</code>构建完成。</li><li><code>外联javascript</code>加载过程</li></ol><p><code>html</code>页面中可以引入<code>内联javascript</code>，也可以引入<code>外联javascript</code>，<code>外联javascript</code>又分为：</p><ul><li>外联普通 javascript</li><li>外联 defer javascript</li><li>外联 async javascript</li></ul><p>其中第一种就是<code>外联普通javascript</code>，会阻塞<code>html</code>的解析，<code>html</code>解析过程中每遇到这种<code>&lt;script&gt;</code>标签就会请求并执行，如下图所示，绿色表示<code>html</code>解析；灰色表示<code>html</code>解析暂停；蓝色表示<code>外联javascript</code>加载；粉色表示<code>javascript执行</code>。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1601120590269-59a3bb29-8d14-4a0b-b7a7-815080f63ce6.webp#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&originHeight=163&originWidth=702&size=0&status=done&style=none&width=702"><br><code>外联普通javascript</code>的加载执行过程如下：<img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1601120590168-9cacc84c-d58e-406d-99ee-96bb086a370e.webp#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&originHeight=104&originWidth=767&size=0&status=done&style=none&width=767"><br>第二种<code>外联defer javascript</code>稍有不同，<code>html</code>解析过程中遇到此类<code>&lt;script&gt;</code>标签不阻塞解析，而是会暂存到一个队列中，等整个<code>html</code>解析完成后再按队列的顺序请求并执行<code>javascript</code>，但是这种<code>外联defer javascript</code>全部加载并执行完成后才会派发<code>DOMContentLoaded</code>事件，<code>外联defer javascript</code>的加载执行过程如下：<img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1601120590192-5f337a36-d352-4c65-ae84-902f700434a3.webp#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=766&size=0&status=done&style=none&width=766"><br>第三种<code>外联async javascript</code>则不阻塞<code>html</code>的解析过程，注意这里是说的脚本的<code>下载</code>过程不阻塞<code>html</code>解析，如果下载完成后<code>html</code>还没解析完成，则会暂停<code>html</code>解析，先执行完成下载后的<code>javascript</code>代码再继续解析<code>html</code>，过程如下：<img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1601120590170-04e883a6-5b5a-4875-84f4-fbf8ed6d06ea.webp#align=left&display=inline&height=92&margin=%5Bobject%20Object%5D&originHeight=92&originWidth=768&size=0&status=done&style=none&width=768">但是如果<code>html</code>已经解析完毕，<code>外联async javascript</code>还未下载完成，则不阻塞<code>DOMContentLoaded</code>事件的派发。因此<code>外联async javascript</code>很有可能来不及监听<code>DOMContentLoaded</code>事件，比如<code>stackoverflow</code>上的<a href="https://stackoverflow.com/questions/9237044/async-loaded-scripts-with-domcontentloaded-or-load-event-handlers-not-being-call">这个问题</a>。<br>说明下，这几个图引用自<a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">这里</a>。<br><strong>补充</strong></p><ul><li>解析 HTML 构建 DOM 时，遇到 JavaScript 会被阻塞</li><li><code>JavaScript执行会被CSSOM构建阻塞</code>，也就是说，<code>JavaScript必须等到CSSOM构建完成后才会执行</code></li><li>如果使用异步脚本，脚本的网络请求优先级降低，且网络请求期间不阻塞 DOM 构建，直到请求完成才开始执行脚本</li></ul><h3 id="浏览器是如何渲染页面的"><a href="#浏览器是如何渲染页面的" class="headerlink" title="浏览器是如何渲染页面的"></a>浏览器是如何渲染页面的</h3><p>参考于：<a href="https://juejin.im/post/6844904131346300942">https://juejin.im/post/6844904131346300942</a></p><h4 id="Critical-Rendering-Path"><a href="#Critical-Rendering-Path" class="headerlink" title="Critical Rendering Path"></a>Critical Rendering Path</h4><p>_Critical Rendering Path_，中文翻译过来，叫做<code>关键渲染路径</code>。指的是浏览器从请求 HTML，CSS，JavaScript 文件开始，到将它们最终以像素输出到屏幕上这一过程。包括以下几个部分：</p><ol><li><code>构建DOM</code><ul><li>将 HTML 解析成许多 Tokens</li><li>将 Tokens 解析成 object</li><li>将 object 组合成为一个 DOM 树</li></ul></li><li><code>构建CSSOM</code><ul><li>解析 CSS 文件，并构建出一个 CSSOM 树（过程类似于 DOM 构建）</li></ul></li><li><code>构建Render Tree</code><ul><li>结合 DOM 和 CSSOM 构建出一颗 Render 树</li></ul></li><li><code>Layout</code><ul><li>计算出元素相对于 viewport 的相对位置</li></ul></li><li><code>Paint</code><ul><li>将 render tree 转换成像素，显示在屏幕上</li></ul></li></ol><p>值得注意的是，上面的过程<code>并不是依次进行的，而是存在一定交叉</code>。</p><h2 id="为什么使用虚拟-DOM，直接操作-DOM-不是更快吗？"><a href="#为什么使用虚拟-DOM，直接操作-DOM-不是更快吗？" class="headerlink" title="为什么使用虚拟 DOM，直接操作 DOM 不是更快吗？"></a>为什么使用虚拟 DOM，直接操作 DOM 不是更快吗？</h2><p>没答到点上，只说了双向绑定的核心是虚拟 DOM。应该想问的是 diff 算法。<br>但是说了数据量非常大的情况下，使用虚拟 DOM 也不一定更好。</p><h4 id="为啥真实-DOM-操作不推荐"><a href="#为啥真实-DOM-操作不推荐" class="headerlink" title="为啥真实 DOM 操作不推荐"></a>为啥真实 DOM 操作不推荐</h4><p>真实 DOM 的操作，<strong>一般都会对某块元素的整体重新渲染</strong>。</p><h4 id="为啥虚拟-DOM-能提升性能"><a href="#为啥虚拟-DOM-能提升性能" class="headerlink" title="为啥虚拟 DOM 能提升性能"></a>为啥虚拟 DOM 能提升性能</h4><p>采用虚拟 DOM 的话，当数据变化的时候，只需要<strong>局部刷新</strong>变化的位置就好了。</p><h2 id="实现固定长宽比（4-3）的块"><a href="#实现固定长宽比（4-3）的块" class="headerlink" title="实现固定长宽比（4:3）的块"></a>实现固定长宽比（4:3）的块</h2><p>忘记了加 top，问题不大。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;element&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>考点：<strong>padding 是根据父元素的 width 计算的。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="npm-包的版本语义化规范说一下"><a href="#npm-包的版本语义化规范说一下" class="headerlink" title="npm 包的版本语义化规范说一下"></a>npm 包的版本语义化规范说一下</h2><p>没了解过，学习了一下。<br>转自:<a href="https://segmentfault.com/a/1190000018714929">https://segmentfault.com/a/1190000018714929</a><br>为了在软件版本号中包含更多意义，反映代码所做的修改，产生了语义化版本，软件的使用者能从版本号中推测软件做的修改。npm 包使用语义化版控制，我们可安装一定版本范围的 npm 包，npm 会选择和你指定的版本<code>相匹配</code> 的 <code>(latest)最新版本</code>安装。<br>npm 的版本号由三部分组成：<br><code>主版本号</code>、<code>次版本号</code>、<code>补丁版本号</code>。变更不同的版本号，代表不同的意义：</p><ul><li>主版本号（major）：软件做了不兼容的变更（breaking change 重大变更）；</li><li>次版本号（minor）：添加功能或者废弃功能，向下兼容；</li><li>补丁版本号（patch）：bug 修复，向下兼容。</li></ul><p>有时候为了表达更加确切的版本，还会在版本号后面添加<strong>标签</strong>或者<strong>扩展</strong>，来说明是预发布版本或者测试版本等。比如 <strong>3.2.3-beta-3</strong>。<br>常见的标签有 :</p><table><thead><tr><th align="center">标签</th><th align="center">意义</th><th>补充</th></tr></thead><tbody><tr><td align="center">demo</td><td align="center">demo 版本</td><td>可能用于验证问题的版本</td></tr><tr><td align="center">dev</td><td align="center">开发版</td><td>开发阶段用的，bug 多，体积较大等特点，功能不完善</td></tr><tr><td align="center">alpha</td><td align="center">α 版本</td><td>用于内部交流或者测试人员测试，bug 较多</td></tr><tr><td align="center">beta</td><td align="center">测试版(β 版本)</td><td>较 α 版本，有较大的改进，但是还是有 bug</td></tr><tr><td align="center">gamma</td><td align="center">（γ）伽马版本</td><td>较 α 和 β 版本有很大的改进，与稳定版相差无几，用户可使用</td></tr><tr><td align="center">trial</td><td align="center">试用版本</td><td>本软件通常都有时间限制，过期之后用户如果希望继续使用，一般得交纳一定的费用进行注册或购买。有些试用版软件还在功能上做了一定的限制。</td></tr><tr><td align="center">stable</td><td align="center">稳定版</td><td></td></tr><tr><td align="center">csp</td><td align="center">内容安全版本</td><td>js 库常用</td></tr><tr><td align="center">latest</td><td align="center">最新版本</td><td>不指定版本和标签，npm 默认安最新版</td></tr></tbody></table><p><a href="https://docs.npmjs.com/cli/dist-tag">更多关于标签的内容</a><br>查看标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm dist-tags ls &lt;pkg&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm dist-tags ls vue<br></code></pre></td></tr></table></figure><p>得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">beta</span>: <span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span>-beta.<span class="hljs-number">3</span><br><span class="hljs-attribute">csp</span>: <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">28</span>-csp<br><span class="hljs-attribute">latest</span>: <span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>安装带标签的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i &lt;pkg&gt;@&lt;tag&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i vue@beta <span class="hljs-comment"># 安装 2.6.0-beta.3</span><br></code></pre></td></tr></table></figure><h3 id="版本号变更规则"><a href="#版本号变更规则" class="headerlink" title="版本号变更规则"></a>版本号变更规则</h3><ol><li>版本号只升不降，不得在数字前加 0，比如 2.01.2 不允许的；</li><li>0.y.z，处于开发阶段的版本；</li><li>第一个正式版版本往往命名为 1.0.0；</li><li>先行版本必须在补丁版本之后添加，比如 2.3.7-0,<code>0</code>表示先行版本，和补丁版本用<code>-</code>分隔；</li><li>版本的比较依次比较<strong>主版本</strong>→<strong>次版本</strong>→<strong>补丁版本</strong>→<strong>先行版本</strong>，直到第一个能得出比较结果为止；</li><li>不小心把一个<strong>不兼容的改版</strong>当成了<strong>次版本号</strong>发行了该怎么办？一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并<strong>发行一个新的次版本号</strong>来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。</li></ol><h2 id="了解-EventLoop-吗"><a href="#了解-EventLoop-吗" class="headerlink" title="了解 EventLoop 吗"></a>了解 EventLoop 吗</h2><p>做一道 EventLoop 题，并详细复述过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;start&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;timer1&quot;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;timer2&quot;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise3&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>改造  update  函数，根据事件循环模式，将多次更新合并成一次。进行了多次 update，执行耗时的函数，但是前面的不重要，如何合并所有的操作，只执行最后的操作。<br>提示说是 EventLoop，如何开启下一次 EventLoop，谈到了页面渲染的机制，栈空的时候再渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test render<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>     <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>this is result<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">num, id</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 非常耗时的计算</span></span><br><span class="javascript">      <span class="hljs-keyword">const</span> array = <span class="hljs-built_in">Array</span>.from(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10000000</span> &#125;);</span><br><span class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="javascript">        array[index] = &#123;&#125;;</span><br><span class="javascript">      &#125; <span class="hljs-comment">// 开始准备渲染</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> product = num * num;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> ele = <span class="hljs-built_in">document</span>.getElementById(id);</span><br><span class="javascript">      ele.textContent = product;</span><br><span class="javascript">    &#125; <span class="hljs-comment">// 改造 update 函数，根据事件循环模式，将多次更新合并成一次</span></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">num, id</span>) </span>&#123;</span><br><span class="javascript">      render(num, id);</span><br><span class="javascript">    &#125; <span class="hljs-comment">// 更新多次</span></span><br><span class="javascript"></span><br><span class="javascript">    update(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">    update(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我的做法，暂时想不到不设一个全局变量能实现的方法。用了防抖的思想。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">num, id</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    render(num, id);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-Lodash-Chunk-函数"><a href="#实现-Lodash-Chunk-函数" class="headerlink" title="实现 Lodash Chunk 函数"></a>实现 Lodash Chunk 函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.chunk([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>], <span class="hljs-number">2</span>); <span class="hljs-comment">//[[&#x27;a&#x27;,&#x27;b&#x27;], [&#x27;c&#x27;,&#x27;d&#x27;]]</span><br></code></pre></td></tr></table></figure><p>这题比较简单，秒答了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> chunk = <span class="hljs-function">(<span class="hljs-params">arr, length</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (arr.length &gt; length) &#123;<br>    res.push(arr.splice(<span class="hljs-number">0</span>, length));<br>  &#125;<br>  res.push(arr);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="场景题-1"><a href="#场景题-1" class="headerlink" title="场景题"></a>场景题</h2><p>无法使用加减符号，但是可以有一个机器可以获得加减结果，实现 sum 获得求和结果。提示 promiseify<br><a href="https://www.cnblogs.com/ryzz/p/13264798.html">https://www.cnblogs.com/ryzz/p/13264798.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">asyncAdd(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 8</span><br>&#125;);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncAdd</span>(<span class="hljs-params">a, b, cb</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    cb(<span class="hljs-literal">null</span>, a + b);<br>  &#125;, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>));<br>&#125;<br><span class="hljs-comment">// 实现 sum</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> sum(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>);<br>  <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> sum(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br>  <span class="hljs-keyword">const</span> result3 = <span class="hljs-keyword">await</span> sum(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>);<br>  <span class="hljs-built_in">console</span>.log([result1, result2, result3]); <span class="hljs-comment">// [44, 420, 32]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (args.length) &#123;<br>      sum = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        asyncAdd(sum, args.shift(), <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>          res(result);<br>        &#125;);<br>      &#125;);<br>    &#125;<br>    resolve(sum);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><p>公司技术栈：全 React<br>移动端的技术栈：公司自研框架，小部分 RN<br>对我的学习前端的方向有什么意见：还需要多操作，多使用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3新特性</title>
    <link href="/2020/09/23/yuque/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2020/09/23/yuque/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="一、css3-新选择器："><a href="#一、css3-新选择器：" class="headerlink" title="一、css3 新选择器："></a>一、css3 新选择器：</h4><p>E:nth-child(n) 选择器匹配其父元素的第 n 个子元素，不论元素类型，n 可以使数字，关键字，或公式<br>E:nth-of-type(n) 选择与之其匹配的父元素的第 N 个子元素<br>E:frist-child 相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应<br>E:frist-of-type 相对于父级做参考，“特定类型”（E）的第一个子元素<br>E:empty 选择没有子元素的每个 E 元素<br>E:target 选择当前活动的 E 元素<br>::selection 选择被用户选取的元素部分<br>属性选择器<br>E[abc*=”def”] 选择 adc 属性值中包含子串”def”的所有元素</p><h4 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h4><p>text-shadow:2px 2px 8px #000;参数 1 为向右的偏移量，参数 2 为向左的偏移量，参数 3 为渐变的像素，参数 4 为渐变的颜色<br>box-shadow: 1px 1px 1px 1px red;<br>text-overflow:规定当文本溢出包含元素时发生的事情  text-overflow:ellipsis(省略)<br>text-wrap:规定文本换行的规则<br>word-break 规定非中日韩文本的换行规则<br>word-wrap   对长的不可分割的单词进行分割并换行到下一行<br>white-space: 规定如何处理元素中的空白  white-space:nowrap 规定段落中的文本不进行换行</p><h4 id="三、边框"><a href="#三、边框" class="headerlink" title="三、边框"></a>三、边框</h4><p><strong>border-raduis</strong>:50%边框的圆角<br><strong>border-image</strong> 边框图片<br>.border-image {<br>   border-image-source:url(images/border.png);<br>   boder-image-slice:27;<br>   border-image-width:10px;<br>   border-iamge-repeat:round; (round 平铺) 平铺效果不作用于四角，只适应与四边  <br>}</p><h4 id="四、背景"><a href="#四、背景" class="headerlink" title="四、背景"></a>四、背景</h4><p><strong>rgba</strong><br>backgrounnd-size:cover/contain，其中 background-size：cover，会使“最大”边进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。background-size:contain，会使“最小”边进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片</p><h4 id="五、渐变"><a href="#五、渐变" class="headerlink" title="五、渐变"></a>五、渐变</h4><p><strong>linear-gradient</strong><br>background-image:linear-gradient(90deg,yellow 20%,green 80%)<br><strong>radial-gradient</strong><br>background-iamge:radial-gradient(120px at center center,yellow,green)</p><h4 id="六、多列布局"><a href="#六、多列布局" class="headerlink" title="六、多列布局"></a>六、多列布局</h4><p>column-count<br>column-width<br>column-gap<br>column-rule</p><h4 id="七、过渡"><a href="#七、过渡" class="headerlink" title="七、过渡"></a>七、过渡</h4><p><strong>transition</strong><br>transition-property:width       //property 为定义过渡的 css 属性列表，列表以逗号分隔<br>transition-duration:2s;    //过渡持续的时间<br>transition-timing-function:ease;<br>transition-delay:5s  //过渡延迟 5s 进行</p><h4 id="八、动画、旋转"><a href="#八、动画、旋转" class="headerlink" title="八、动画、旋转"></a>八、动画、旋转</h4><p><strong>animation</strong><br>transform ：translate（x,y) rotate(deg) scale(x,y)<br>translate<br>scale<br>rotate<br>skew（倾斜）</p><h4 id="九、flex-布局"><a href="#九、flex-布局" class="headerlink" title="九、flex 布局"></a>九、flex 布局</h4><h4 id="十、-media-媒体查询"><a href="#十、-media-媒体查询" class="headerlink" title="十、@media 媒体查询"></a>十、@media 媒体查询</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML5新特性</title>
    <link href="/2020/09/23/yuque/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2020/09/23/yuque/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ol><li><strong>本地存储特性</strong></li><li>设备兼容特性 HTML5 提供了前所未有的数据与应用接入开放接口</li><li>连接特性 <strong>WebSockets</strong></li><li>网页多媒体特性 支持 Audio Video <strong>SVG Canvas</strong> WebGL CSS3</li><li>CSS3 特性</li></ol><p>增加<code>拖放API</code>、<code>地理定位</code>、<code>SVG绘图</code>、<code>canvas绘图</code>、<code>Web Worker</code>、<code>WebSocket</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用promise封装ajax（XMLHttpRequest）</title>
    <link href="/2020/09/23/yuque/%E4%BD%BF%E7%94%A8promise%E5%B0%81%E8%A3%85ajax%EF%BC%88XMLHttpRequest%EF%BC%89/"/>
    <url>/2020/09/23/yuque/%E4%BD%BF%E7%94%A8promise%E5%B0%81%E8%A3%85ajax%EF%BC%88XMLHttpRequest%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xhr = XMLHttpRequest<br>      ? <span class="hljs-keyword">new</span> XMLHttpRequest()<br>      : <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Mscrosoft.XMLHttp&quot;</span>);<br>    xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">false</span>);<br>    xhr.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (xhr.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span> || xhr.status === <span class="hljs-number">304</span>) &#123;<br>        resolve(xhr.responseText);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(xhr.responseText));<br>      &#125;<br>    &#125;;<br>    xhr.send();<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用promise封装JSONP</title>
    <link href="/2020/09/23/yuque/%E4%BD%BF%E7%94%A8promise%E5%B0%81%E8%A3%85JSONP/"/>
    <url>/2020/09/23/yuque/%E4%BD%BF%E7%94%A8promise%E5%B0%81%E8%A3%85JSONP/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> generateUrl = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> dataSrc = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(params, key)) &#123;<br>        dataSrc += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;<br>      &#125;<br>    &#125;<br>    dataSrc += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataSrc&#125;</span>`</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br>    scriptEle.src = generateUrl();<br>    <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);<br>    <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      resolve(data);<br>      <span class="hljs-built_in">document</span>.removeChild(scriptEle);<br>    &#125;;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue生命周期</title>
    <link href="/2020/09/23/yuque/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/09/23/yuque/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>本文转自:<a href="https://segmentfault.com/a/1190000011381906">https://segmentfault.com/a/1190000011381906</a></p><h2 id="1-生命周期是什么？"><a href="#1-生命周期是什么？" class="headerlink" title="1. 生命周期是什么？"></a>1. 生命周期是什么？</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><h2 id="2-各个生命周期的作用"><a href="#2-各个生命周期的作用" class="headerlink" title="2. 各个生命周期的作用"></a>2. 各个生命周期的作用</h2><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，data 和 methods 中的数据还没有初始化</td></tr><tr><td>created</td><td>组件实例已经完全创建，data 和 methods 都已经初始化好了</td></tr><tr><td>beforeMount</td><td>模板渲染，相关的 render 函数首次被调用，模板已经在内存中编译好了，但是尚未挂载到页面中去</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.el 替换，真是 dom 已经生成，<em>el</em>替换，真是<em>dom</em>已经生成，el 可用，组件脱离创建阶段，进入运行阶段</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用， 此时页面中显示的数据还是旧的，但 data 是最新的，页面尚未和最新的数据保持同步</td></tr><tr><td>update</td><td>组件数据更新之后，页面和 data 数据已经保持同步，都是最新的</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用，vue 实例从运行阶段进入到销毁阶段，这时 vue 实例身上所有都可用，还没有真正执行销毁</td></tr><tr><td>destoryed</td><td>组件销毁后调用，vue 实例上的所有都不可以用了</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用，</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用，</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599313876348-576561ef-d304-4158-bbe0-dc3c4e6785e2.webp#align=left&display=inline&height=1075&margin=%5Bobject%20Object%5D&originHeight=1075&originWidth=960&size=0&status=done&style=none&width=960"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1599313892321-b33ef229-8899-47b8-99f3-76988ddfb379.png#align=left&display=inline&height=2800&margin=%5Bobject%20Object%5D&originHeight=2800&originWidth=1200&size=0&status=done&style=none&width=1200"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现MVVM (ES6)</title>
    <link href="/2020/09/23/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0MVVM%20(ES6)/"/>
    <url>/2020/09/23/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0MVVM%20(ES6)/</url>
    
    <content type="html"><![CDATA[<p>本文参考，加以修改：<a href="https://segmentfault.com/a/1190000015460479">https://segmentfault.com/a/1190000015460479</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>简单版mvvm<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>开发语言：&#123;&#123;language&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>组成部分：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123;makeUp.one&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123;makeUp.two&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123;makeUp.three&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>描述：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;describe&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;123&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;makeUp.three&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./MVVM.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-comment">// 写法和Vue一样</span></span><br><span class="javascript">      <span class="hljs-keyword">const</span> mvvm = <span class="hljs-keyword">new</span> Mvvm(&#123;</span><br><span class="javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">          <span class="hljs-attr">language</span>: <span class="hljs-string">&quot;Javascript&quot;</span>,</span><br><span class="javascript">          <span class="hljs-attr">makeUp</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">one</span>: <span class="hljs-string">&quot;ECMAScript&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">two</span>: <span class="hljs-string">&quot;文档对象模型（DOM）&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">three</span>: <span class="hljs-string">&quot;浏览器对象模型（BOM）&quot;</span>,</span><br><span class="javascript">          &#125;,</span><br><span class="javascript">          <span class="hljs-attr">describe</span>: <span class="hljs-string">&quot;没什么产品是写不了的&quot;</span>,</span><br><span class="javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="javascript">          <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;mounted&quot;</span>);</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">      &#125;);</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(mvvm);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mvvm</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$el = options.el;<br>    <span class="hljs-built_in">this</span>.$data = options.data;<br>    <span class="hljs-built_in">this</span>.$vm = <span class="hljs-built_in">this</span>.initProxyVM();<br>    <span class="hljs-built_in">this</span>.$mounted = options.mounted();<br>    <span class="hljs-built_in">this</span>.initObserve();<br>    <span class="hljs-built_in">this</span>.initComplie();<br>    <span class="hljs-built_in">this</span>.mounted();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$vm;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initProxyVM</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">this</span>, &#123;<br>      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, key, receiver</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[key] || <span class="hljs-built_in">this</span>.$data[key];<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">target, key, value</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(<span class="hljs-built_in">this</span>.$data, key, value);<br>      &#125;,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initObserve</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$data = <span class="hljs-built_in">this</span>.observer(<span class="hljs-built_in">this</span>.$data);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initComplie</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> Complie(<span class="hljs-built_in">this</span>.$el, <span class="hljs-built_in">this</span>.$vm);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$mounted &amp;&amp; <span class="hljs-built_in">this</span>.$mounted.call(<span class="hljs-built_in">this</span>.$vm);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">observer</span>(<span class="hljs-params">object</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observe(object);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observe</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">object</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep();<br>    <span class="hljs-built_in">Reflect</span>.ownKeys(object).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      object[key] = <span class="hljs-built_in">this</span>.observer(object[key]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.initProxyObject(object);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">observer</span>(<span class="hljs-params">object</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observe(object);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">initProxyObject</span>(<span class="hljs-params">object</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> dep = <span class="hljs-built_in">this</span>.dep;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(object, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, key, receiver</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>          <span class="hljs-keyword">if</span> (!dep.depSet.includes(Dep.exp)) &#123;<br>            dep.addDep(Dep.target);<br>            dep.addDep(Dep.exp);<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, value</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Reflect</span>.set(target, key, self.observer(value));<br>        dep.notify();<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complie</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">el, vm</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$el = <span class="hljs-built_in">document</span>.querySelector(el);<br>    <span class="hljs-built_in">this</span>.$vm = vm;<br>    <span class="hljs-built_in">this</span>.fragment = <span class="hljs-built_in">this</span>.createFragment();<br>    <span class="hljs-built_in">this</span>.complieFragment();<br>    <span class="hljs-built_in">this</span>.$el.appendChild(<span class="hljs-built_in">this</span>.fragment);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">createFragment</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();<br>    <span class="hljs-keyword">let</span> firstChild = <span class="hljs-built_in">this</span>.$el.firstChild;<br>    <span class="hljs-keyword">while</span> (firstChild) &#123;<br>      fragment.appendChild(firstChild);<br>      firstChild = <span class="hljs-built_in">this</span>.$el.firstChild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fragment;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">complieFragment</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> childNodesArr = [...this.fragment.childNodes];<br>    childNodesArr.forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isElementNode(node)) &#123;<br>        <span class="hljs-keyword">const</span> nodeAttrs = [...node.attributes];<br>        nodeAttrs.forEach(<span class="hljs-function">(<span class="hljs-params">attr</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> attrName = attr.name;<br>          <span class="hljs-keyword">const</span> attrValue = attr.value;<br>          <span class="hljs-keyword">if</span> (attrName === <span class="hljs-string">&quot;v-model&quot;</span>) &#123;<br>            node.addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>              <span class="hljs-keyword">const</span> keyArr = attrValue.split(<span class="hljs-string">&quot;.&quot;</span>);<br>              <span class="hljs-keyword">if</span> (keyArr.length === <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">this</span>.$vm[keyArr[<span class="hljs-number">0</span>]] = e.target.value;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.$vm;<br>                <span class="hljs-keyword">let</span> key = keyArr.pop();<br>                keyArr.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>                  val = val[key];<br>                &#125;);<br>                val[key] = e.target.value;<br>              &#125;<br>            &#125;);<br>          &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// &#125; else if(this.isTextNode(node))&#123;</span><br>        <span class="hljs-keyword">const</span> text = node.textContent;<br>        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;<br>        <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceText</span>(<span class="hljs-params"></span>) </span>&#123;<br>          node.textContent = text.replace(reg, <span class="hljs-function">(<span class="hljs-params">matched, placeholder</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">new</span> Watcher(self.$vm, placeholder, replaceText);<br>            <span class="hljs-keyword">return</span> placeholder.split(<span class="hljs-string">&quot;.&quot;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[b], self.$vm);<br>          &#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (reg.test(text)) &#123;<br>          replaceText();<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">isElementNode</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> node.nodeType === <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">isTextNode</span>(<span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> node.nodeType === <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> target = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">static</span> depSet = [];<br>  <span class="hljs-keyword">static</span> exp = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.depSet = [];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">addDep</span>(<span class="hljs-params">dep</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.depSet.push(dep);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.depSet<br>      .filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> e !== <span class="hljs-string">&quot;string&quot;</span>)<br>      .forEach(<span class="hljs-function">(<span class="hljs-params">dep</span>) =&gt;</span> &#123;<br>        dep.update();<br>      &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">vm, exp, fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$vm = vm;<br>    <span class="hljs-built_in">this</span>.exp = exp;<br>    <span class="hljs-built_in">this</span>.fn = fn;<br>    Dep.target = <span class="hljs-built_in">this</span>;<br>    Dep.exp = exp;<br>    <span class="hljs-keyword">const</span> arr = exp.split(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.$vm;<br>    arr.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      val = val[key];<br>    &#125;);<br>    Dep.target = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> exp = <span class="hljs-built_in">this</span>.exp;<br>    <span class="hljs-keyword">let</span> arr = exp.split(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.$vm;<br>    arr.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      val = val[key];<br>    &#125;);<br>    <span class="hljs-built_in">this</span>.fn(val);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动Promise / A+ (ES6)</title>
    <link href="/2020/09/23/yuque/%E6%89%8B%E5%8A%A8Promise%20!%20A+%20(ES6)/"/>
    <url>/2020/09/23/yuque/%E6%89%8B%E5%8A%A8Promise%20!%20A+%20(ES6)/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6860037916622913550#heading-10">https://juejin.im/post/6860037916622913550#heading-10</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;PENDING&quot;</span>; <span class="hljs-comment">// 进行中</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&quot;FULFILLED&quot;</span>; <span class="hljs-comment">// 已成功</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;REJECTED&quot;</span>; <span class="hljs-comment">// 已失败</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myPromise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>    <span class="hljs-comment">// 请求状态</span><br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-comment">// 成功结果</span><br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 失败原因</span><br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 成功态回调队列</span><br>    <span class="hljs-built_in">this</span>.onFulfilledCallbacks = [];<br>    <span class="hljs-comment">// 失败态回调队列</span><br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks = [];<br><br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(value);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = FULFILLED;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.onFulfilledCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn(<span class="hljs-built_in">this</span>.value));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = REJECTED;<br>        <span class="hljs-built_in">this</span>.reason = reason;<br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn(<span class="hljs-built_in">this</span>.reason));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled !== <span class="hljs-string">&quot;function&quot;</span>) onFulfilled = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>)<br>      onRejected = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> reason;<br>      &#125;;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (self.status === PENDING) &#123;<br>        self.onFulfilledCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-keyword">const</span> res = onFulfilled(self.value);<br>              <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> myPromise) &#123;<br>                res.then(resolve, reject);<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(res);<br>              &#125;<br>            &#125;);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error);<br>          &#125;<br>        &#125;);<br>        self.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-keyword">const</span> res = onRejected(self.value);<br>              <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> myPromise) &#123;<br>                res.then(resolve, reject);<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                reject(res);<br>              &#125;<br>            &#125;);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error);<br>          &#125;<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === FULFILLED) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> res = onFulfilled(self.value);<br>            <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> myPromise) &#123;<br>              res.then(resolve, reject);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              resolve(res);<br>            &#125;<br>          &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          reject(error);<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === REJECTED) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> res = onRejected(self.reason);<br>            <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> myPromise) &#123;<br>              res.then(resolve, reject);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              reject(res);<br>            &#125;<br>          &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          reject(error);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(reason));<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> myPromise) <span class="hljs-keyword">return</span> value;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> promisesLength = promises.length;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(promisesLength);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, i</span>) =&gt;</span> &#123;<br>        myPromise<br>          .resolve(promise)<br>          .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            result[i] = res;<br>            count++;<br>            <span class="hljs-keyword">if</span> (count === promisesLength) &#123;<br>              resolve(result);<br>            &#125;<br>          &#125;)<br>          .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            reject(err);<br>          &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>        myPromise<br>          .resolve(promise)<br>          .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            resolve(res);<br>          &#125;)<br>          .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            reject(err);<br>          &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">3</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br>myPromise.all([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).then(<span class="hljs-function">(<span class="hljs-params">[res1, res2, res3]</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res1, res2, res3);<br>&#125;);<br><br>myPromise.race([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章的目的是解剖 Promise 源码，起因也是最近秋招被问到了让手写 Promise，另外在网上看到的 Promise 源码或多或少有些小问题，也就是没有完全遵循 Promise/A+规范。<br>代码会完全使用<code>ES6</code>语法，主要分以下几个模块：</p><ul><li>整体分析（为代码书写铺路）</li><li>实现初版（构造函数大致功能亿完善）</li><li>支持异步和链式调用（完善 then 方法）</li><li>实现 catch 方法</li><li>实现 Promise.resolve()</li><li>实现 Promise.reject()</li><li>实现 Promise.all()</li><li>实现 Promise.race()</li></ul><h2 id="一、整体分析"><a href="#一、整体分析" class="headerlink" title="一、整体分析"></a>一、整体分析</h2><p>所谓 Promise 就是一个容器，有三个状态：<strong>PENDING</strong>（进行中）、<strong>FULFILLED</strong>（成功）、<strong>REJECTED</strong>（失败），里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，有两大特点：</p><ul><li>容器状态不受外界影响</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果</li></ul><p>来看下 Promise 的用法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 成功则执行resolve，否则指定reject</span><br>&#125;).<span class="hljs-keyword">then</span>(<br> <span class="hljs-function"> <span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve对应触发函数的执行</span><br>  &#125;,<br> <span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// reject对应触发函数的执行</span><br>  &#125;<br>).<span class="hljs-keyword">then</span>(<br>  <span class="hljs-comment">// 支持链式调用</span><br> <span class="hljs-function"> <span class="hljs-params">res</span> =&gt;</span> &#123;<br><br>  &#125;<br>).catch(<br> <span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> console.log(err)<br>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>all(<span class="hljs-literal">[<span class="hljs-identifier">promise1</span>, <span class="hljs-identifier">promise2</span>, <span class="hljs-operator">...</span>]</span>).<span class="hljs-keyword">then</span><span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>race(<span class="hljs-literal">[<span class="hljs-identifier">promise1</span>, <span class="hljs-identifier">promise2</span>, <span class="hljs-operator">...</span>]</span>).<span class="hljs-keyword">then</span><span class="hljs-literal">()</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>通过用法不难分析出：</p><ul><li>Promise 构造函数接受一个函数参数<strong>exector</strong>，exector 接受<strong>resolve</strong>和<strong>reject</strong>两个函数并<strong>立即执行</strong>，通过<strong>resolve/reject</strong>改变状态</li><li>状态改变后，触发原型链上的<code>then、catch</code>方法</li><li>Promise 类拥有静态方法<code>resolve、reject、all、race</code></li></ul><p>那么可以写出大致结构代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">exector</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">() =&gt;</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">() =&gt;</span> &#123;<br>    &#125;<br>    exector(resolve, reject);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params"></span>)</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>() &#123;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params"></span>)</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params"></span>)</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params"></span>)</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>之后在此基础上补充代码。</p><h2 id="二、实现初版"><a href="#二、实现初版" class="headerlink" title="二、实现初版"></a>二、实现初版</h2><p>首先引入三种状态，完善<code>resolve</code>、<code>reject</code>函数，最后在构造函数内执行<code>exector(resolve, reject)</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义三种状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;      <span class="hljs-comment">// 进行中</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;  <span class="hljs-comment">// 已成功</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;    <span class="hljs-comment">// 已失败</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(exector) &#123;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-keyword">this</span>.status = PENDING;<br>    <span class="hljs-comment">// 将成功、失败结果放在this上，便于then、catch访问</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<br>    <span class="hljs-keyword">this</span>.reason = undefined;<br>    <span class="hljs-keyword">const</span> resolve = value =&gt; &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-keyword">this</span>.status = FULFILLED;<br>        <span class="hljs-keyword">this</span>.value = value;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = reason =&gt; &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-keyword">this</span>.status = REJECTED;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 立即执行exector</span><br>    <span class="hljs-comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span><br>    exector(resolve, reject);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>注意：<code>exector(resolve, reject);</code>执行可能会报错，所以需要使用<code>try</code>包括一下，有报错<code>reject</code>抛出去。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">constructor</span>(exector) &#123;<br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-keyword">this</span>.status = PENDING;<br>  <span class="hljs-comment">// 将成功、失败结果放在this上，便于then、catch访问</span><br>  <span class="hljs-keyword">this</span>.value = undefined;<br>  <span class="hljs-keyword">this</span>.reason = undefined;<br>  <span class="hljs-keyword">const</span> resolve = value =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">this</span>.status = FULFILLED;<br>      <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> reject = reason =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">this</span>.status = REJECTED;<br>      <span class="hljs-keyword">this</span>.reason = reason;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 修改代码</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 立即执行executor</span><br>    <span class="hljs-comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span><br>    exector(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-comment">// executor执行出错，将错误内容reject抛出去</span><br>    reject(e);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>此时可以使用<code>then</code>进行捕获了，<code>then</code>接收两个函数，分别对应<code>FULFILLED</code>和<code>REJECTED</code>状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>().then(<br>  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;&#125;,<br>  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;&#125;,<br>)<br>复制代码<br></code></pre></td></tr></table></figure><p>注意：<code>then</code>、<code>catch</code>是微任务，这里使用<strong>setTimeout</strong>模拟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>  <span class="hljs-comment">// then是微任务，这里用setTimeout模拟</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === FULFILLED) &#123;<br>      <span class="hljs-comment">// FULFILLED状态下才执行</span><br>      onFulfilled(<span class="hljs-built_in">this</span>.value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === REJECTED) &#123;<br>      <span class="hljs-comment">// REJECTED状态下才执行</span><br>      onRejected(<span class="hljs-built_in">this</span>.reason);<br>    &#125;<br>  &#125;)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>OK，初版已经完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义三种状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;      <span class="hljs-comment">// 进行中</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;  <span class="hljs-comment">// 已成功</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;    <span class="hljs-comment">// 已失败</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(exector) &#123;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-keyword">this</span>.status = PENDING;<br>    <span class="hljs-comment">// 将成功、失败结果放在this上，便于then、catch访问</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<br>    <span class="hljs-keyword">this</span>.reason = undefined;<br>    <span class="hljs-keyword">const</span> resolve = value =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>        <span class="hljs-keyword">this</span>.status = FULFILLED;<br>        <span class="hljs-keyword">this</span>.value = value;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = reason =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>        <span class="hljs-keyword">this</span>.status = REJECTED;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 立即执行executor</span><br>      <span class="hljs-comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span><br>      exector(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-comment">// executor执行出错，将错误内容reject抛出去</span><br>      reject(e);<br>    &#125;<br>  &#125;<br>  then(onFulfilled, onRejected) &#123;<br>    <span class="hljs-comment">// then是微任务，这里用setTimeout模拟</span><br>    setTimeout(() =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>        <span class="hljs-comment">// FULFILLED状态下才执行</span><br>        onFulfilled(<span class="hljs-keyword">this</span>.value);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>        <span class="hljs-comment">// REJECTED状态下才执行</span><br>        onRejected(<span class="hljs-keyword">this</span>.reason);<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>可以拿数据测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? resolve(<span class="hljs-number">1</span>) : reject(-<span class="hljs-number">1</span>);<br>&#125;).then(<br>  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res),<br>  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err),<br>)<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="三、支持异步和链式调用"><a href="#三、支持异步和链式调用" class="headerlink" title="三、支持异步和链式调用"></a>三、支持异步和链式调用</h2><p>此时初版还有三个方向需要完善：</p><ol><li>Promise 内部异步代码执行的问题。</li><li>Promise 的链式调用</li><li>值传透</li></ol><h3 id="支持异步代码"><a href="#支持异步代码" class="headerlink" title="支持异步代码"></a>支持异步代码</h3><p>开发中经常会将接口放于<code>promise</code>内部，等接口请求响应成功把数据<code>resolve</code>出去，或失败时把数据<code>reject</code>出去，此时<code>then</code>、<code>catch</code>才会进行捕获。<br>而现在的代码，<code>promise</code>内部如果有异步代码执行后才<code>resolve</code>，<code>then</code>不会等待异步代码执行完毕会直接执行，所以此时状态是<code>PENDING</code>，不会触发<code>then</code>的回调函数。<br>新增<strong>onFulfilledCallbacks</strong>、<strong>onRejectedCallbacks</strong>维护成功态、失败态任务队列：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义三种状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;      <span class="hljs-comment">// 进行中</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;  <span class="hljs-comment">// 已成功</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;    <span class="hljs-comment">// 已失败</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(exector) &#123;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-keyword">this</span>.status = PENDING;<br>    <span class="hljs-comment">// 将成功、失败结果放在this上，便于then、catch访问</span><br>    <span class="hljs-keyword">this</span>.value = undefined;<br>    <span class="hljs-keyword">this</span>.reason = undefined;<br><br>    <span class="hljs-comment">// 新增代码：</span><br>    <span class="hljs-comment">// 成功态回调函数队列</span><br>    <span class="hljs-keyword">this</span>.onFulfilledCallbacks = [];<br>    <span class="hljs-comment">// 失败态回调函数队列</span><br>    <span class="hljs-keyword">this</span>.onRejectedCallbacks = [];<br>    <span class="hljs-keyword">const</span> resolve = value =&gt; &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-keyword">this</span>.status = FULFILLED;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-comment">// 新增代码：</span><br>        <span class="hljs-comment">// 成功态函数依次执行</span><br>        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.forEach(fn =&gt; fn(<span class="hljs-keyword">this</span>.value));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = reason =&gt; &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-keyword">this</span>.status = REJECTED;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-comment">// 新增代码：</span><br>        <span class="hljs-comment">// 失败态函数依次执行</span><br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks.forEach(fn =&gt; fn(<span class="hljs-keyword">this</span>.reason))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 立即执行executor</span><br>      <span class="hljs-comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span><br>      exector(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-comment">// executor执行出错，将错误内容reject抛出去</span><br>      reject(e);<br>    &#125;<br>  &#125;<br>  then(onFulfilled, onRejected) &#123;<br>    <span class="hljs-comment">// then是微任务，这里用setTimeout模拟</span><br>    setTimeout(() =&gt; &#123;<br>      <span class="hljs-comment">// 新增代码：</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-comment">// 状态是PENDING下执行</span><br>        <span class="hljs-comment">// 说明promise内部有异步代码执行，还未改变状态，添加到成功/失败回调任务队列即可</span><br>        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(onRejected);<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>        <span class="hljs-comment">// FULFILLED状态下才执行</span><br>        onFulfilled(<span class="hljs-keyword">this</span>.value);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>        <span class="hljs-comment">// REJECTED状态下才执行</span><br>        onRejected(<span class="hljs-keyword">this</span>.reason);<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> promise = new Promise((resolve, reject) =&gt; &#123;<br>  setTimeout(() =&gt; resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br>&#125;).then(<br>  res =&gt; console.log(res)<br>)<br><span class="hljs-comment">// 1</span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><p><code>Promise</code>的一大优势就是支持链式调用，具体来说就是<code>then</code>方法的具体实现，实际上是返回了一个<code>Promise</code>，需要注意的几个点：</p><ol><li>保存之前 promise 实例的引用，即保存<code>this</code></li><li>根据<code>then</code>回调函数执行的返回值</li></ol><ul><li>如果是 promise 实例，那么返回的下一个 promise 实例会等待这个 promise 状态发生变化</li><li>如果不是 promise 实例，根据目前情况直接执行<code>resolve</code>或<code>reject</code></li></ul><p>完善<code>then</code>函数：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">then</span>(onFulfilled, onRejected) &#123;<br>  <span class="hljs-regexp">//</span> 保存<span class="hljs-built_in">this</span><br>  const self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (self.status === PENDING) &#123;<br>      self.onFulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">try</span>捕获错误<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-regexp">//</span> 模拟微任务<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            const result = onFulfilled(self.value);<br>            <span class="hljs-regexp">//</span> 分两种情况：<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">1.</span> 回调函数返回值是<span class="hljs-built_in">Promise</span>，执行<span class="hljs-keyword">then</span>操作<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">2.</span> 如果不是<span class="hljs-built_in">Promise</span>，调用新<span class="hljs-built_in">Promise</span>的resolve函数<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : resolve(result);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;);<br>      self.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 以下同理<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            const result = onRejected(self.reason);<br>            <span class="hljs-regexp">//</span> 不同点：此时是reject<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : reject(result);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === FULFILLED) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          const result = onFulfilled(self.value);<br>          result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : resolve(result);<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === REJECT)&#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          const result = onRejected(self.error);<br>          result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : reject(result);<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="值传透"><a href="#值传透" class="headerlink" title="值传透"></a>值传透</h3><p><code>Promise</code>支持值穿透：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promsie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br>.then(<span class="hljs-number">2</span>)<br>.then(<span class="hljs-number">3</span>)<br>.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value)<br>&#125;)<br><span class="hljs-comment">// 1</span><br>复制代码<br></code></pre></td></tr></table></figure><p><code>then</code>参数期望是函数，传入非函数则会发生值穿透。值传透可以理解为，当传入 then 的不是函数的时候，这个 then 是无效的。<br>原理上是当 then 中传入的不算函数，则这个<code>promise</code>返回上一个<code>promise</code>的值，这就是发生值穿透的原因，所以只需要对<code>then</code>的两个参数进行设置就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>? onRejected:<br>    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(reason <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? reason.message:reason) &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>完整的 then 函数代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">then</span>(onFulfilled, onRejected) &#123;<br>  onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value;<br>  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>? onRejected:<br>    reason =&gt; &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(reason <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? reason.message:reason) &#125;<br>  <span class="hljs-regexp">//</span> 保存<span class="hljs-built_in">this</span><br>  const self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (self.status === PENDING) &#123;<br>      self.onFulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">try</span>捕获错误<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-regexp">//</span> 模拟微任务<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            const result = onFulfilled(self.value);<br>            <span class="hljs-regexp">//</span> 分两种情况：<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">1.</span> 回调函数返回值是<span class="hljs-built_in">Promise</span>，执行<span class="hljs-keyword">then</span>操作<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">2.</span> 如果不是<span class="hljs-built_in">Promise</span>，调用新<span class="hljs-built_in">Promise</span>的resolve函数<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : resolve(result);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;);<br>      self.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 以下同理<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            const result = onRejected(self.reason);<br>            <span class="hljs-regexp">//</span> 不同点：此时是reject<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : reject(result);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === FULFILLED) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>          const result = onFulfilled(self.value);<br>          result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : resolve(result);<br>        &#125;);<br>      &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        reject(e);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === REJECTED)&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>          const result = onRejected(self.reason);<br>          result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.<span class="hljs-keyword">then</span>(resolve, reject) : reject(result);<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        reject(e);<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="四、实现-catch-方法"><a href="#四、实现-catch-方法" class="headerlink" title="四、实现 catch()方法"></a>四、实现 catch()方法</h2><p><code>Promise.prototype.catch</code>就是<code>Promise.prototype.then(null, onRejected)</code>的别名，所以实现就很简单了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">catch</span>(onRejected) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="五、Promise-resolve"><a href="#五、Promise-resolve" class="headerlink" title="五、Promise.resolve()"></a>五、Promise.resolve()</h2><p>这里就不考虑参数是<code>thenable</code>对象了，那么参数有两种情况：</p><ol><li><code>Promise</code>实例</li><li>不是<code>Promise</code>实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>    <span class="hljs-comment">// 如果是Promise实例，直接返回</span><br>    <span class="hljs-keyword">return</span> value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="六、Promise-reject"><a href="#六、Promise-reject" class="headerlink" title="六、Promise.reject()"></a>六、Promise.reject()</h2><p><code>Promise.reject</code>也会返回一个 Promise 实例，状态为<code>REJECTED</code>。<br>与<code>Promise.resolve</code>不同的是，<code>Promise.reject</code>方法的参数会原封不动地作为<code>reject</code>的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(reason);<br>  &#125;)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="七、Promise-all"><a href="#七、Promise-all" class="headerlink" title="七、Promise.all()"></a>七、Promise.all()</h2><p>返回一个 promise 对象，只有当所有 promise 都成功时返回的 promise 状态才成功，需要注意的点是：</p><ol><li>所有的 promise 状态变为<code>FULFILLED</code>，返回的 promise 状态才变为<code>FULFILLED</code>。</li><li>一个 promise 状态变为<code>REJECTED</code>，返回的 promise 状态就变为<code>REJECTED</code>。</li><li>数组成员不一定都是 promise，需要使用<code>Promise.resolve()</code>处理。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> len = promiseArr.length;<br>  <span class="hljs-keyword">const</span> values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);<br>  <span class="hljs-comment">// 记录已经成功执行的promise个数</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// Promise.resolve()处理，确保每一个都是promise实例</span><br>      <span class="hljs-built_in">Promise</span>.resolve(promiseArr[i]).then(<br>        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>          values[i] = val;<br>          count++;<br>          <span class="hljs-comment">// 如果全部执行完，返回promise的状态就可以改变了</span><br>          <span class="hljs-keyword">if</span> (count === len) resolve(values);<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err),<br>      );<br>    &#125;<br>  &#125;)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="八、Promise-race"><a href="#八、Promise-race" class="headerlink" title="八、Promise.race()"></a>八、Promise.race()</h2><p><code>Promise.race()</code>实现就比较简单了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">Promise</span>.resolve(p).then(<br>        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> resolve(val),<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err),<br>      )<br>    &#125;)<br>  &#125;)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="九、完整代码"><a href="#九、完整代码" class="headerlink" title="九、完整代码"></a>九、完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义三种状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;      <span class="hljs-comment">// 进行中</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;  <span class="hljs-comment">// 已成功</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;    <span class="hljs-comment">// 已失败</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">exector</span>)</span> &#123;<br>    <span class="hljs-comment">// 初始化状态</span><br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-comment">// 将成功、失败结果放在this上，便于then、catch访问</span><br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 成功态回调函数队列</span><br>    <span class="hljs-built_in">this</span>.onFulfilledCallbacks = [];<br>    <span class="hljs-comment">// 失败态回调函数队列</span><br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks = [];<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = FULFILLED;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-comment">// 成功态函数依次执行</span><br>        <span class="hljs-built_in">this</span>.onFulfilledCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(<span class="hljs-built_in">this</span>.value));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有进行中状态才能更改状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>        <span class="hljs-built_in">this</span>.status = REJECTED;<br>        <span class="hljs-built_in">this</span>.reason = reason;<br>        <span class="hljs-comment">// 失败态函数依次执行</span><br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(<span class="hljs-built_in">this</span>.reason))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 立即执行executor</span><br>      <span class="hljs-comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span><br>      exector(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-comment">// executor执行出错，将错误内容reject抛出去</span><br>      reject(e);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>? onRejected:<br>      <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(reason <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? reason.message:reason) &#125;<br>    <span class="hljs-comment">// 保存this</span><br>    <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (self.status === PENDING) &#123;<br>        self.onFulfilledCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// try捕获错误</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟微任务</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-keyword">const</span> result = onFulfilled(self.value);<br>              <span class="hljs-comment">// 分两种情况：</span><br>              <span class="hljs-comment">// 1. 回调函数返回值是Promise，执行then操作</span><br>              <span class="hljs-comment">// 2. 如果不是Promise，调用新Promise的resolve函数</span><br>              result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.then(resolve, reject) : resolve(result);<br>            &#125;)<br>          &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>            reject(e);<br>          &#125;<br>        &#125;);<br>        self.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 以下同理</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-keyword">const</span> result = onRejected(self.reason);<br>              <span class="hljs-comment">// 不同点：此时是reject</span><br>              result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.then(resolve, reject) : reject(result);<br>            &#125;)<br>          &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>            reject(e);<br>          &#125;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === FULFILLED) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> result = onFulfilled(self.value);<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.then(resolve, reject) : resolve(result);<br>          &#125;);<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === REJECTED)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> result = onRejected(self.reason);<br>            result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? result.then(resolve, reject) : reject(result);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>      <span class="hljs-comment">// 如果是Promise实例，直接返回</span><br>      <span class="hljs-keyword">return</span> value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      reject(reason);<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> len = promiseArr.length;<br>    <span class="hljs-keyword">const</span> values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);<br>    <span class="hljs-comment">// 记录已经成功执行的promise个数</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">// Promise.resolve()处理，确保每一个都是promise实例</span><br>        <span class="hljs-built_in">Promise</span>.resolve(promiseArr[i]).then(<br>          <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            values[i] = val;<br>            count++;<br>            <span class="hljs-comment">// 如果全部执行完，返回promise的状态就可以改变了</span><br>            <span class="hljs-keyword">if</span> (count === len) resolve(values);<br>          &#125;,<br>          <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err),<br>        );<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">Promise</span>.resolve(p).then(<br>          <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> resolve(val),<br>          <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err),<br>        )<br>      &#125;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作者：洛霞<br>链接：<a href="https://juejin.im/post/6860037916622913550">https://juejin.im/post/6860037916622913550</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>伪元素及伪类</title>
    <link href="/2020/09/22/yuque/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8F%8A%E4%BC%AA%E7%B1%BB/"/>
    <url>/2020/09/22/yuque/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%8F%8A%E4%BC%AA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903929289900046">https://juejin.im/post/6844903929289900046</a></p><h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近看一些前端面试题，经常有问到伪类和伪元素的作用以及两者区别，所以特意找了一些资料学习。下面是我对这一方面知识的理解和总结，可能会有遗漏或者一些出入，欢迎大家指正，相互交流～</p><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><blockquote><p>A psuedo-class is a selector that selects elements that are in a specific state, e.g. they are the first element of their type, or they are being hovered over by the mouse pointer. They tend to act as if you had applied a class to some part of your document, often helping you cut down on excess classes in your markup, and giving you more flexible, maintainable code.</p></blockquote><p>MDN 上面阐述的很明确，伪类就是一个选择处于特定状态的元素的选择器，比如某一个 clsss 的第一个元素，某个被 hover 的元素等等…，我们可以理解成一个特定的 CSS 类，但与普通的类不一样，它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类</p><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><blockquote><p>Pseudo-elements behave in a similar way, however they act as if you had added a whole new HTML element into the markup, rather than applying a class to existing elements. Pseudo-elements start with a double colon ::</p></blockquote><p>伪元素和伪类很像，但是伪元素类似于增添一个新的 DOM 节点到 DOM 树中，而不是改变元素的状态。注意了，这里是类似，而不是真的增加一个节点，这也是其被称为伪元素的原因（实质上，元素被创建在文档外）。</p><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p>伪类是操作文档中已有的元素，而伪元素是创建了一个文档外的元素，两者最关键的区别就是这点。此外，为了书写 CSS 时进行区分，一般伪类是单冒号，如<code>:hover</code>，而伪元素是双冒号<code>::before</code>。一般大部分伪类强制使用单冒号，大部分伪元素单冒号和双冒号都可以，但是为了区分，建议按照规范书写。</p><h4 id="伪类和伪元素都有哪些？"><a href="#伪类和伪元素都有哪些？" class="headerlink" title="伪类和伪元素都有哪些？"></a>伪类和伪元素都有哪些？</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600789345615-b477439a-900d-4094-9433-7f6fa41a4c2e.webp#align=left&display=inline&height=537&margin=%5Bobject%20Object%5D&originHeight=537&originWidth=594&size=0&status=done&style=none&width=594"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600789345628-807cb2bc-1307-4e80-9ff2-6a4cff4055f4.webp#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&originHeight=212&originWidth=491&size=0&status=done&style=none&width=491"></p><ul><li><p>伪类</p><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>:avtive</td><td>匹配被用户激活的元素（比如点击）</td></tr><tr><td>:blank</td><td>匹配空的 input</td></tr><tr><td>:checked</td><td>匹配被选中的 radio 或者 checkbox</td></tr><tr><td>:disabled</td><td>匹配处于不可用状态的可交互元素</td></tr><tr><td>:empty</td><td>匹配没有子元素的元素</td></tr><tr><td>:enabled</td><td>匹配处于可用状态的可交互元素</td></tr><tr><td>:first-child</td><td>匹配在兄弟元素中处于第一的元素</td></tr><tr><td>:first-of-type</td><td>匹配在它的兄弟元素中是某个类型中的第一个的元素</td></tr><tr><td>:focus</td><td>匹配获取焦点的的元素</td></tr><tr><td>:focus-visible</td><td>匹配获取焦点且能被用户看到的元素</td></tr><tr><td>:hover</td><td>匹配用户在此悬停或者触摸的元素</td></tr><tr><td>:invalid</td><td>匹配处于不合法状态的元素，比如<code>&lt;input&gt;</code>正则校验不通过</td></tr><tr><td>:lang</td><td>根据文档语言匹配元素</td></tr><tr><td>:last-child</td><td>匹配在兄弟元素中处于最后的元素</td></tr><tr><td>:last-of-type</td><td>匹配在它的兄弟元素中是某个类型中的最后一个的元素</td></tr><tr><td>:link</td><td>匹配没有被访问过的链接</td></tr><tr><td>:is()</td><td>匹配符合结果的元素</td></tr><tr><td>:not()</td><td>匹配符合结果之外的元素</td></tr><tr><td>:nth-child(n)</td><td>匹配父元素的第 n 个子元素。n 可以是一个数字、一个关键字或一个公式</td></tr><tr><td>:nth-of-type(n)</td><td>匹配父元素的某种类型元素中的第 n 个子元素。n 可以是一个数字、一个关键字或一个 公式</td></tr><tr><td>:nth-last-child(n)</td><td>与 nth-child()类似，从后往前数</td></tr><tr><td>:nth-last-of-type(n)</td><td>与 nth-last-of-type-child()类似，从后往前数</td></tr><tr><td>:only-child</td><td>匹配没有兄弟元素的元素</td></tr><tr><td>:only-of-type</td><td>匹配一个元素，该元素是其兄弟元素中唯一的一个类型。</td></tr><tr><td>:placeholder-shown</td><td>匹配显示默认占位符的表单元素</td></tr><tr><td>:required</td><td>匹配内容为必填的表单元素</td></tr><tr><td>:root</td><td>匹配根元素</td></tr><tr><td>:valid</td><td>匹配处于合法状态的元素</td></tr><tr><td>:target</td><td>匹配符合当前 url 的锚点元素</td></tr><tr><td>:visited</td><td>匹配被访问过的元素</td></tr></tbody></table></li><li><p>伪元素</p><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>::before</td><td>匹配在原始元素的实际内容之后出现的区域</td></tr><tr><td>::after</td><td>匹配在原始元素的实际内容之前出现的区域</td></tr><tr><td>::first-letter</td><td>匹配元素的第一个字母</td></tr><tr><td>::first-line</td><td>匹配元素第一行</td></tr><tr><td>::selection</td><td>匹配被选中的文本或者区域</td></tr></tbody></table></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单页面与多页面的优缺点比较</title>
    <link href="/2020/09/22/yuque/%E5%8D%95%E9%A1%B5%E9%9D%A2%E4%B8%8E%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83/"/>
    <url>/2020/09/22/yuque/%E5%8D%95%E9%A1%B5%E9%9D%A2%E4%B8%8E%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://blog.csdn.net/mikibiubiu/article/details/102215059">https://blog.csdn.net/mikibiubiu/article/details/102215059</a></p><h2 id="单页面应用（SinglePage-Web-Application，SPA）"><a href="#单页面应用（SinglePage-Web-Application，SPA）" class="headerlink" title="单页面应用（SinglePage Web Application，SPA）"></a>单页面应用（SinglePage Web Application，SPA）</h2><p>只有一张 Web 页面的应用，是一种从 Web 服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css 等)仅需加载一次，常用于 PC 端官网、购物等网站<br>如图:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600788858088-704df2d8-a491-4af2-aacc-1f0a76f094f5.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&originHeight=319&originWidth=600&size=0&status=done&style=none&width=600"><br>单页面应用结构视图</p><h2 id="多页面应用（MultiPage-Application，MPA）"><a href="#多页面应用（MultiPage-Application，MPA）" class="headerlink" title="多页面应用（MultiPage Application，MPA）"></a>多页面应用（MultiPage Application，MPA）</h2><p>多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载，常用于 app 或 客户端等<br>如图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600788858018-38331ca2-bea8-4fe7-bfdd-e37ae3ceadc2.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&originHeight=297&originWidth=600&size=0&status=done&style=none&width=600"><br>多页面应用结构视图<br>具体对比分析：</p><table><thead><tr><th></th><th>单页面应用（SinglePage Web Application，SPA）</th><th>多页面应用（MultiPage Application，MPA）</th></tr></thead><tbody><tr><td>组成</td><td>一个外壳页面和多个页面片段组成</td><td>多个完整页面构成</td></tr><tr><td>资源共用(css,js)</td><td>共用，只需在外壳部分加载</td><td>不共用，每个页面都需要加载</td></tr><tr><td>刷新方式</td><td>页面局部刷新或更改</td><td>整页刷新</td></tr><tr><td>url 模式</td><td>a.com/#/pageone a.com/#/pagetwo</td><td>a.com/pageone.html a.com/pagetwo.html</td></tr><tr><td>用户体验</td><td>页面片段间的切换快，用户体验良好</td><td>页面切换加载缓慢，流畅度不够，用户体验比较差</td></tr><tr><td>转场动画</td><td>容易实现</td><td>无法实现</td></tr><tr><td>数据传递</td><td>容易</td><td>依赖 url 传参、或者 cookie 、localStorage 等</td></tr><tr><td>搜索引擎优化(SEO)</td><td>需要单独方案、实现较为困难、不利于 SEO 检索 可利用服务器端渲染(SSR)优化</td><td>实现方法简易</td></tr><tr><td>试用范围</td><td>高要求的体验度、追求界面流畅的应用</td><td>适用于追求高度支持搜索引擎的应用</td></tr><tr><td>开发成本</td><td>较高，常需借助专业的框架</td><td>较低 ，但页面重复代码多</td></tr><tr><td>维护成本</td><td>相对容易</td><td>相对复杂</td></tr></tbody></table><p>单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于 pc 端。<br>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p><h2 id="单页面的优点："><a href="#单页面的优点：" class="headerlink" title="单页面的优点："></a>单页面的优点：</h2><p>1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点 spa 对服务器压力较小<br>2，前后端分离<br>3，页面效果会比较炫酷（比如切换页面内容时的专场动画）</p><h2 id="单页面缺点："><a href="#单页面缺点：" class="headerlink" title="单页面缺点："></a>单页面缺点：</h2><p>1，不利于 seo<br>2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）<br>3，初次加载时耗时多<br>4，页面复杂度提高很多</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>script标签async和defer的区别及作用</title>
    <link href="/2020/09/22/yuque/script%E6%A0%87%E7%AD%BEasync%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
    <url>/2020/09/22/yuque/script%E6%A0%87%E7%AD%BEasync%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.cnblogs.com/leungUwah/p/10798585.html">https://www.cnblogs.com/leungUwah/p/10798585.html</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。<br>2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。<br>3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发** DOMContentLoaded **事件。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br>在加载多个 JS 脚本的时候，<code>**async**</code>是<code>**无顺序**</code>的加载，而<code>**defer**</code>是<code>**有顺序**</code>的加载。</p><ul><li><p>当 script 中有 defer 属性时，脚本的加载过程和文档加载是异步发生的，<strong>等到文档解析完(DOMContentLoaded 事件发生)脚本才开始执行</strong>。</p></li><li><p>当 script 有 async 属性时，脚本的加载过程和文档加载也是异步发生的。但脚本下载完成后会<strong>停止 HTML 解析，执行脚本，脚本解析完继续 HTML 解析</strong>。</p></li><li><p>当 script 同时有 async 和 defer 属性时，执行效果和 async 一致。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实现a==1&amp;&amp;a==2&amp;&amp;a==3及a===1&amp;&amp;a===2&amp;&amp;a===3</title>
    <link href="/2020/09/22/yuque/%E5%AE%9E%E7%8E%B0a==1&amp;&amp;a==2&amp;&amp;a==3%E5%8F%8Aa===1&amp;&amp;a===2&amp;&amp;a===3/"/>
    <url>/2020/09/22/yuque/%E5%AE%9E%E7%8E%B0a==1&amp;&amp;a==2&amp;&amp;a==3%E5%8F%8Aa===1&amp;&amp;a===2&amp;&amp;a===3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.val = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A();<br><br>a.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.val);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.val++;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(a == <span class="hljs-number">0</span> &amp;&amp; a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">Object</span>.defineProperty(globalThis, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">//0 1 2</span><br>    <span class="hljs-keyword">return</span> index++;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(a === <span class="hljs-number">0</span> &amp;&amp; a === <span class="hljs-number">1</span> &amp;&amp; a === <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实现add(1)(2)(3)或add(1)(2)(3).done()</title>
    <link href="/2020/09/22/yuque/%E5%AE%9E%E7%8E%B0add(1)(2)(3)%E6%88%96add(1)(2)(3).done()/"/>
    <url>/2020/09/22/yuque/%E5%AE%9E%E7%8E%B0add(1)(2)(3)%E6%88%96add(1)(2)(3).done()/</url>
    
    <content type="html"><![CDATA[<h1 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = num1;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num2</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num2) &#123;<br>      res += num2;<br>      <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>  &#125;<br>  sum.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  sum.done = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>));<br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>).done());<br></code></pre></td></tr></table></figure><h1 id="科里化"><a href="#科里化" class="headerlink" title="科里化"></a>科里化</h1><p>科里化实现无限，add(1,2)(3,4,5)(6)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args1</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [...args1];<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args2</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> ([...args2].length &gt; <span class="hljs-number">0</span>) &#123;<br>      res = [...args1, ...args2];<br>      <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>  &#125;<br>  sum.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> res.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  &#125;;<br>  sum.done = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> res.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月22日</title>
    <link href="/2020/09/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8822%E6%97%A5/"/>
    <url>/2020/09/22/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 48. 最长不含重复字符的子字符串</p><span id="more"></span><h1 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br><strong>示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>s.length &lt;= 40000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="优化的滑动窗口（哈希表）"><a href="#优化的滑动窗口（哈希表）" class="headerlink" title="优化的滑动窗口（哈希表）"></a>优化的滑动窗口（哈希表）</h4><p>我们可以使用哈希表记录每个字符的下一个索引，然后尽量向右移动尾指针来拓展窗口，并更新窗口的最大长度。如果尾指针指向的元素重复，则将头指针直接移动到窗口中重复元素的右侧。<br><strong>算法</strong><br>tail 指针向末尾方向移动；<br>如果尾指针指向的元素存在于哈希表中：<br>head 指针<code>**跳跃到重复字符的下一位**</code>；<br>更新哈希表和窗口长度。<br>作者：z1m<br>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/</a></p><p>注意判断<code>map.get(s[end]) &gt;= start</code>时，即点在窗口中时，才是出现重复值。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>,<br>    end = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">while</span> (end &lt; s.length) &#123;<br>    <span class="hljs-comment">// 如果哈希表中存在该节点，且取到的下标大于头结点，说明在本窗口中重复了，设置窗口左侧和右侧到重复节点的右边一个位置</span><br>    <span class="hljs-keyword">if</span> (map.get(s[end]) &gt;= start) &#123;<br>      start = map.get(s[end]) + <span class="hljs-number">1</span>;<br>      map.set(s[end], end);<br>      <span class="hljs-comment">// 如果不存在，令当前哈希表中的下标加一，求当前窗口大小，判断是否大于最大大小</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.set(s[end], end);<br>      res = <span class="hljs-built_in">Math</span>.max(res, end - start + <span class="hljs-number">1</span>);<br>    &#125;<br>    end++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生手动实现轮播图</title>
    <link href="/2020/09/22/yuque/%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <url>/2020/09/22/yuque/%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-list&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;swiperList&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">              <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=518601442,146924060&amp;fm=26&amp;gp=0.jpg&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            /&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">              <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=518601442,146924060&amp;fm=26&amp;gp=0.jpg&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;2&quot;</span></span><br><span class="hljs-tag">            /&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">              <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=518601442,146924060&amp;fm=26&amp;gp=0.jpg&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;3&quot;</span></span><br><span class="hljs-tag">            /&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;swiper-dot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dotList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handlePrev()&quot;</span>&gt;</span>上一张<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleNext()&quot;</span>&gt;</span>下一张<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">let</span> imageCount = <span class="hljs-number">0</span>;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> interval = <span class="hljs-number">2000</span>;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        handleNext();</span><br><span class="javascript">      &#125;, interval);</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> handlePrev = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        index = index === <span class="hljs-number">0</span> ? imageCount - <span class="hljs-number">1</span> : index - <span class="hljs-number">1</span>;</span><br><span class="javascript">        change();</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> handleNext = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        index = index === imageCount - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : index + <span class="hljs-number">1</span>;</span><br><span class="javascript">        change();</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> change = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> dotItem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#dotList&quot;</span>).children;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> activeSwiperItem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#swiperList&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(dotItem);</span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dotItem.length; i++) &#123;</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (i === index) dotItem[i].className = <span class="hljs-string">&quot;swiper-dot-item active&quot;</span>;</span><br><span class="javascript">          <span class="hljs-keyword">else</span> dotItem[i].className = <span class="hljs-string">&quot;swiper-dot-item&quot;</span>;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> left = <span class="hljs-number">600</span> * index;</span><br><span class="javascript">        activeSwiperItem.setAttribute(<span class="hljs-string">&quot;style&quot;</span>, <span class="hljs-string">`left:-<span class="hljs-subst">$&#123;left&#125;</span>px;`</span>);</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> countImageNum = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> imageDoms = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#swiperList&quot;</span>);</span><br><span class="javascript">        imageCount = imageDoms.children.length;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(imageCount);</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> creatDotDoms = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> dotDom = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#dotList&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(dotDom);</span><br><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imageCount; i++) &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);</span><br><span class="javascript">          div.className = <span class="hljs-string">&quot;swiper-dot-item&quot;</span>;</span><br><span class="javascript">          dotDom.appendChild(div);</span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        countImageNum();</span><br><span class="javascript">        creatDotDoms();</span><br><span class="javascript">        change();</span><br><span class="javascript">      &#125;;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.swiper-container</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">        <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-selector-class">.swiper-list</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">        <span class="hljs-attribute">flex-wrap</span>: nowrap;</span><br><span class="css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">        <span class="hljs-attribute">transition</span>: left <span class="hljs-number">1s</span>;</span><br><span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      &#125;</span><br><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.swiper-item</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">list-style-type</span>: none;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-selector-class">.swiper-item</span> <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">      &#125;</span><br><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.swiper-dot</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;</span><br><span class="css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">        <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="css">      &#125;</span><br><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.swiper-dot-item</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;</span><br><span class="css">      &#125;</span><br><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.active</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;</span><br><span class="css">      &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对象扁平化</title>
    <link href="/2020/09/22/yuque/%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <url>/2020/09/22/yuque/%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatObj</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> flat = <span class="hljs-function">(<span class="hljs-params">obj, preKey</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || obj === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">Object</span>.entries(obj).forEach(<span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;object&quot;</span>)<br>        flat(val, <span class="hljs-string">`<span class="hljs-subst">$&#123;preKey ? preKey + <span class="hljs-string">&quot;.&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span><span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (res[key]) res[<span class="hljs-string">`<span class="hljs-subst">$&#123;preKey&#125;</span>.<span class="hljs-subst">$&#123;key&#125;</span>`</span>] = val;<br>        <span class="hljs-keyword">else</span> res[key] = val;<br>      &#125;<br>    &#125;);<br>  &#125;;<br>  flat(obj);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;123&quot;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>  <span class="hljs-attr">c</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">789</span>,<br>    <span class="hljs-attr">e</span>: &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">000</span>,<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(flatObj(obj)); <span class="hljs-comment">// &#123; a: &#x27;123&#x27;, b: &#x27;456&#x27;, &#x27;c.a&#x27;: 789, &#x27;c.e.a&#x27;: 0 &#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS中的常见继承方法</title>
    <link href="/2020/09/22/yuque/JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/"/>
    <url>/2020/09/22/yuque/JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文部分转自：<a href="https://juejin.im/post/6844903798624747528">https://juejin.im/post/6844903798624747528</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br>Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;person fun!&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>&#125;<br><br><span class="hljs-comment">// 1.构造函数继承，无法获得父类原型链上的参数</span><br><span class="hljs-keyword">let</span> Student = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>,name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-number">12</span>)<br><span class="hljs-built_in">console</span>.log(stu.name) <span class="hljs-comment">//zs 12</span><br><span class="hljs-built_in">console</span>.log(stu.getName()) <span class="hljs-comment">// stu.getName is not a cm-functionOps</span><br><br><span class="hljs-comment">// 2.原型链继承，无法向父类传递参数，可以调用父类原型链上的方法，只可以继承一个父类</span><br><span class="hljs-keyword">let</span> Student = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>Student.prototype = <span class="hljs-keyword">new</span> Person()<br>Student.prototype.constructor = Student<br>Student.prototype.stuFun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;student fun!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;123&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(stu.name) <span class="hljs-comment">// undefined 无法向父类传递参数</span><br><span class="hljs-built_in">console</span>.log(stu.getName()) <span class="hljs-comment">// person fun! return undefined</span><br><span class="hljs-built_in">console</span>.log(stu.stuFun()) <span class="hljs-comment">// student fun!</span><br><br><span class="hljs-number">3.</span>组合继承，ES6之前常用方案，重复调用两次父类性能损耗<br><span class="hljs-keyword">let</span> Student = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>,name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br>Student.prototype = <span class="hljs-keyword">new</span> Person()<br>Student.prototype.constructor = Student<br>Student.prototype.stuFun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;student fun!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;hhh&#x27;</span>,<span class="hljs-number">123</span>)<br><span class="hljs-built_in">console</span>.log(stu.name) <span class="hljs-comment">// undefined 无法向父类传递参数</span><br><span class="hljs-built_in">console</span>.log(stu.getName()) <span class="hljs-comment">// person fun! return hhh</span><br><span class="hljs-built_in">console</span>.log(stu.stuFun()) <span class="hljs-comment">// student fun!</span><br><br><span class="hljs-comment">// 4.原型式继承，使用ES5 Object.create 使用传入的对象作为__proto__，返回一个新对象。本质上是一个浅拷贝，所以引用类型是父子都可以更改的</span><br><span class="hljs-keyword">let</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>  <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-built_in">Object</span>.create(parent)<br>child.name = <span class="hljs-string">&#x27;child&#x27;</span><br><span class="hljs-built_in">console</span>.log(child.name) <span class="hljs-comment">// child</span><br><span class="hljs-built_in">console</span>.log(child.arr.pop()) <span class="hljs-comment">// [4]</span><br><span class="hljs-built_in">console</span>.log(parent.arr) <span class="hljs-comment">// [1,2,3]</span><br><span class="hljs-built_in">console</span>.log(parent.name) <span class="hljs-comment">// parent</span><br><span class="hljs-built_in">console</span>.log(child.getName()) <span class="hljs-comment">// child</span><br><span class="hljs-built_in">console</span>.log(parent.getName()) <span class="hljs-comment">// parent</span><br><br><span class="hljs-comment">// 5.寄生式继承，原型式继承的基础上添加属性或方法，再封装起来</span><br><span class="hljs-keyword">let</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>  <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> child = <span class="hljs-built_in">Object</span>.create(parent)<br>  child.childFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;add child function!&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> child<br>&#125;<br><br><span class="hljs-keyword">let</span> child = object(parent)<br>child.name = <span class="hljs-string">&#x27;child&#x27;</span><br><span class="hljs-built_in">console</span>.log(child.name) <span class="hljs-comment">// child</span><br><span class="hljs-built_in">console</span>.log(child.arr.pop()) <span class="hljs-comment">// [4]</span><br><span class="hljs-built_in">console</span>.log(parent.arr) <span class="hljs-comment">// [1,2,3]</span><br><span class="hljs-built_in">console</span>.log(parent.name) <span class="hljs-comment">// parent</span><br><span class="hljs-built_in">console</span>.log(child.getName()) <span class="hljs-comment">// child</span><br><span class="hljs-built_in">console</span>.log(parent.getName()) <span class="hljs-comment">// parent</span><br><span class="hljs-built_in">console</span>.log(child.childFn()); <span class="hljs-comment">// add child function!</span><br><br><span class="hljs-comment">// 6.寄生组合式继承，使用中继函数，免去两次调用父类构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>,name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">// 其实是一种原型链继承方式</span><br><span class="hljs-built_in">Object</span>.setPrototypeOf(Student.prototype,Person.prototype)<br><br><span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;yyy&#x27;</span>,<span class="hljs-number">12</span>)<br><span class="hljs-built_in">console</span>.log(stu.name,stu.age) <span class="hljs-comment">// yyy 12</span><br><span class="hljs-built_in">console</span>.log(stu.getName()) <span class="hljs-comment">// person fun! yyy</span><br><br><span class="hljs-comment">// 7.ES6 class继承</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>(name)<br>    <span class="hljs-built_in">this</span>.age = age<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;hsw&#x27;</span>,<span class="hljs-number">20</span>)<br><span class="hljs-built_in">console</span>.log(child.name,child.age) <span class="hljs-comment">// hsw 20</span><br><span class="hljs-built_in">console</span>.log(child.getName(),child.getAge()) <span class="hljs-comment">// hsw 20</span><br></code></pre></td></tr></table></figure><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>构造函数继承没有用到 prototype 这种方式比较常见，定义和使用也较为简单，下面是一个例子 🌰：</p><ul><li>👍 可以定义私有属性方法</li><li>👍 子类可以传递参数给父类</li><li>❌ 不能定义共享属性方法/或写在外面失去了封装性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Parent(name, friends) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>    <span class="hljs-keyword">this</span>.friends = friends <span class="hljs-comment">// 👍 可以定义私有 引用类型不会被共享</span><br>    <span class="hljs-keyword">this</span>.share = share <span class="hljs-comment">// ❌ 可以定义公有 但需要放在外部</span><br>    <span class="hljs-keyword">this</span>.log = log <span class="hljs-comment">// ❌ 避免重复声明，为了复用需要放在外面</span><br>&#125;<br><span class="hljs-comment">// ❌ 公有属性和方法定义在外面失去了封装性</span><br>let share = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>function log() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<br>&#125;<br>function Child(name, friends, gender) &#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name, friends) <span class="hljs-comment">// 👍 可以在子类传递参数给父类</span><br>    <span class="hljs-keyword">this</span>.gender = gender<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600752584600-9b38474b-15e1-4087-9607-7a310c511a9a.webp#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=117&originWidth=871&size=0&status=done&style=none&width=871"></p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链模式需要手动重新绑定 constructor 而且不能定义私有变量</p><ul><li>👍 可以定义公有属性方法</li><li>❌ 无论是定义还是继承都需要手动修改 constructor</li><li>❌ 封装性一般</li><li>❌ 不能定义私有属性方法</li><li>❌ 没办法向父类传递参数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> Parent() &#123;&#125;<br>Parent.prototype = &#123;<br>    constructor: Parent, <span class="hljs-regexp">//</span> ❌ 需要手动绑定 constructor<br>    name: <span class="hljs-string">&#x27;oli&#x27;</span>, <span class="hljs-regexp">//</span> ❌ 不能定义私有属性，全部都是公有<br>    friends: [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;troy&#x27;</span>], <span class="hljs-regexp">//</span> 👍 可以定义公有属性 所有实例都引用这个<br>    log: <span class="hljs-keyword">function</span>() &#123; <span class="hljs-regexp">//</span> 👍 方法被共享了<br>        return this.name<br>    &#125;<br>&#125;<br><span class="hljs-regexp">//</span> 也可以写成多个 Parent.prototype.func1 = <span class="hljs-keyword">function</span>()&#123;&#125; 封装性更差 但不用修改 constructor<br><span class="hljs-regexp">//</span> ❌ 封装性一般<br><span class="hljs-keyword">function</span> Child() &#123;&#125; <span class="hljs-regexp">//</span> ❌ 没办法向父类传递参数<br>Child.prototype = new Parent() <span class="hljs-regexp">//</span> 使用 new 操作符创建并重写 prototype<br>Child.prototype.constructor = Child <span class="hljs-regexp">//</span> ❌ 每次继承都需要手动修改 constructor 谁叫你是覆盖 prototype 属性呢<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600752584659-dfc89e1f-dea7-4413-bdc2-19af6bfcdb5f.webp#align=left&display=inline&height=157&margin=%5Bobject%20Object%5D&originHeight=157&originWidth=942&size=0&status=done&style=none&width=942"></p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>上面两者结合即成为组合继承模式，这个是结合了两者的优势，在 ES6 的 class 出现之前的常用方法，🦐🍜 看看例子：</p><ul><li>👍 公有的写在原型</li><li>👍 私有的写在构造函数</li><li>👍 可以向父类传递参数</li><li>❌ 需要手动绑定 constructor</li><li>❌ 封装性一般</li><li>⚡ 重复调用父类性能损耗</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>)</span> &#123;<br>    <span class="hljs-comment">// 😀 私有的写这里</span><br>    this.name = name <span class="hljs-comment">// 👍 可以定义私有属性</span><br>    this.friends = friends <span class="hljs-comment">// 👍 可以定义公有引用属性不会被共享</span><br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype = &#123;<br>    <span class="hljs-comment">// 😀 公有的写这里</span><br>    constructor: Parent, <span class="hljs-comment">// ❌ 需要手动绑定 constructor</span><br>    share: <span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>, <span class="hljs-comment">// 👍 这里定义的公有属性会被共享</span><br>    log: <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123; <span class="hljs-comment">// 👍 方法被共享了</span><br>        return this.name<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ❌ 封装性一般</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>, <span class="hljs-params">gender</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this, name, friends) <span class="hljs-comment">// 👍 可以向父类传递参数 ⚡ 这里又调用了一次 Parent</span><br>    this.gender = gender<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span> <span class="hljs-comment">// 使用 new 操作符创建并重写 prototype ⚡ 这里调用了一次 Parent</span><br><span class="hljs-comment">// 有方法避免多次调用直接去掉 new 操作符 转而写成 Child.prototype = Parent.prototype 这样并不好，虽然避免出现重复调用但导致修改子类 constructor 的时候父类也被修改了</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child <span class="hljs-comment">// ❌ 每次继承都需要手动修改 constructor 谁叫你是覆盖 prototype 属性呢</span><br><span class="hljs-comment">// 如果使用 Child.prototype = Parent.prototype 那么 constructor 子类父类是同一个</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600752584560-1d9269a5-f3a2-4fbf-a122-4e00d65732d4.svg#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&name=image.svg&originHeight=125&originWidth=637&size=106&status=done&style=none&width=637" alt="image.svg"></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承直接使用 ES5 <code>Object.create</code> 方法，该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例，本质是一个浅拷贝</p><ul><li>👍 父类方法可以复用</li><li>❌ 父类引用属性全部被共享</li><li>❌ 子类不可传递参数给父类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> parent = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>    <span class="hljs-attr">share</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-comment">// ❌ 父类的引用属性全部被子类所共享</span><br>    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 👍 父类方法可以复用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> child = <span class="hljs-built_in">Object</span>.create(parent) <span class="hljs-comment">// ❌ 子类不能向父类传递参数</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600752584564-ea337f19-e791-412a-968a-091c7ed73fc3.svg#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.svg&originHeight=96&originWidth=520&size=105&status=done&style=none&width=520" alt="image.svg"></p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>原型式继承的基础上为子类增加属性和方法</p><ul><li>👍 父类方法可以复用</li><li>👍 增加了别的属性和方法</li><li>❌ 父类引用属性全部被共享</li><li>❌ 子类不可传递参数给父类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> parent = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>    <span class="hljs-attr">share</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(obj) <span class="hljs-comment">// 本质上还是 Object.create</span><br>    clone.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 增加一些属性或方法</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone<br>&#125;<br><span class="hljs-keyword">let</span> child = create(parent)<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>杂糅了原型链式、构造函数式、组合式、原型式、寄生式而形成的一种方式：<br>组合继承的方法会调用两次 Parent，一次是在 <code>Child.prototype = new Parent()</code> ，一次是在 <code>Parent.call()</code>。这个是组合继承的唯一缺点，寄生组合式解决了这个问题：</p><ul><li>👍 公有的写在原型</li><li>👍 私有的写在构造函数</li><li>👍 可以向父类传递参数</li><li>👍 不会重复调用父类</li><li>❌ 需要手动绑定 constructor （如果重写 prototype）</li><li>❌ 需要调用额外的方法封装性一般</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>)</span> &#123;<br>    this.name = name<br>    this.friends = friends<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype = &#123;<br>    constructor: Parent, <span class="hljs-comment">// ❌ 需要手动绑定 constructor</span><br>    share: <span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>,<br>    log: <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>        return this.name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>, <span class="hljs-params">gender</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this, name, friends) <span class="hljs-comment">// ⚡ 这里只需要调用一次 Parent</span><br>    this.gender = gender<br>&#125;<br><span class="hljs-comment">// 上半部分和组合继承一样</span><br><span class="hljs-keyword">let</span> F = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;&#125; <span class="hljs-comment">// 创建一个中介函数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype <span class="hljs-comment">// 这个中介的原型指向 Parent 的原型</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span> <span class="hljs-comment">// 注意这里没有使用 new 操作符调用 Parent</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child<br>复制代码<br></code></pre></td></tr></table></figure><p>对上述方法进行一个封装：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>)</span> &#123;<br>    this.name = name <span class="hljs-comment">// 👍 可以定义私有属性</span><br>    this.friends = friends <span class="hljs-comment">// 👍 可以定义公有引用属性不会被共享</span><br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype = &#123;<br>    constructor: Parent, <span class="hljs-comment">// ❌ 需要手动绑定 constructor</span><br>    share: <span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>, <span class="hljs-comment">// 👍 这里定义的公有属性会被共享</span><br>    log: <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123; <span class="hljs-comment">// 👍 方法被共享了</span><br>        return this.name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">friends</span>, <span class="hljs-params">gender</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this, name, friends) <span class="hljs-comment">// 👍 可以向父类传递参数 ⚡ 这里又调用了一次 Parent</span><br>    this.gender = gender<br>&#125;<br><span class="hljs-keyword">function</span> proto(child, parent) &#123;<br>    <span class="hljs-keyword">let</span> clonePrototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(parent.prototype)<br>    child.prototype = clonePrototype<br>    child.prototype.constructor = child<br>&#125;<br>proto(Child, Parent)<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><p>class 的语法，就比较清晰了，能用 class 就用 class 吧：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    constructor(name, friends) &#123; <span class="hljs-comment">// 该属性在构造函数上，不共享</span><br>        <span class="hljs-keyword">this</span>.name = name<br>        <span class="hljs-keyword">this</span>.friends = friends<br>    &#125;<br>    log() &#123; <span class="hljs-comment">// 该方法在原型上，共享</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br>&#125;<br><span class="hljs-type">Parent</span>.prototype.share = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// 原型上的属性，共享</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    constructor(name, friends, gender) &#123;<br>        <span class="hljs-keyword">super</span>(name, friends)<br>        <span class="hljs-keyword">this</span>.gender = gender<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>另外可以使用 get set 方法将 share 属性写入到原型中去</p></blockquote><p>另外，class 是一种语法糖使用 babel 将其转化一下看看：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600752584875-c9c2a900-174c-471c-b072-a998523f254b.webp#align=left&display=inline&height=886&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=765&size=0&status=done&style=none&width=765"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后上个图作为总结：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600752584619-4db76a70-7538-466b-8454-048fdab05dac.webp#align=left&display=inline&height=475&margin=%5Bobject%20Object%5D&originHeight=475&originWidth=1280&size=0&status=done&style=none&width=1280"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现instanceof</title>
    <link href="/2020/09/22/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof/"/>
    <url>/2020/09/22/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceOf</span>(<span class="hljs-params">obj, fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Reflect</span>.getPrototypeOf(obj);<br>  <span class="hljs-keyword">while</span> (proto) &#123;<br>    <span class="hljs-keyword">if</span> (proto === fn.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-built_in">Reflect</span>.getPrototypeOf(proto);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> AA();<br><br><span class="hljs-built_in">console</span>.log(myInstanceOf(a, <span class="hljs-built_in">Object</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现bind</title>
    <link href="/2020/09/22/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0bind/"/>
    <url>/2020/09/22/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0bind/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">const</span> bound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> newArgs = [...args, ...args2];<br>    <span class="hljs-comment">// 如果是new方法调用，this指向bound实例化对象，则使用该方式执行一次构造方法</span><br>    <span class="hljs-comment">// 如果是普通调用，this指向window</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> bound) &#123;<br>      fn.apply(<span class="hljs-built_in">this</span>, newArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fn.apply(context, newArgs);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 处理new的情况，如果简单绑定原型，会导致修改实例的__proto__会修改Person的原型</span><br>  <span class="hljs-comment">// bound.prototype=fn.prototype</span><br>  <span class="hljs-comment">// 下面的代码，其实是一种原型链继承方式</span><br>  <span class="hljs-built_in">Object</span>.setPrototypeOf(bound.prototype, fn.prototype);<br>  <span class="hljs-keyword">return</span> bound;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  <span class="hljs-built_in">console</span>.log(...arguments);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br><span class="hljs-keyword">let</span> test = Person.myBind(&#123;&#125;, <span class="hljs-number">123</span>);<br><span class="hljs-keyword">let</span> test2 = <span class="hljs-keyword">new</span> test(<span class="hljs-number">789</span>);<br>test2.__proto__.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;被篡改&quot;</span>);<br>&#125;;<br>Person.prototype.getName();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS和CSRF</title>
    <link href="/2020/09/22/yuque/XSS%E5%92%8CCSRF/"/>
    <url>/2020/09/22/yuque/XSS%E5%92%8CCSRF/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903856443392014">https://juejin.im/post/6844903856443392014</a></p><h3 id="XSS-Cross-Site-Script-跨站脚本攻击"><a href="#XSS-Cross-Site-Script-跨站脚本攻击" class="headerlink" title="XSS (Cross Site Script) 跨站脚本攻击"></a>XSS (Cross Site Script) 跨站脚本攻击</h3><p>XSS<strong>跨站脚本攻击</strong>是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。<br>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。<br>XSS 攻击可以分为 3 类：反射型（非持久型）、存储型（持久型）、基于 DOM。<br><strong>XSS 主要是通过输入框等形式提交 js 脚本，最终在页面上被执行。</strong></p><h4 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h4><p>现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。<br><strong>HttpOnly 防止劫取 Cookie</strong><br>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的 Javascript 访问带有 HttpOnly 属性的 Cookie。<br>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。<br><strong>输入检查</strong><br><strong>不要相信用户的任何输入。</strong> 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。<br>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。<br>而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// vuejs 中的 decodingMap</span><br><span class="hljs-comment">// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉</span><br><span class="hljs-keyword">const</span> decodingMap = &#123;<br>  <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-string">&#x27;&lt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;&gt;&#x27;</span>: <span class="hljs-string">&#x27;&gt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;&quot;&#x27;</span>: <span class="hljs-string">&#x27;&quot;&#x27;</span>,<br>  <span class="hljs-string">&#x27;&amp;&#x27;</span>: <span class="hljs-string">&#x27;&amp;&#x27;</span>,<br>  <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#x27;</span>: <span class="hljs-string">&#x27;\n&#x27;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>输出检查</strong><br>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</p><h3 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF (Cross Site Request Forgery)"></a>CSRF (Cross Site Request Forgery)</h3><p>CSRF，即 Cross Site Request Forgery，中译是<strong>跨站请求伪造</strong>，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。<br>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。<br>在用户已经登录目标站的前提下，访问到了攻击者的钓鱼网站，攻击者直接通过 url 调用目标站的接口，伪造用户的行为进行攻击，通常这个行为用户是不知情的。</p><h4 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h4><p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。<br><strong>验证码</strong><br>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。<br>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。<br>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。<br><strong>Referer Check</strong><br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。<br>比如，如果用户要删除自己的帖子，那么先要登录 <a href="http://www.c.com,然后找到对应的页面,发起删除帖子的请求.此时,referer/">www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer</a> 的值是 <a href="http://www.c.com/">www.c.com</a>；当请求是从 <a href="http://www.a.com/">www.a.com</a> 发起时，Referer 的值是 <a href="http://www.a.com/">www.a.com</a> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <a href="http://www.c.com/">www.c.com</a> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。<br>针对上文的例子，可以在服务端增加如下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (req.headers.referer !== <span class="hljs-string">&#x27;http://www.c.com:8002/&#x27;</span>) &#123;<br>    res.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;csrf 攻击&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。<br><strong>添加 token 验证</strong><br>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读 SQL 注入技术专题的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p><ol><li>防御 XSS 攻击<ul><li>HttpOnly 防止劫取 Cookie</li><li>用户的输入检查</li><li>服务端的输出检查</li></ul></li><li>防御 CSRF 攻击<ul><li>验证码</li><li>Referer Check</li><li>Token 验证</li></ul></li></ol><ul><li><p>XSS 是利用用户对指定网站的信任；</p></li><li><p>CSRF 是利用网站对用户的信任。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现一个apply</title>
    <link href="/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAapply/"/>
    <url>/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAapply/</url>
    
    <content type="html"><![CDATA[<p>关键步骤，<strong>在 context 上调用方法，触发 this 绑定为 context</strong><br>和 call 基本类似，但是需要判断是否包含参数 args</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖</span><br>  context = context ? context : globalThis;<br>  <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;key&quot;</span>);<br>  context[key] = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">let</span> res = context[key](args);<br>  <span class="hljs-keyword">delete</span> context[key];<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  <span class="hljs-built_in">console</span>.log(args);<br>&#125;<br><br>name = <span class="hljs-string">&quot;234&quot;</span>;<br>person.call(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span> &#125;, [<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>]);<br>person.myCall(<span class="hljs-literal">null</span>, [<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现一个call</title>
    <link href="/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcall/"/>
    <url>/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcall/</url>
    
    <content type="html"><![CDATA[<p>关键是<strong>在 context 上调用方法，触发 this 绑定为 context</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖</span><br>  <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;key&quot;</span>);<br>  context[key] = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">const</span> res = context[key](args);<br>  <span class="hljs-keyword">delete</span> context[key];<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  <span class="hljs-built_in">console</span>.log(args);<br>&#125;<br><br>person.call(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span> &#125;, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>);<br>person.myCall(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span> &#125;, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月21日</title>
    <link href="/2020/09/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8821%E6%97%A5/"/>
    <url>/2020/09/21/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>二叉树的层次遍历、合并有序链表、链表中环的入口节点</p><span id="more"></span><h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600689937924-5254f84b-4838-4db8-9c3b-e4d3939af0a4.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&originHeight=292&originWidth=311&size=0&status=done&style=none&width=155"><br>该二叉树层序遍历的结果是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>[<span class="hljs-number">3</span>],<br>[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>示例 1</strong><br>输入</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong><br>输入</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,#,#,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个数组存储当前层的所有节点，遍历拿到值以后再加入结果数组中，同时把它们的左右节点加入队列数组中。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function TreeNode(x) &#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.left = null;</span><br><span class="hljs-comment"> *   this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>root TreeNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型二维数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  queue.unshift(root);<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">let</span> tmp = queue.splice(<span class="hljs-number">0</span>, queue.length);<br>    <span class="hljs-keyword">let</span> tmp2 = [];<br>    <span class="hljs-keyword">while</span> (tmp.length) &#123;<br>      <span class="hljs-keyword">let</span> node = tmp.shift();<br>      tmp2.push(node.val);<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>    res.push(tmp2);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">levelOrder</span>: levelOrder,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h1><p>将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。</p><p><strong>示例 1</strong><br>输入</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong><br>输入</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;1&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>两个指针指向链表头，不断比较值，加入结果列表，并下移指针。其中一条遍历完之后，将剩下一条都放入结果链表即可。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>l1 ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>l2 ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> tmp = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> res = tmp;<br>  <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>    <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>      tmp.next = <span class="hljs-keyword">new</span> ListNode(l1.val);<br>      l1 = l1.next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      tmp.next = <span class="hljs-keyword">new</span> ListNode(l2.val);<br>      l2 = l2.next;<br>    &#125;<br>    tmp = tmp.next;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (l1) &#123;<br>    tmp.next = <span class="hljs-keyword">new</span> ListNode(l1.val);<br>    l1 = l1.next;<br>    tmp = tmp.next;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (l2) &#123;<br>    tmp.next = <span class="hljs-keyword">new</span> ListNode(l2.val);<br>    l2 = l2.next;<br>    tmp = tmp.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">mergeTwoLists</span>: mergeTwoLists,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h1><p>对于一个给定的链表，返回环的入口节点，如果没有环，返回 null<br>拓展：<br>你能给出不利用额外空间的解法么？</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="添加-isVisit"><a href="#添加-isVisit" class="headerlink" title="添加 isVisit"></a>添加 isVisit</h4><p>可以取巧给每个节点加上一个属性判断是否遍历过，判断后就可以再环入口节点时返回节点。</p><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快慢指针相遇只能判断是否有环。</p><p>串长 a + n，其中 n 为循环，当 a + b 步的慢指针与走了 2*(a+b)步的快指针相遇时，快指针已经走过了 k 圈，k&gt;=1。<br>即**a + b + k * n = 2 _ (a+b)**，求 a，得到 a = k _ n - b。<br>也就是头结点从 X 走 a 步，等于 Z 位置上的指针再走 k 圈减去 b 的长度，相遇于 Y 点，即环的入口。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1600692494342-12f30e91-cca7-4398-a507-c45f9dc5fd36.jpeg#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=378&size=0&status=done&style=none&width=378"></p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="添加-isVisit-1"><a href="#添加-isVisit-1" class="headerlink" title="添加 isVisit"></a>添加 isVisit</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    <span class="hljs-keyword">if</span> (head.isVisit) <span class="hljs-keyword">return</span> head;<br>    head.isVisit = <span class="hljs-literal">true</span>;<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">detectCycle</span>: detectCycle,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> fast = head;<br>  <span class="hljs-keyword">let</span> slow = head;<br>  <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) &#123;<br>    fast = fast.next.next;<br>    slow = slow.next;<br>    <span class="hljs-keyword">if</span> (fast === slow) &#123;<br>      <span class="hljs-keyword">let</span> tmp = head;<br>      <span class="hljs-keyword">while</span> (tmp !== fast) &#123;<br>        tmp = tmp.next;<br>        fast = fast.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">detectCycle</span>: detectCycle,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组扁平化</title>
    <link href="/2020/09/21/yuque/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <url>/2020/09/21/yuque/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-comment">// 1.flat方法</span><br>  <span class="hljs-comment">// return arr.flat(Infinity)</span><br>  <span class="hljs-comment">// 2.toString()再split()</span><br>  <span class="hljs-comment">// return arr.toString().split(&#x27;,&#x27;)</span><br>  <span class="hljs-comment">// 3.reduce</span><br>  <span class="hljs-comment">// return arr.reduce((a,b)=&gt;a.concat(Array.isArray(b)?flat(b):b),[])</span><br>  <span class="hljs-comment">// 4.递归</span><br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) &#123;<br>      res.push(...flat(item));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(item);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, [<span class="hljs-number">10</span>]]]]];<br><br><span class="hljs-built_in">console</span>.log(flat(arr));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化</title>
    <link href="/2020/09/21/yuque/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2020/09/21/yuque/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curryFn(...args, ...args2);<br>      &#125;;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><span class="hljs-keyword">const</span> curriedSum = curry(sum);<br><span class="hljs-built_in">console</span>.log(curriedSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><span class="hljs-built_in">console</span>.log(curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><span class="hljs-built_in">console</span>.log(curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现深克隆</title>
    <link href="/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86/"/>
    <url>/2020/09/21/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-keyword">if</span> (map.has(obj)) <span class="hljs-keyword">return</span> map.get(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      obj.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    &#125;;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;<br>  map.set(obj, res);<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj[key] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;<br>      res[key] = deepClone(obj[key]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res[key] = obj[key];<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原生手动实现懒加载</title>
    <link href="/2020/09/21/yuque/%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/09/21/yuque/%E5%8E%9F%E7%94%9F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>重点是如何判断是否在视窗内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> viewPortHeight = <span class="hljs-built_in">window</span>.innerHeight;<br><span class="hljs-keyword">const</span> offsetTop = el.offsetTop;<br><span class="hljs-keyword">const</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br><span class="hljs-keyword">const</span> top = offsetTop - scrollTop;<br><span class="hljs-keyword">return</span> top &lt;= viewPortHeight + <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100vw;height: 3000px;display: flex;flex-direction: column;&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600664088205&amp;di=d9ba384447ddd9e91146950c1fe4f7f4&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170823%2Fa248070c2ec342a7af7c94a4ed1ee3d6.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> isInViewport = <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> viewPortHeight = <span class="hljs-built_in">window</span>.innerHeight;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> offsetTop = el.offsetTop;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> top = offsetTop - scrollTop;</span><br><span class="javascript">        <span class="hljs-comment">// console.log(viewPortHeight,offsetTop,scrollTop)</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span> top &lt;= viewPortHeight + <span class="hljs-number">100</span>;</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (!timer) &#123;</span><br><span class="javascript">            fn.apply(context, args);</span><br><span class="javascript">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              timer = <span class="hljs-literal">null</span>;</span><br><span class="javascript">            &#125;, delay);</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;;</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">const</span> handleScroll = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.documentElement.scrollTop === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> imagesDom = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>);</span><br><span class="javascript">        <span class="hljs-comment">// console.log(imagesDom)</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dom <span class="hljs-keyword">of</span> imagesDom) &#123;</span><br><span class="javascript">          <span class="hljs-keyword">if</span> (isInViewport(dom)) &#123;</span><br><span class="javascript">            dom.setAttribute(<span class="hljs-string">&quot;src&quot;</span>, dom.getAttribute(<span class="hljs-string">&quot;data-url&quot;</span>));</span><br><span class="javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">            dom.setAttribute(</span><br><span class="javascript">              <span class="hljs-string">&quot;src&quot;</span>,</span><br><span class="javascript">              <span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp&quot;</span></span><br><span class="javascript">            );</span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onscroll = throttle(handleScroll, <span class="hljs-number">500</span>);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不断旋转的三角形</title>
    <link href="/2020/09/21/yuque/%E4%B8%8D%E6%96%AD%E6%97%8B%E8%BD%AC%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2020/09/21/yuque/%E4%B8%8D%E6%96%AD%E6%97%8B%E8%BD%AC%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tri&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">      <span class="hljs-selector-class">.tri</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="css">        <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;</span><br><span class="css">        <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;</span><br><span class="css">        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">87px</span> solid blue;</span><br><span class="css">        <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">67%</span>; <span class="hljs-comment">/* 设置旋转点 */</span></span><br><span class="css">        <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">3s</span> linear infinite;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-keyword">@keyframes</span> rotate &#123;</span><br><span class="css">        <span class="hljs-selector-tag">from</span> &#123;</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-tag">to</span> &#123;</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);</span><br><span class="css">        &#125;</span><br><span class="css">      &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>head、footer、三栏中间自适应，两边固定长度布局实现</title>
    <link href="/2020/09/21/yuque/head%E3%80%81footer%E3%80%81%E4%B8%89%E6%A0%8F%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E4%B8%A4%E8%BE%B9%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/09/21/yuque/head%E3%80%81footer%E3%80%81%E4%B8%89%E6%A0%8F%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E4%B8%A4%E8%BE%B9%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;flex-direction:column;width: 100vw;height: 100vh;&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;box-sizing: border-box;width: 100%;height: 100px;background-color: #F00;padding:10px&quot;</span></span><br><span class="hljs-tag">      &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;flex-direction:flex;width: 100%;height: calc(100% - 200px);&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">          <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;background-color: #0F0;box-sizing: border-box;margin: 10px;&quot;</span></span><br><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">          <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: calc(100% - 200px);background-color: #00F;box-sizing: border-box;margin: 10px;&quot;</span></span><br><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">          <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px;background-color: #F00;box-sizing: border-box;margin: 10px;&quot;</span></span><br><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;box-sizing: border-box;width: 100%;height: 100px;background-color: #F00;padding:10px&quot;</span></span><br><span class="hljs-tag">      &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见面试智力题</title>
    <link href="/2020/09/20/yuque/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <url>/2020/09/20/yuque/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="赛马次数"><a href="#赛马次数" class="headerlink" title="赛马次数"></a>赛马次数</h1><blockquote></blockquote><h3 id="有-25-匹马和-5-条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前-3-名。"><a href="#有-25-匹马和-5-条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前-3-名。" class="headerlink" title="有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。"></a>有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。</h3><p>先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 <strong>5+1+1=7</strong> 场赛马。<br>A 组：1，<strong>2，3</strong>，4，5<br>B 组：<strong>1，2</strong>，3，4，5<br>C 组：<strong>1</strong>，2，3，4，5<br>D 组：1，2，3，4，5<br>E 组：1，2，3，4，5</p><h1 id="用绳子计时-15-分钟"><a href="#用绳子计时-15-分钟" class="headerlink" title="用绳子计时 15 分钟"></a>用绳子计时 15 分钟</h1><blockquote></blockquote><h3 id="给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量-15-分钟。"><a href="#给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量-15-分钟。" class="headerlink" title="给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。"></a>给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。</h3><ul><li>点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头；</li><li>当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟；</li><li>点燃 R2 的另一头，15 分钟后，R2 将全部烧完。</li></ul><h1 id="砝码秤盐"><a href="#砝码秤盐" class="headerlink" title="砝码秤盐"></a>砝码秤盐</h1><blockquote></blockquote><h3 id="140g-盐-一天平-7g-、2g-砝码各一个-如何只利用这些东西-3-次把盐分成-50g-和-90g"><a href="#140g-盐-一天平-7g-、2g-砝码各一个-如何只利用这些东西-3-次把盐分成-50g-和-90g" class="headerlink" title="140g 盐,一天平,7g 、2g 砝码各一个,如何只利用这些东西 3 次把盐分成 50g 和 90g?"></a>140g 盐,一天平,7g 、2g 砝码各一个,如何只利用这些东西 3 次把盐分成 50g 和 90g?</h3><ul><li><p>第一次： 7g、2g 砝码称出 9g 盐，结果盐分成 9g 与 131g</p></li><li><p>第二次：将 9g 盐与 7g、2g 都作为砝码，结果将盐分为 18g 与 113g （注意：这时盐已经分为三份：9g、18g、113g，还有两个砝码）</p></li><li><p>第三次：将 18g 盐与 7g 砝码发在左托盘，将 2g 砝码放在右托盘，然后在 113g 盐中取盐添置右托盘中，可获取 23g 盐。</p></li></ul><p>这时盐分为 9g，18g，23g 与 90g。</p><p>即三次，可以得到 90g 与（9+18+23）50g。 <a href=""> </a></p><h1 id="九球称重"><a href="#九球称重" class="headerlink" title="九球称重"></a>九球称重</h1><blockquote></blockquote><h3 id="有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。"><a href="#有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。" class="headerlink" title="有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。"></a>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。</h3><p>将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。<br>对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。</p><h1 id="药丸称重"><a href="#药丸称重" class="headerlink" title="药丸称重"></a>药丸称重</h1><blockquote></blockquote><h3 id="有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。"><a href="#有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。" class="headerlink" title="有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。"></a>有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。</h3><p>可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。</p><h1 id="得到-4-升的水"><a href="#得到-4-升的水" class="headerlink" title="得到 4 升的水"></a>得到 4 升的水</h1><blockquote></blockquote><h3 id="有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。"><a href="#有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。" class="headerlink" title="有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。"></a>有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。</h3><p>可以理解为用若干个 5 和 3 做减法得到 4。</p><ul><li>不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水；</li><li>1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水；</li><li>5 - 3 = 2。</li></ul><h1 id="扔鸡蛋"><a href="#扔鸡蛋" class="headerlink" title="扔鸡蛋"></a>扔鸡蛋</h1><blockquote></blockquote><h3 id="一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少。"><a href="#一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少。" class="headerlink" title="一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。"></a>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。</h3><p>可以将楼层划分成多个区间，第一个鸡蛋 E1 用来确定 N 属于哪个区间，第二个鸡蛋 E2 按顺序遍历该区间找到 N。那么问题就转换为怎么划分区间满足最坏情况下扔鸡蛋次数最少。<br>E1 需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，即 E2 的遍历次数固定。那么最坏的情况是 N 在最后一个区间，此时 E1 遍历的次数最多。为了使最坏情况下 E1 和 E2 总共遍历的次数比较少，那么后面的区间大小要比前面的区间更小。具体来说，E1 每多遍历一次，E2 要少遍历一次，才使得 N 无论在哪个区间，总共遍历的次数一样。设第一个区间大小为 <strong>X</strong>，那么第二个区间的大小为** X-1<strong>，以此类推。那么</strong> X + (X-1) + (X-2) + … + 1 = 100，得到 X (X + 1) / 2 = 100 ，即 X = 14。**<br>转自：<a href="https://blog.csdn.net/abe_abd/article/details/77710356">https://blog.csdn.net/abe_abd/article/details/77710356</a><br>试着从 10 楼开始扔鸡蛋，然后是 20 层，30 层……100 层<br>如果鸡蛋 1 在第十层（随便举例子的一个数值也可以是别的数，看到后面就会知道这个值应该取 14，但是刚开始分析谁也不知道该取 14 不是么）扔下，鸡蛋摔碎。那么第二个鸡蛋只需要从 1-9 层依次扔下去试就能试出来是 1-10 中的第几层，所以最差在恰好在第十层才能摔碎，结果是 1+9=10 次<br>如果鸡蛋 1 在第 100 层是才摔碎，实验楼层依次是：10 层、20 层、30 层、、、100 层，试验了 10 次。在第 90 层时鸡蛋没有摔碎，但是在 100 层摔碎了。这说明 N 在[90,100]区间内，所以鸡蛋 2 只需要从 91 层楼开始试验，最差一直试验到 99 层必然会测试出 N 的值。最差次数：鸡蛋 1 的次数 10 次 + 鸡蛋 2 的次数 9 次 = 19 次。<br>设计一种扔鸡蛋的方法，使得扔鸡蛋 1 的次数无论是第一次还是最后一次扔下的次数越稳定越好。<br>负载均衡方法：扔鸡蛋 1 的次数 和扔鸡蛋 2 的次数的和 不论什么时候都是一样的，鸡蛋 1 多扔一次鸡蛋 2 就少扔一次，假如开始扔鸡蛋 1 的初始楼层是 x 层，那么扔鸡蛋 2 初始楼层是由扔鸡蛋 1 是否摔碎决定的。即，鸡蛋 1 摔碎的那一楼层 和 扔鸡蛋 1 的摔碎之前扔的那一次楼层数之间的差值减 1（假设鸡蛋 1 从 20 层开始扔下，没碎；从 30 层扔下，碎了，那么鸡蛋 2 就得从 21 层开始扔，最差一直扔到 29 层就能判断出 N 的值了），如果在 x 层扔下没碎，那么下一次扔的楼层就是 x+x-1 层（第一次是 20 层，下一次就是 20+20-1=39 层）鸡蛋 2 的次数相应的就减去 1 次；第二次没碎，下次从 x+ x-1 + x-2 层扔下（承接上面括号的例子：20+19+18 = 57 层），依次类推…..<br>也就是 ： x +  (x-1)+ (x-2)+。。。+1=100 求一下 x 值   x =  14.先从 14 层往下扔，没碎的前提下再从 14+13=27 层往下扔。最差的情况下就是第一次在 14 层恰好摔碎了，鸡蛋 2 只需要从 1-13 层个扔一次就能判断出 N 的值了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>介绍一下SVG</title>
    <link href="/2020/09/20/yuque/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSVG/"/>
    <url>/2020/09/20/yuque/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSVG/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844904017273815048">https://juejin.im/post/6844904017273815048</a></p><h2 id="SVG-简介"><a href="#SVG-简介" class="headerlink" title="SVG 简介"></a>SVG 简介</h2><p>SVG，即可缩放矢量图形(Scalable Vector Graphics)，是一种 XML 应用，可以以一种简洁、可移植的形式表示图形信息。目前，人们对 SVG 越来越感兴趣。大多数现代浏览器都能显示 SVG 图形，并且大多数矢量绘图软件都能导出 SVG 图形。SVG 主要可以概括为以下几点：</p><ul><li>SVG 指可伸缩矢量图形</li><li>SVG 用来定义网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li></ul><h4 id="SVG-的应用"><a href="#SVG-的应用" class="headerlink" title="SVG 的应用"></a>SVG 的应用</h4><ol><li>图表视图(echart)、地图视图(WEB-GIS)</li><li>形象(AI)的全网应用</li><li>UI 产品的设计</li><li>SVG 动画</li></ol><h4 id="SVG-浏览器的兼容情况"><a href="#SVG-浏览器的兼容情况" class="headerlink" title="SVG 浏览器的兼容情况"></a>SVG 浏览器的兼容情况</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617662-ddefade2-6577-40fc-a4e0-35cd82eec3fa.webp#align=left&display=inline&height=217&margin=%5Bobject%20Object%5D&originHeight=217&originWidth=800&size=0&status=done&style=none&width=800"></p><h4 id="SVG-与-Canvas-区别"><a href="#SVG-与-Canvas-区别" class="headerlink" title="SVG 与 Canvas 区别"></a>SVG 与 Canvas 区别</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617539-913413ff-7bac-49ee-acb4-8393adef88e4.webp#align=left&display=inline&height=464&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=800&size=0&status=done&style=none&width=800"></p><h2 id="图形系统"><a href="#图形系统" class="headerlink" title="图形系统"></a>图形系统</h2><p>计算机中描述图形信息的两大系统是栅格图形和矢量图形。</p><h4 id="栅格图形"><a href="#栅格图形" class="headerlink" title="栅格图形"></a>栅格图形</h4><p>在栅格图形系统中，图像被表示为图片元素或者像素的长方形数组如下图片所示。每个像素用其 RGB 颜色值或者颜色表内的索引表示。这一系列也称为 <strong>位图</strong>，通过以某种压缩格式存储。由于大多数现代显示设备也是栅格设备，显示图像时仅需要一个阅读器将位图解压并将它传输到屏幕上。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617509-427809aa-c086-488b-8cfb-19fe9a222d54.webp#align=left&display=inline&height=343&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=303&size=0&status=done&style=none&width=303"></p><h4 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h4><p>矢量图是基于数学的描述，如下图的多啦 A 梦，他的头是一条怎么样的贝塞尔曲线，它的参数是什么及用什么颜色来填充贝塞尔曲线，通过这种方式描述图片就是<strong>矢量图形</strong>。<br>想象一下在一张绘图纸上作图的过程，栅格图形的工作就像是描述哪个方格应该填充什么颜色，而矢量图形的工作则像是描述要绘制从某个点到另一个点的直线或曲线。</p><h2 id="创建-SVG-图像"><a href="#创建-SVG-图像" class="headerlink" title="创建 SVG 图像"></a>创建 SVG 图像</h2><h4 id="SVG-文档基本结构"><a href="#SVG-文档基本结构" class="headerlink" title="SVG 文档基本结构"></a>SVG 文档基本结构</h4><p>如下所示，是一个 SVG 文档结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>根元素 <code>&lt;svg&gt;</code> 以像素为单位定义了整个图像的 <code>width</code> 和 <code>height</code>，还通过 <code>xmlns</code> 属性定义了 <strong>SVG</strong> 的命名空间。<code>&lt;title&gt;</code> 元素的内容可以被阅读器显示在标题栏上或者是作为鼠标指针指向图像时的提示， <code>&lt;desc&gt;</code> 元素允许咱们为图像定义完整的描述信息。</p><h4 id="基本形状和属性"><a href="#基本形状和属性" class="headerlink" title="基本形状和属性"></a>基本形状和属性</h4><p><strong>基本图形</strong><br><code>&lt;rect&gt;</code>、<code>&lt;circle&gt;</code>、<code>&lt;ellipse&gt;</code>、<code>&lt;line&gt;</code>、<code>&lt;polyline&gt;</code>、<code>&lt;polygon&gt;</code><br><strong>基本属性</strong><br><code>fill</code>、<code>stroke</code>、<code>stroke-width</code>、<code>transform</code></p><h4 id="基本形状-—-圆形"><a href="#基本形状-—-圆形" class="headerlink" title="基本形状 — 圆形"></a>基本形状 — 圆形</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617506-54c5c50e-e866-4b0b-b7cb-29312d516634.webp#align=left&display=inline&height=392&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=800&size=0&status=done&style=none&width=800"><br>咱们可以通过 <code>&lt;circle&gt;</code> 元素来绘制猫的脸部。元素属性的中心点 <code>x</code> 坐标和 <code>y</code> 坐标以为半径。<code>点(0,0)</code> 为图像左上角。水平向右移动时 <code>x</code> 坐标增大，垂直向下移动时 <code>y</code> 坐标增大。为了避免一些误会，API 语义就很明确了，点 <code>(cx, cy)</code> 就表示圆心的位置，<code>r</code> 表示圆的半径。<br>绘图的颜色是表现的一部分，表现信息包含在 <code>style</code> 属性中，这里的轮廓颜色为黑色，填充颜色为 <code>none</code> 以使猫的脸部透明。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617505-a02962f5-0399-4139-977c-c735cb198132.webp#align=left&display=inline&height=197&margin=%5Bobject%20Object%5D&originHeight=197&originWidth=346&size=0&status=done&style=none&width=346"></p><h4 id="指定样式的属性"><a href="#指定样式的属性" class="headerlink" title="指定样式的属性"></a>指定样式的属性</h4><p>接着在添加两个圆表示两个眼睛。上面的 <code>stroke</code> 与 <code>fill</code> 是写在 <code>style</code> 里面的，但是 <strong>SVG</strong> 也允许咱们使用单独的属性，而不用全部写在 <code>style</code> 内，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617533-e352f96c-e9f4-438f-b83a-dae0f3f68f65.webp#align=left&display=inline&height=168&margin=%5Bobject%20Object%5D&originHeight=168&originWidth=345&size=0&status=done&style=none&width=345"></p><h4 id="图形对象分组"><a href="#图形对象分组" class="headerlink" title="图形对象分组"></a>图形对象分组</h4><p>接着使用两个 <code>&lt;line&gt;</code> 元素在猫的右脸上添加胡须，先看下线的示意图：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617512-bfa1ceb7-8d76-493f-9a83-b92250f16470.webp#align=left&display=inline&height=400&margin=%5Bobject%20Object%5D&originHeight=400&originWidth=800&size=0&status=done&style=none&width=800"><br>这很好理解，就不多说了。 这里我们需要把胡须作为一个部件，并包装在分组元素 <code>&lt;g&gt;</code> (后面会讲)里面，然后给下 <code>id</code> ，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;whiskers&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;105&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617536-2fb1b9c1-c0c8-4725-9416-3ea13156dfef.webp#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=358&size=0&status=done&style=none&width=358"></p><h4 id="图形对象分组-1"><a href="#图形对象分组-1" class="headerlink" title="图形对象分组"></a>图形对象分组</h4><p>接着使用 <code>&lt;use&gt;</code> 复用胡须分组并将它变换(transfrom) 为左侧胡须，如下图所示，首先在 <code>scale</code> 变换中对 <code>x</code> 坐标乘以 <code>-1</code>，翻转坐标系统。这意味原始坐标系统中的点<code>(75, 95)</code> 现在位于 <code>(-75, 95)</code>。接着通过 <code>translate</code> 向左平移调整对应的位置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;whiskers&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;105&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#whiskers&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&#x27;scale(-1 1) translate(-140 0)&#x27;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617500-9454af34-7eee-4323-aa71-3a4318e45be5.webp#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&originHeight=152&originWidth=282&size=0&status=done&style=none&width=282"></p><h4 id="其他基本图形"><a href="#其他基本图形" class="headerlink" title="其他基本图形"></a>其他基本图形</h4><p>如下图所示，咱们使用 <code>&lt;polyline&gt;</code> 元素构建嘴和耳朵，它接受一对 <code>x</code> 和 <code>y</code> 坐标为 <code>points</code> 属性的值。你可以使用空格或者逗号分隔这些数值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;whiskers&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;105&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#whiskers&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&#x27;scale(-1 1) translate(-140 0)&#x27;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 耳朵 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;108 62,90 10, 70 45, 50, 10, 32, 62&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 嘴 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;35 110,45 120, 95 120, 105, 110&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617534-dcf4a066-f800-4510-bff4-25a10e4f92c3.webp#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=335&size=0&status=done&style=none&width=335"></p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>所有的基本形状都是通用的 <code>&lt;path&gt;</code> 元素的快捷写法。接着使用 <code>&lt;path&gt;</code> 元素为猫添加鼻子。如下所示的代码，翻译过来就是 “移动到坐标<code>(75, 90)</code>。绘制一条到坐标<code>(65,90)</code> 的直线。然后以 <code>x</code> 半径为 <code>5</code>、<code>y</code> 半径为 <code>10</code> 绘制一个椭圆，最后回到坐标 <code>(75, 90)</code> 处”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;whiskers&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;105&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#whiskers&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&#x27;scale(-1 1) translate(-140 0)&#x27;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 耳朵 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;108 62,90 10, 70 45, 50, 10, 32, 62&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 嘴 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;35 110,45 120, 95 120, 105, 110&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 鼻子 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&#x27;M 75 90 L 65 90 A 5 10 0 0 0 75 90&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:#ffcccc&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617484-533a98d8-65ae-497c-b924-e23bafbb4696.webp#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=177&originWidth=274&size=0&status=done&style=none&width=274"></p><h4 id="路径-1"><a href="#路径-1" class="headerlink" title="路径"></a>路径</h4><p>由于这只是一个简单的图形，用户可能看不出这是一只猫，所以咱们可以使用 元素添加一些文本注释。在 元素中，x 和 y 属性用于指定文本的位置，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;170&#x27;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/1999/xlink&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;55&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&#x27;#3339933&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;whiskers&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;75&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;135&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;105&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">line</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#whiskers&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&#x27;scale(-1 1) translate(-140 0)&#x27;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 耳朵 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;108 62,90 10, 70 45, 50, 10, 32, 62&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 嘴 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;35 110,45 120, 95 120, 105, 110&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 鼻子 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&#x27;M 75 90 L 65 90 A 5 10 0 0 0 75 90&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:#ffcccc&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;165&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;font-family:sans-serif;font-size: 14pt;</span></span><br><span class="hljs-string"><span class="hljs-tag">    stroke:none; fill: black;</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#x27;</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617483-45578d3f-d144-45d5-ba83-21eaa7b234d1.webp#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&originHeight=184&originWidth=257&size=0&status=done&style=none&width=257"><br>如果看不懂代码，没关系，后面几章节会深入这些基本及属性。</p><h2 id="在网页中使用-SVG"><a href="#在网页中使用-SVG" class="headerlink" title="在网页中使用 SVG"></a>在网页中使用 SVG</h2><p>SVG 是一种图件格式，因此可以使用与其他图像类型相同的方式包含在 HTML 页面中。具体可以采用两种方法：将图像包含在 <code>&lt;img&gt;</code> 元素内（当图像是页面的基本组成部分时，推荐这种方式）；或者将图像作为另一个元素的 CSS 样式属性插入(当图像主要用来装饰时，推荐这种方式)。</p><h4 id="在-元素内包含-SVG"><a href="#在-元素内包含-SVG" class="headerlink" title="在 元素内包含 SVG"></a>在 元素内包含 SVG</h4><p>在 <code>&lt;img&gt;</code> 元素内包含 SVG 图像非常简单，只需设置 <code>src</code> 指向 SVG 文件位置即可。如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&#x27;cat.svg&#x27;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&#x27;&#x27;</span>/&gt;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="在-CSS-中包含-SVG"><a href="#在-CSS-中包含-SVG" class="headerlink" title="在 CSS 中包含 SVG"></a>在 CSS 中包含 SVG</h4><p>可以使用 background-image 属性来显示 SVG，如果没有固有尺寸， SVG 会被缩放为元素高度和宽度的 100%，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.background-cat</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;cat.svg&#x27;</span>);<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100%</span> <span class="hljs-number">100%</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="使用-object-标签引入-SVG-（不推荐）"><a href="#使用-object-标签引入-SVG-（不推荐）" class="headerlink" title="使用 object 标签引入 SVG （不推荐）"></a>使用 object 标签引入 SVG （不推荐）</h4><p><code>&lt;object&gt;</code> 元素的 <code>type</code> 属性表示要嵌入的文件类型。这个属性应该是一个有效的网络媒体类型(通常被称为 MIME 类型)。对于 <code>SVG</code>，使用 <code>type=&#39;image/svg+xml&#39;</code>。如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;object <span class="hljs-attribute">data</span>=<span class="hljs-string">&#x27;cat.svg&#x27;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&#x27;image/svg+xml&#x27;</span><br>  <span class="hljs-attribute">width</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&#x27;100&#x27;</span>/&gt;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="在网页中直接使用-SVG-标签"><a href="#在网页中直接使用-SVG-标签" class="headerlink" title="在网页中直接使用 SVG 标签"></a>在网页中直接使用 SVG 标签</h4><p>直接引用 svg 定即可，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">heiight</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>Stick Figure of Cat<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在这里绘制图像 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;95&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><h2 id="SVG-的视窗，视野和全局（世界）"><a href="#SVG-的视窗，视野和全局（世界）" class="headerlink" title="SVG 的视窗，视野和全局（世界）"></a>SVG 的视窗，视野和全局（世界）</h2><p><strong>视窗</strong><br>SVG 的属性<code>width</code>、<code>height</code>来控制视窗的大小，也称为<code>SVG</code>容器<br><strong>世界</strong><br>SVG 里面的代码，就是对 SVG 世界的定义<br><strong>视野</strong><br>世界是无穷大的，视野是观察世界的一个矩形区域。如下图所示<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617583-d2844e8e-292c-4ecd-8dc4-6da2ca546602.webp#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=594&size=0&status=done&style=none&width=594"><br>世界不可变，而视野是可以改变的。在 SVG 中，提供了<code>viewBox</code>和<code>preserveAspectRatio</code>属性来控制视野。</p><h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h2><p>SVG 可以使用 元素画出一条直线，使用只需要指定线段的起(x1, y1)止(x2, y2)点。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617493-5049c2af-1c54-4d68-8794-bc10472f6d54.webp#align=left&display=inline&height=385&margin=%5Bobject%20Object%5D&originHeight=385&originWidth=780&size=0&status=done&style=none&width=780"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617568-9c127e26-8bb8-481d-8ae4-38e2742939dc.webp#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&originHeight=178&originWidth=327&size=0&status=done&style=none&width=327"></p><h2 id="笔画的特性"><a href="#笔画的特性" class="headerlink" title="笔画的特性"></a>笔画的特性</h2><p>线段可以看作画面上画出来的笔画。笔画的尺寸、颜色和风格都会影响线段的表现。这些特性都可以在 <code>style</code> 属性指定。</p><h4 id="stroke-width"><a href="#stroke-width" class="headerlink" title="stroke-width"></a>stroke-width</h4><p><code>stroke-width</code> 是设置线段的粗细，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:10;stroke:black&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617546-c73e66d8-0408-4722-a7ea-b4491a7cd96e.webp#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&originHeight=185&originWidth=361&size=0&status=done&style=none&width=361"></p><h4 id="笔画的颜色和透明度"><a href="#笔画的颜色和透明度" class="headerlink" title="笔画的颜色和透明度"></a>笔画的颜色和透明度</h4><p>可以通过以下几种方式指定笔画颜色：</p><ul><li>基本颜色关键字： aqua、black、blue、fuchsia、gray、green 等</li><li>由 6 位十六进制指定的颜色，形式为 <code>#rrggbb</code>，其中 <code>rr</code> 表示红色, <code>gg</code> 表示绿色, <code>bb</code> 表示蓝色，它们的范围都是 <code>00--ff</code></li><li>由 3 位十六进制指定的颜色，形式为 <code>#rgb</code>，其中 <code>r</code> 表示红色，<code>g</code> 表示绿色, <code>b</code> 表示蓝色，它们的范围都是 <code>0-f</code> 。</li><li>通过 <code>rgb()</code> 形式指定的 <code>rgb</code> 颜色值，每个值的取值范围都是整数 <code>0-255</code> 或者百分比 <code>0 - 100%</code></li><li>currentColor 关键字，表示当前元素应用的 CSS 属性 color 的值。color 是用来给 HTML 的文本设置颜色的，会被子元素继承，但对 SVG 没有直接效果。</li></ul><p>线段都是实线，咱们也可以使用 <code>stroke-opacity</code> 来控制线的透明度，取值范围和 CSS 一样 <code>0.0-1.0</code>,来几个例子演示一下：<br>来几个例子演示一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;140&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;170&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 红色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:5;stroke:red&#x27;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 谈绿色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:5;stroke:#9f9f;stroke-opacity: 0.2&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 橘色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;40&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;40&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:5;stroke:rgb(255,128,64);stroke-opacity: 0.5&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 深紫色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:5;stroke:rgb(60%,20%,60%);stroke-opacity: 0.8&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617532-778972fd-9d80-4a2d-9541-4c55cbe2601f.webp#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=265&size=0&status=done&style=none&width=265"></p><blockquote><p>如果不指定笔画颜色的话，将看不到任何线，因为 stroke 属性的默认值是 none</p></blockquote><h4 id="stroke-dasharray-属性"><a href="#stroke-dasharray-属性" class="headerlink" title="stroke-dasharray 属性"></a>stroke-dasharray 属性</h4><p>有时咱们需要点线和虚线，刚需要使用 stroke-dasharray 属性，它的值由一列数字构成，代表线的长度和空隙的长度，数字之间用逗号或空格隔开。数字的个数应该为偶数，但如果是奇数，则 SVG 会重复几次，让总数为偶数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 9个像素的虚线，5个像素的空隙 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;10&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-dasharray:9, 5; stroke: black; stroke-width:2&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 5个像素的虚线，3个像素的空隙 ,9个像素的虚线，2个像素的空隙 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;30&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-dasharray:9, 5, 9, 2; stroke: black; stroke-width:2&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 复制奇数个数 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;50&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-dasharray:9, 3, 5; stroke: black; stroke-width:2&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617512-f928d62a-5a55-49a2-9074-620bf2caa140.webp#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=142&originWidth=271&size=0&status=done&style=none&width=271"></p><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617526-b402fe29-33bb-445f-b54b-588c8e252aa2.webp#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=800&size=0&status=done&style=none&width=800"><br>矩形是最简单基本形状，只需要其左上角 <code>x</code> 和 <code>y</code> 坐标以及它的宽度(<code>width</code>)和高度(<code>height</code>)，如果想要指定圆角，可以指定 <code>rx</code>(x 方向的圆角半径)，该最大值是矩形宽度的一半，同理，<code>ry</code>(y 方向的圆角半径)，该最大值是矩形高度的一半。如果只指定了 <code>rx</code> 和 <code>ry</code> 中的一个值，则认为它们相等，矩形内部还可以使用 <code>fill</code> 属性来填充颜色，默认为黑色，用 stroke 来绘制边框，默认透明。来几个例子看看。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;300&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;500&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内部填充为黑色，不绘制边框 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;50&#x27;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内部填充为蓝色，绘制较粗，半透明红色边框--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;50&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill: #0000ff;stroke: red;stroke-width: 7; stroke-opacity: .5&#x27;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!-- rx 和 ry 相等，逐渐增大--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;40&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>/&gt;</span>ry5&#x27;<br>  <span class="hljs-comment">&lt;!-- rx 和 ry 相等，逐渐增大--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;5&#x27;</span>  <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;40&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- rx 和 ry 不相等 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;130&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;40&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;130&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;40&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617516-7964c0c9-b7f6-41ab-9f25-e25de22adf47.webp#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=221&originWidth=287&size=0&status=done&style=none&width=287"></p><h2 id="圆和椭圆"><a href="#圆和椭圆" class="headerlink" title="圆和椭圆"></a>圆和椭圆</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617535-c48cbda8-9338-4060-abd9-d010b2161d22.webp#align=left&display=inline&height=384&margin=%5Bobject%20Object%5D&originHeight=384&originWidth=800&size=0&status=done&style=none&width=800"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617486-f6e19135-0536-44ce-8bd8-70a05ccf350c.webp#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=800&size=0&status=done&style=none&width=800"><br>画一个圆，需要使用 <code>&lt;circle&gt;</code> 元素，并指定圆心的 <code>x</code> 和 <code>y</code> 坐标(<code>cx/cy</code>) 以及半径(<code>r</code>)。和矩形一样，不指定 fill 和 stroke 时，圆会使用黑色填充并且没有轮廓线。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;300&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;500&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke-width:5;stroke:black; fill:none&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&#x27;20&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;80&#x27;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&#x27;10&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black; fill:none&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>对于椭圆来说，除了指定圆心和坐标外，还需要同时指定 <code>x</code> 方向的半径和 <code>y</code> 方向的半径，属性分为是 <code>rx</code> 和 <code>ry</code>。对于圆和椭圆来说，如果省略 <code>cx</code> 或者 <code>cy</code> ，则默认为 <code>0</code>，如果半径为 <code>0</code>，则不会显示图形，如果半径为负数，则会报错。来几个例子看看：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617546-cbc746f9-cb9b-443e-a7df-02c3da162116.webp#align=left&display=inline&height=155&margin=%5Bobject%20Object%5D&originHeight=155&originWidth=240&size=0&status=done&style=none&width=240"></p><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617500-92caefc0-81f5-4f29-8ece-90b1f5da5a77.webp#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&originHeight=367&originWidth=800&size=0&status=done&style=none&width=800"><br>咱们可以使用 <code>&lt;polygon&gt;</code> 元素绘制多边形，使用 <code>points</code> 属性指定一系列的 <code>x/y</code> 坐标对，并用逗号或者空格分隔<strong>坐标个数必须是偶数</strong>。指定坐标不需要在最后指定返回起始坐标， <code>&lt;polygon&gt;</code> 元素会自动回到起始坐标。来几个例子看看：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--平等四边形--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;15,10 55,10 45,20 5,20&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:red; stroke: black;&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br>  <span class="hljs-comment">&lt;!--五角星--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;35,37.5 37.9,46.1 46.9,46.1 39.7,51.5</span></span><br><span class="hljs-string"><span class="hljs-tag">    42.3,60.1 35,55 27.7,60.1 30.3,51.5 23.1,46.1 32.1,46.1&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill: #ccffcc; stroke: green;&#x27;</span></span><br><span class="hljs-tag">    /&gt;</span><br>  <span class="hljs-comment">&lt;!--不规则图形--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;60 60, 65,72 80 60, 90,90 72,85 50,95&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;fill: yellow; fill-opacity:.5; stroke:black&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617540-f92edb4f-bbdc-4d57-bc75-0648230b17dd.webp#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&originHeight=149&originWidth=268&size=0&status=done&style=none&width=268"><br>从上面很容易看出多边形都很容易填充，因为多边形的各边都没有交叉，很容易区分出多边形的内部区域和外部区域。但是，当多边形彼此交叉的时候，要区分哪些区域是图形内部并不容易。如下如融合所示，中间的区域是算内部还是外部呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;48,16 16,96 96,48 0,48 80,96&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke: black;&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617509-a4ad7b9a-f6f5-4aff-937d-5f10a9f44e5c.webp#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=132&originWidth=244&size=0&status=done&style=none&width=244"><br>SVG 有两种判断某个点是否在多边形中的规则。分别对应<code>fill-true</code>属性的<code>nonezero</code>（默认值）和<code>evenodd</code>。其效果图分别如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;padding: 100px 0 0 200px&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;48,16 16,96 96,48 0,48 80,96&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill-rule: nonzero; fill:yellow; stroke: black;&#x27;</span></span><br><span class="hljs-tag">  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;148,16 116,96 196,48 100,48 180,96&#x27;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill-rule: evenodd; fill:red; stroke: black;&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617566-98727132-9e1f-4591-8d6c-981363d98de4.webp#align=left&display=inline&height=131&margin=%5Bobject%20Object%5D&originHeight=131&originWidth=365&size=0&status=done&style=none&width=365"></p><h2 id="折线"><a href="#折线" class="headerlink" title="折线"></a>折线</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617561-d027769e-4e32-4338-a088-8abdc41db0a9.webp#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&originHeight=398&originWidth=800&size=0&status=done&style=none&width=800"><br><code>&lt;polyline&gt;</code> 元素与 有相同的属性，不同之处在于图形并不封闭，直接来个事例看看：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&quot;5,20 20,20 25,10 35,30 45,10</span></span><br><span class="hljs-string"><span class="hljs-tag">    55,30 65,10 74,30 80,20 95,20&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;stroke:black; stroke-width:3; fill:none&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617538-f8c294be-485f-4897-8167-7f02eab16db5.webp#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&originHeight=87&originWidth=197&size=0&status=done&style=none&width=197"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="形状元素"><a href="#形状元素" class="headerlink" title="形状元素"></a>形状元素</h4><p>线段：<code>&lt;line x1=&quot; &quot; y1=&quot; &quot; x2=&quot; &quot; y2=&quot; &quot; style=&quot; &quot;/&gt;</code><br>矩形：<code>&lt;rect x=&quot; &quot; y=&quot; &quot; width=&quot; &quot; height=&quot; &quot; style=&quot; &quot;/&gt;</code><br>圆角矩形：<code>&lt;rect x=&quot; &quot; y=&quot; &quot; rx=&quot; &quot; ry=&quot; &quot; style=&quot; &quot;/&gt;</code><br>圆形：<code>&lt;circle cx=&quot; &quot; cy=&quot; &quot; r=&quot; &quot; style=&quot; &quot;/&gt;</code><br>椭圆形：<code>&lt;ellipse cx=&quot; &quot; cy=&quot; &quot; rx=&quot; &quot; ry=&quot; &quot; style=&quot; &quot; /&gt;</code><br>多边形：<code>&lt;polygon points=&quot; &quot; style=&quot; &quot;/&gt;</code><br>折线：<code>&lt;polyline points=&quot; &quot; style=&quot; &quot;/&gt; //注意需把fill设成none</code><br>SVG 有两种判断某个点是否在多边形中的规则。分别对应<code>fill-true</code>属性的<code>nonezero</code>（默认值）和<code>evenodd</code>。其效果图分别如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617572-7b3802d8-324b-449e-b046-f643ee3e3a2f.webp#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&originHeight=368&originWidth=250&size=0&status=done&style=none&width=250"></p><h4 id="笔画特性："><a href="#笔画特性：" class="headerlink" title="笔画特性："></a>笔画特性：</h4><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>stoke</td><td>笔画颜色，默认为 none</td></tr><tr><td>stroke-opacity</td><td>笔画透明度，默认为 1.0（完全不透明），值范围：0.0~1.0</td></tr><tr><td>stroke-dasharray</td><td>用一系列数字指定虚线和间隙的长度，如：stroke-dasharray:5,10,5,20</td></tr><tr><td>stroke-linecap</td><td>线头尾的形状：butt（默认）、round、square</td></tr><tr><td>stroke-linejoin</td><td>图形的棱角或一系列连线的形状：miter（尖的，默认值）、round（圆的）、bevel（平的）</td></tr><tr><td>stroke-miterlimit</td><td>相交处显示宽度与线宽的最大比例，默认为 4</td></tr></tbody></table><h4 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h4><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>fill</td><td>指定填充颜色，默认值为 black</td></tr><tr><td>fill-opacity</td><td>从 0.0 到 1.0 的数字， 0.0 表示完全透明, 1.0(默认值) 表示完全不透明</td></tr><tr><td>fill-rule</td><td>属性值为 nonzero (默认值) 或 evenodd。</td></tr></tbody></table><h2 id="在-SVG-中使用样式"><a href="#在-SVG-中使用样式" class="headerlink" title="在 SVG 中使用样式"></a>在 SVG 中使用样式</h2><p>在 SVG 的使用样式中 CSS 很相似，主要有 4 种，分别如下：</p><ul><li>内联样式</li><li>内部样式表</li><li>外部样式表</li><li>表现属性</li></ul><p><strong>内联样式</strong><br>用法跟 css 一样，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;line <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;fill:yellow;stroke:blue;stroke-width=4&quot;</span> <span class="hljs-attribute">x1</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attribute">y1</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attribute">x2</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attribute">y2</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;*<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>内部样式表</strong><br>用法也跟 css 的类名一样，如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">.linestyle&#123;<br>stroke:red;<br>stroke-width:<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 那么在使用标签时，指定此样式即可：</span><br>&lt;line <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">linestyle</span>&quot; <span class="hljs-symbol">x1</span>=&quot;<span class="hljs-symbol">10</span>&quot; <span class="hljs-symbol">y1</span>=&quot;<span class="hljs-symbol">10</span>&quot; <span class="hljs-symbol">x2</span>=&quot;<span class="hljs-symbol">100</span>&quot; <span class="hljs-symbol">y2</span>=&quot;<span class="hljs-symbol">100</span>&quot;/&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>外部样式表</strong><br>跟 CSS 用法一样，把样式写在另外文件中，然后导入使用。<br><strong>表现属性</strong><br>咱们可能通过 style 属性修改样式，当然 style 里面的属性值，可以单独写，这种也叫表现属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;circle <span class="hljs-attribute">cx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attribute">cy</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attribute">r</span>=<span class="hljs-string">&#x27;5&#x27;</span><br>  <span class="hljs-attribute">fill</span>=<span class="hljs-string">&#x27;red&#x27;</span> <span class="hljs-attribute">stroke</span>=<span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-attribute">stroke-width</span>=<span class="hljs-string">&#x27;2&#x27;</span>/&gt;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="分组与引用对象"><a href="#分组与引用对象" class="headerlink" title="分组与引用对象"></a>分组与引用对象</h2><p>虽然可以将所有的绘图看成是由一系列几乎一样的形状和线条组成的，但通常咱们还是认为大多数非抽象的艺术作品是由一系列命名对象组成的，而这些对象由形状和线条组合而成。SVG 提供了一些元素，允许咱们对元素进行这样的分组，从而使文档更加结构化以及更易理解。</p><h4 id="lt-g-gt-元素"><a href="#lt-g-gt-元素" class="headerlink" title="&lt;g&gt; 元素"></a><code>&lt;g&gt;</code> 元素</h4><p>1）<code>&lt;g&gt;</code>元素会将所有子元素作为一个组合，通常还有一个唯一的 id 作为名称; 2）每个组合还可以拥有自己的<code>&lt;title&gt;</code>和<code>&lt;desc&gt;</code>来供基于文本的 xml 应用程序识别或者为视障用户提供更好的可访问性; 3）阅读器会读取<code>&lt;title&gt;</code>和<code>&lt;desc&gt;</code>元素的内容。鼠标悬停或者轻触组合内的图形时，会显示<code>&lt;title&gt;</code>元素内容的提示框。 4）<code>&lt;g&gt;</code>元素可以组合元素并可以提供一些注释，组合还可以比较嵌套;<br>在起始 标签中指定的所有样式会应用于组合内的所有子元素，如下面示例所示，咱们可以不用复制每个元素上的 <code>style=&#39;fill:none; stroke:black;&#39;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢乐一家人<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>一家人在一起就是简单幸福的了<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;house&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke:black&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>房子<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;6&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;50&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;60&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;60&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;6 50, 36 9, 66 50&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;36 110, 36 80, 50 80， 50 110&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke:green&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>男人<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;56&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;10&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;66&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;85&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;80&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;76 104, 85 80, 94 104&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;76 70, 85 76, 94 70&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;woman&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke:red&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>女人<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;110&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;56&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;10&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;110 66, 110 80, 100 90, 120 90, 110 80&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;104&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;104&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;108&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;90&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;112&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;90&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;116&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;104&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;101 70, 110 76, 119 80&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617693-bc2bb924-1b19-4a7c-97f9-2f13e1697dbb.webp#align=left&display=inline&height=180&margin=%5Bobject%20Object%5D&originHeight=180&originWidth=305&size=0&status=done&style=none&width=305"></p><h4 id="lt-use-gt-元素"><a href="#lt-use-gt-元素" class="headerlink" title="&lt;use&gt; 元素"></a><code>&lt;use&gt;</code> 元素</h4><p>1）复杂的图形中经常会出现重复元素，svg 使用<code>&lt;use&gt;</code>元素为定义在<code>&lt;g&gt;</code>元素内的组合或者任意独立图形元素提供了类似复杂黏贴的能力; 2）定义了一组<code>&lt;g&gt;</code>图形对象后，使用<code>&lt;use&gt;</code>标签再次显示它们。要指定想要的重用的组合就给<code>xlink:href</code>属性指定<code>URI</code>即可，同时还要指定<code>x</code>和<code>y</code>的位置以表示组合应该移动到的位置。 3）<code>&lt;use&gt;</code>元素并不限制只使用在同一个文件内的对象，还可以指定任意有效的文件或者 URI.<br>因此为了创建另一个上面的房子和一组小人，只要把下面的代码入 <code>&lt;svg&gt;</code> 元素里面即可。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;use xlink:<span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;#house&#x27;</span> <span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;100&#x27;</span>/&gt;<br>&lt;use xlink:<span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;#woman&#x27;</span> <span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;-80&#x27;</span> <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;100&#x27;</span>/&gt;<br>&lt;use xlink:<span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;#man&#x27;</span> <span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;-30&#x27;</span> <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;100&#x27;</span>/&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617541-070db860-4f86-4b65-aa03-0d45259e96ad.webp#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&originHeight=256&originWidth=312&size=0&status=done&style=none&width=312"></p><h4 id="lt-defs-gt-元素"><a href="#lt-defs-gt-元素" class="headerlink" title="&lt;defs&gt;元素"></a><code>&lt;defs&gt;</code>元素</h4><p>上面例子有几个缺点：</p><ul><li><p>复用 <code>man</code> 和 <code>woman</code> 组合时，需要知道原始图像中这些图形的位置，并以此位置作为利用的基础，而不是使用诸如 <code>0</code> 这样的简单数字</p></li><li><p>房子的填充和笔画颜色由原始图形建立，并且不能通过 元素覆盖，这说明咱们不能构造一行彩色的房子。</p></li><li><p>文档中会画出所有的三个元素 woman,man 和 house,并不能将它们单独 ‘存储’ 下来，然后只绘制一排房子或者只绘制一组人。</p></li></ul><p><code>&lt;defs&gt;</code> 元素可以解决这些问题<br>1）SVG 规范推荐我们将所有想要复用的对象放置在元素内，这样 SVG 阅读器进入流式环境中就能更轻松地处理数据。 2）由于组合在<code>&lt;defs&gt;</code>元素内，它们不会立刻绘制到屏幕上，而是作为”模板”供其他地方使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&#x27;0 0 240 240&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢乐一家人<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>一家人在一起就是简单幸福的了<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;house&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;stroke:black&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>房子<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;41&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;60&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;60&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;0 41, 30 0, 60 41&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;30 110, 30 71, 44 71， 44 101&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;man&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke:green&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>男人<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;10&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;44&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;1 58, 10 44, 19 58&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;1 24, 10 30, 19 24&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;woman&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:none; stroke:red&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>女人<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&#x27;10&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;10 20, 10 34, 0 44, 20 44, 10 34&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;58&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;8&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;44&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&#x27;44&#x27;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&#x27;16&#x27;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&#x27;58&#x27;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polyline</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&#x27;1 24, 10 30, 19 24&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;couple&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>夫妻<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#man&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#woman&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;25&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#house&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:#cfc&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#couple&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;70&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;40&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#house&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;120&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;fill:#99f&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&#x27;#couple&#x27;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&#x27;190&#x27;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&#x27;40&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617595-076d6053-9c33-4469-a50e-2f4e66828cf6.webp#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&originHeight=176&originWidth=372&size=0&status=done&style=none&width=372"></p><h4 id="lt-symbol-gt-元素"><a href="#lt-symbol-gt-元素" class="headerlink" title="&lt;symbol&gt;元素"></a><code>&lt;symbol&gt;</code>元素</h4><p><code>&lt;symbol&gt;</code>作为模板，同<code>&lt;defs&gt;</code>一样，内部的所有元素都不会展现在画布上，因此咱们无需把它放在 规范内。然而，咱们还是习惯将它放到 <code>&lt;defs&gt;</code> 中，因为 symbol 也是咱们定义的供后续使用的元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;240&#x27;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&#x27;0 0 240 240&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">defs</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;circle&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 100 100&quot;</span> <span class="hljs-attr">preserveAspectRatio</span>=<span class="hljs-string">&quot;xMinYMin meet&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;triangle&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 100 100&quot;</span> <span class="hljs-attr">preserveAspectRatio</span>=<span class="hljs-string">&quot;xMaxYMax slice&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&quot;0 0, 100 0, 50 100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">polygon</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">defs</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;grey&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#circle&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#triangle&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617617-089cc583-7bf8-44d4-b3b9-d67a193cb34e.webp#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=322&size=0&status=done&style=none&width=322"></p><h2 id="image-元素"><a href="#image-元素" class="headerlink" title="image 元素"></a>image 元素</h2><p><code>&lt;image&gt;</code>顾名思义里面放图片的，至于说是矢量图(vector)还是位图(raster)，都成，用起来也方便：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">&lt;svg <span class="hljs-built_in">width</span>=<span class="hljs-string">&#x27;310&#x27;</span> <span class="hljs-built_in">height</span>=<span class="hljs-string">&#x27;310&#x27;</span> viewBox=<span class="hljs-string">&#x27;0 0 310 310&#x27;</span> xmlns=<span class="hljs-string">&#x27;http://wwww.w3.org/2000/svg&#x27;</span>&gt;<br>  &lt;<span class="hljs-built_in">ellipse</span> cx=<span class="hljs-string">&#x27;154&#x27;</span> cy=<span class="hljs-string">&#x27;154&#x27;</span> rx=<span class="hljs-string">&#x27;150&#x27;</span> ry=<span class="hljs-string">&#x27;120&#x27;</span> style=<span class="hljs-string">&#x27;fill: #999&#x27;</span>/&gt;<br>  &lt;<span class="hljs-built_in">ellipse</span> cx=<span class="hljs-string">&#x27;152&#x27;</span> cy=<span class="hljs-string">&#x27;152&#x27;</span> rx=<span class="hljs-string">&#x27;150&#x27;</span> ry=<span class="hljs-string">&#x27;120&#x27;</span> style=<span class="hljs-string">&#x27;fill: #999&#x27;</span> /&gt;<br>  &lt;<span class="hljs-built_in">image</span> xlink:href=<span class="hljs-string">&#x27;3.jpg&#x27;</span> x=<span class="hljs-string">&#x27;72&#x27;</span> y=<span class="hljs-string">&#x27;92&#x27;</span><br>    <span class="hljs-built_in">width</span>=<span class="hljs-string">&#x27;160&#x27;</span> <span class="hljs-built_in">height</span>=<span class="hljs-string">&#x27;120&#x27;</span><br>  /&gt;<br>&lt;/svg&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600656617563-b6c63117-14e4-4eef-91b5-67e9623d6c4d.webp#align=left&display=inline&height=278&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=450&size=0&status=done&style=none&width=450"><br>作者：前端小智<br>链接：<a href="https://juejin.im/post/6844904017273815048">https://juejin.im/post/6844904017273815048</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个超有趣的变色龙智力题</title>
    <link href="/2020/09/20/yuque/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E8%89%B2%E9%BE%99%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <url>/2020/09/20/yuque/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E8%89%B2%E9%BE%99%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://blog.csdn.net/littletigerat/article/details/7583222">https://blog.csdn.net/littletigerat/article/details/7583222</a></p><h2 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h2><p>某岛有三种变色龙，分别为红色，黄色，蓝色，三色分别有<em>13</em>条，<em>15</em>条，<em>17</em>条。当有两只变色龙相遇时，如果颜色不同，他们就变成第三种颜色。如红和黄相遇，都变成蓝色。问：是否可能所有的变色龙都变成同种颜色？</p><h2 id="分析与思路"><a href="#分析与思路" class="headerlink" title="分析与思路"></a>分析与思路</h2><p>您先别着急看答案，先试着做一做。<br>您的答案是什么？为什么是这样的。你的理由是什么？<br>看看您如果遇到此类问题，如何思考。这样可能效果会更好。*<strong>*解决问题的思路更重要。思维过程的更重要。**</strong>问题的解决，就是一个水到渠成的事情了。<br>碰到这样一类题，到底有没有一个套路，有没有一个解决问题的模式呢？让您的答案具有很强的说服力和可行性呢？</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>解决办法：<br>假设某岛红色，黄色，蓝色三色的变色龙的条数分别是<em>X</em>条，<em>Y</em>条，<em>Z</em>条。</p><h3 id="倒数最后一步："><a href="#倒数最后一步：" class="headerlink" title="倒数最后一步："></a>倒数最后一步：</h3><p>如果最终所有的变色龙都变成了同一种颜色，那么最后一次变色，必然满足：<br><em>m</em>条*,m<em>条</em>,n<em>条颜色各异的变色龙，<br>可以再次假设：**\</em>*<strong>m</strong>条<strong>a1</strong>色变色龙，<strong>m</strong>条<strong>a2</strong>色变色龙，<strong>n</strong>条<strong>a3</strong>色变色龙**<strong>，<br>其中</strong>**<strong>a1</strong>，<strong>a2</strong>以及<strong>a3</strong>属于红色、黄色与蓝色的某一个颜色排列序列***<em>。<br><em>m</em>条</em>a1<em>色变色龙与</em>m<em>条</em>a2<em>色变色龙进行相遇，新变成了</em>2m<em>条</em>a3<em>色的变色龙，最后是</em>2m+n<em>条</em>a3*颜色的变色龙。</p><p><strong>演变关系是：</strong></p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th></tr></thead><tbody><tr><td>a1</td><td>m</td><td>0</td></tr><tr><td>a2</td><td>m</td><td>0</td></tr><tr><td>a3</td><td>n</td><td>n+2m</td></tr></tbody></table><p>并且满足如下等式：<br><em>2m+n= X + Y + Z</em></p><h3 id="倒数第二步"><a href="#倒数第二步" class="headerlink" title="倒数第二步"></a>倒数第二步</h3><p>那么如何将<em>X</em>，_Y_，<em>Z</em>等条数的变色龙变成<em>m</em>，_m_，<em>n</em>条数呢？<br>那么将是<em>m + m/2</em>条<em>a1</em>色变色龙*, 0<em>条</em>a2<em>色的变色龙</em>, n + m/2<em>条</em>a3<em>色的变色龙， **</em>*即<strong>3m/2</strong>条<strong>a1</strong>色变色龙，<strong>0</strong>条<strong>a2</strong>色变色龙，*<em>(2n+m)/2<strong>条</strong>a3**色变色龙\</em>***<br><em>a1</em>色变色龙有<em>m/2</em>条与<em>a3</em>色变色龙的<em>m/2</em>色相遇，新变成了<em>m</em>条<em>a2</em>色的变色龙。<br><strong>演变关系是：</strong></p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th></tr></thead><tbody><tr><td>a1</td><td>m + m/2</td><td>m</td></tr><tr><td>a2</td><td>0</td><td>m</td></tr><tr><td>a3</td><td>n + m/2</td><td>n</td></tr></tbody></table><p>现假设<em>m=2k</em>（<em>k</em>可为正整数） *<strong>*即</strong>3k<strong>条</strong>a1<strong>色变色龙，</strong>0<strong>条</strong>a2<strong>色变色龙，</strong>(n+k)<strong>条</strong>a3<strong>色变色龙**</strong><br>并且满足如下等式：<br>_4k+n= X + Y + Z_**</p><h3 id="倒数第三步"><a href="#倒数第三步" class="headerlink" title="倒数第三步"></a>倒数第三步</h3><p>那么如何将<em>X</em>，_Y_，<em>Z</em>等条数的变色龙变成<em>m</em>，_m_，<em>n</em>条数呢？<br>那么将是<em>m + m/2</em>条<em>a1</em>色变色龙*, 0<em>条</em>a2<em>色的变色龙</em>, n + m/2<em>条</em>a3<em>色的变色龙， **</em>*即<strong>3m/2</strong>条<strong>a1</strong>色变色龙，<strong>0</strong>条<strong>a2</strong>色变色龙，*<em>(2n+m)/2<strong>条</strong>a3**色变色龙\</em>***<br><em>a1</em>色变色龙有<em>m/2</em>条与<em>a3</em>色变色龙的<em>m/2</em>色相遇，新变成了<em>m</em>条<em>a2</em>色的变色龙。</p><p><strong>演变关系是：</strong><br><em>a2</em>与<em>a3</em>相遇，变成<em>a1</em>色</p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th></tr></thead><tbody><tr><td>a1</td><td>k</td><td>3k</td></tr><tr><td>a2</td><td>k</td><td>0</td></tr><tr><td>a3</td><td>n + 2k</td><td>n+k</td></tr></tbody></table><p>或者<br><em>a1</em>与<em>a2</em>相遇，变成<em>a3</em>色</p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th></tr></thead><tbody><tr><td>a1</td><td>4k</td><td>3k</td></tr><tr><td>a2</td><td>k</td><td>0</td></tr><tr><td>a3</td><td>n -k</td><td>n+k</td></tr></tbody></table><p>通过以上分析：</p><h3 id="最核心的有一个条件"><a href="#最核心的有一个条件" class="headerlink" title="最核心的有一个条件"></a>最核心的有一个条件</h3><p><code>**通过某些变换，就是可以达到3k条a1变色龙，n+k条a3变色龙**</code><br>这是最容易验证识别的。<br>也就是说：倒数第三步的条件操作起来比较麻烦，而倒数第二步推导出来的条件，容易操作，易于操作。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h2><p>_1_．红色变色龙与黄色变色龙相遇，所有的红色变色龙条数变为<em>0</em></p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th><th>说明</th></tr></thead><tbody><tr><td>红</td><td>13</td><td>0</td><td>0</td></tr><tr><td>黄</td><td>15</td><td>2</td><td>不是 3 的倍数</td></tr><tr><td>蓝</td><td>17</td><td>43</td><td></td></tr><tr><td></td><td>不是 3 的倍数</td><td></td><td></td></tr></tbody></table><p>首先就不满足*<strong>*变色龙的条数是 3 的倍数的条件。**</strong><br>_ _<br>_2_．红色变色龙与黄色变色龙相遇，所有的红色变色龙条数变为<em>0</em></p><table><thead><tr><th>颜色</th><th>相遇前(条数)</th><th>相遇后(条数)</th><th>说明</th></tr></thead><tbody><tr><td>红</td><td>13</td><td>43</td><td>不是 3 的倍数</td></tr><tr><td>黄</td><td>15</td><td>0</td><td>0</td></tr><tr><td>蓝</td><td>17</td><td>2</td><td>不是 3 的倍数</td></tr></tbody></table><p>首先就不满足<strong>****</strong>变色龙的条数是 3 的倍数的条件*<strong>*。**</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>碰到这类有多个数字参与（如：三色分别有<em>13</em>条，<em>15</em>条，<em>17</em>条）的数字游戏题，*<strong>*最好先代数化，尽量分析找到某些规律，然后去针对题目的具体数字进行验证说明，避免一下子掉进数字陷阱，这样推理严谨，答案可靠，有理论依据，速度快**</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript严格模式和非严格模式有什么区别？</title>
    <link href="/2020/09/20/yuque/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2020/09/20/yuque/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903566121893895">https://juejin.im/post/6844903566121893895</a></p><h1 id="JavaScript-中的-严格模式"><a href="#JavaScript-中的-严格模式" class="headerlink" title="JavaScript 中的 严格模式"></a>JavaScript 中的 严格模式</h1><p><code>严格模式</code>：使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。</p><h3 id="严格模式的选择使用"><a href="#严格模式的选择使用" class="headerlink" title="严格模式的选择使用"></a>严格模式的选择使用</h3><p>严格模式的编译指示(pragma): <code>&quot;use strict&quot;;</code>，支持严格模式的引擎会启动这种模式，而不支持该模式的引擎就当遇到了一个未赋值的字符串字面量，会忽略这个编译指示。</p><ul><li>在全局作用域中(函数外部)给出这个编译指示，则整个脚本都将使用严格模式。</li><li>在函数作用域中给出这个编译指示，则这个函数将使用严格模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &quot;use strict&quot;</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="严格模式的规范"><a href="#严格模式的规范" class="headerlink" title="严格模式的规范"></a>严格模式的规范</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol><li>不允许意外创建全局变量，给一个没有声明的变量赋值，那代码在执行时就会抛出 ReferenceError</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 未声明变量</span><br><span class="hljs-comment">// 非严格模式:创建全局变量</span><br><span class="hljs-comment">// 严格模式:抛出 ReferenceError</span><br>message = <span class="hljs-string">&quot;Hello world! &quot;</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>不能对变量调用 delete 操作符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//删除变量</span><br><span class="hljs-comment">//非严格模式:静默失败</span><br><span class="hljs-comment">//严格模式:抛出 ReferenceError</span><br><span class="hljs-keyword">var</span> color = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-keyword">delete</span> color;<br></code></pre></td></tr></table></figure><ol start="3"><li>严格模式下对变量名也有限制，不能使用 implements、interface、let、package、 private、protected、public、static 和 yield 标识符作为变量名，使用以上标识符作为变量名会导致语法错误。</li></ol><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol><li>为只读属性赋值会抛出 TypeError</li><li>对不可配置的(nonconfigurable)的属性使用 delete 操作符会抛出 TypeError</li><li>为不可扩展的(nonextensible)的对象添加属性会抛出 TypeError</li><li>使用对象字面量时，属性名必须唯一</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 重名属性</span><br><span class="hljs-comment">// 非严格模式:没有错误，以第二个属性为准</span><br><span class="hljs-comment">// 严格模式:抛出语法错误</span><br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Greg&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol><li>严格模式要求命名函数的参数必须唯一</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//重名参数</span><br><span class="hljs-comment">//非严格模式:没有错误，只能访问第二个参数</span><br><span class="hljs-comment">//严格模式:抛出语法错误</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num, num</span>) </span>&#123;<br>  <span class="hljs-comment">// todo</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在非严格模式下，修改命名参数的值也会反映到 arguments 对象中，而严格模式下这两个值是完全独立的</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//修改命名参数的值</span><br><span class="hljs-comment">//非严格模式:修改会反映到 arguments 中</span><br><span class="hljs-comment">//严格模式:修改不会反映到 arguments 中</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showValue</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  value = <span class="hljs-string">&quot;Foo&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">//&quot;Foo&quot;</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//非严格模式:&quot;Foo&quot;，严格模式:&quot;Hi&quot;</span><br>&#125;<br>showValue(<span class="hljs-string">&quot;Hi&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>arguments.callee 和 arguments.caller，在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//访问 arguments.callee</span><br><span class="hljs-comment">//非严格模式:没有问题</span><br><span class="hljs-comment">//严格模式:抛出 TypeError</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> num * <span class="hljs-built_in">arguments</span>.callee(num - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> result = factorial(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>严格模式对函数名也做出了限制，不允许用 implements、interface、let、package、private、protected、public、static 和 yield 作为函数名</li><li>只能在脚本的顶级和在函数内部声明函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在 if 语句中声明函数</span><br><span class="hljs-comment">//非严格模式:将函数提升到 if 语句外部</span><br><span class="hljs-comment">//严格模式:抛出语法错误</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// todo</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><ol><li>在严格模式中，它在包含上下文中不再创建变量或函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用 eval()创建变量</span><br><span class="hljs-comment">//非严格模式:弹出对话框显示 10</span><br><span class="hljs-comment">//严格模式:调用 alert(x)时会抛出 ReferenceError</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;var x=10&quot;</span>);<br>  alert(x);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>可以在 eval()中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就将被销毁</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;var x=10, y=11; x+y&quot;</span>);<br>alert(result); <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h4 id="eval-和-arguments"><a href="#eval-和-arguments" class="headerlink" title="eval 和 arguments"></a>eval 和 arguments</h4><p>严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把 eval 和 arguments 作为变量引用</span><br><span class="hljs-comment">// 非严格模式: 没问题，不出错</span><br><span class="hljs-comment">// 严格模式: 抛出语法错误</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">eval</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">arguments</span> = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="抑制-this"><a href="#抑制-this" class="headerlink" title="抑制 this"></a>抑制 this</h4><p>在非严格模式下使用函数的 apply()或 call()方法时，null 或 undefined 值会被转换为全局 对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 访问属性</span><br><span class="hljs-comment">// 非严格模式: 传入null, 函数的this值是全局对象</span><br><span class="hljs-comment">// 严格模式: 抛出错误，因为this的值为 null</span><br><span class="hljs-keyword">var</span> color = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayColor</span>(<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-built_in">this</span>.color);<br>&#125;<br>displayColor.call(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h4 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h4><ol><li>非严格模式下的 with 语句能够改变解析标识符的路径。严格模式下，with 被简化掉了</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//with 的语句用法</span><br><span class="hljs-comment">//非严格模式:允许</span><br><span class="hljs-comment">//严格模式:抛出语法错误</span><br><span class="hljs-keyword">with</span> (location) &#123;<br>  alert(href);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>严格模式去掉了 JavaScript 中的八进制字面量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用八进制字面量</span><br><span class="hljs-comment">//非严格模式:值为 8</span><br><span class="hljs-comment">//严格模式:抛出语法错误</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">010</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>严格模式下 parseInt()的行为，八进制字面量在严格模式下会被当作以 0 开头的十进制字面量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用 parseInt()解析八进制字面量</span><br><span class="hljs-comment">//非严格模式:值为 8</span><br><span class="hljs-comment">//严格模式:值为 10</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现一个new</title>
    <link href="/2020/09/20/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"/>
    <url>/2020/09/20/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/</url>
    
    <content type="html"><![CDATA[<p>本文部分转自：<a href="https://segmentfault.com/a/1190000022140993">https://segmentfault.com/a/1190000022140993</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>new</code> 大家肯定都不陌生，单身没有对象的时候就 <code>new</code> 一个，很方便。那么它在创建实例的时候，具体做了哪些操作呢？今天我们就来一起分析一下。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在介绍 <code>new</code> 之前，必须要知道什么是构造函数。<br>构造函数和普通函数在写法上没有任何区别，当一个函数通过 <code>new Fun()</code> 调用时，就叫做<strong>构造函数</strong>，构造函数首字母通常大写。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">User</span>(<span class="hljs-type">name</span>) &#123;<br>    this.name = <span class="hljs-type">name</span>;<br>&#125;<br>let u = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(<span class="hljs-string">&#x27;leo&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这里，<code>User</code> 就是构造函数，当然你也可以直接调用 <code>User()</code>，但是这样就起不到创建实例的作用，在非严格模式下，会把 <code>name</code> 属性挂在 <code>window</code> 上。</p><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><p>那么 <code>new</code> 操作符到底做了什么事情呢，可以创建出一个实例？</p><blockquote><p><strong><code>new</code> 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。**<code>new</code>**关键字会进行如下的操作：</p><ol><li>创建一个空的简单 JavaScript 对象（即**<code>&#123;&#125;</code>**）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤 1 新创建的对象作为**<code>this</code>**的上下文 ；</li><li>如果该函数没有返回对象，则返回**<code>this</code>**。</li></ol></blockquote><p>以上引用自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new 操作符 - MDN</a><br>可能第 2、4 步大家看的不是很明白，这里我重新总结一下这 4 个步骤：</p><ol><li>创建一个空对象 <code>u = &#123;&#125;</code></li><li>绑定原型，<code>u.__proto__ = User.prototype</code></li><li>调用 <code>User()</code> 函数，并把空对象 <code>u</code> 当做 <code>this</code> 传入，即 <code>User.call(u)</code></li><li>如果 <code>User()</code> 函数执行完自己 <code>return</code> 一个 <code>object</code> 类型，那么返回此变量，否则返回 <code>this</code>，</li></ol><p><strong>注意：如果构造函数返回基本类型值，则不影响，还是返回 <code>this</code></strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Func, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 创建构造函数Func的新对象</span><br>  <span class="hljs-keyword">const</span> instance = &#123;&#125;;<br>  <span class="hljs-comment">// 设置对象的__proto__ 为构造函数的prototype</span><br>  <span class="hljs-keyword">if</span> (Func.prototype) &#123;<br>    <span class="hljs-built_in">Object</span>.setPrototypeOf(instance, Func.prototype);<br>  &#125;<br>  <span class="hljs-comment">// 将instance作为this，执行一次构造函数</span><br>  <span class="hljs-keyword">const</span> res = Func.apply(instance, args);<br>  <span class="hljs-comment">// 若返回值为object或function，返回res</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;function&quot;</span> || (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>)) &#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">// 若无返回，或返回为基本值，直接返回this也就是instance</span><br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> me = myNew(Person, <span class="hljs-string">&quot;Jack&quot;</span>);<br>me.sayName();<br><span class="hljs-built_in">console</span>.log(me);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现trim</title>
    <link href="/2020/09/20/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0trim/"/>
    <url>/2020/09/20/yuque/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0trim/</url>
    
    <content type="html"><![CDATA[<p>Q：实现一个函数 trim(str)  字符串前后去空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str</span>) </span>&#123;&#125;<br>trim(<span class="hljs-string">&quot;     hello world     &quot;</span>); <span class="hljs-comment">// =&gt; hello world</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用正则匹配前后字符串<br>使用 split 空格求一个数组，然后删除数组中空元素，再转为字符串</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/(^\s*)|(\s*$)/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-comment">// return str.split(&#x27; &#x27;).filter(e=&gt;e).join(&#x27;&#x27;)</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月20日</title>
    <link href="/2020/09/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8820%E6%97%A5/"/>
    <url>/2020/09/20/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>牛客网多题</p><span id="more"></span><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。<br><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;babad&quot;</span><br>输出: <span class="hljs-string">&quot;bab&quot;</span><br>注意: <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;cbbd&quot;</span><br>输出: <span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力遍历所有可能，无法通过，超时</p><h4 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h4><p>回文串一定是对称的，每次选择一个中心，进行中心向两边扩展比较左右字符是否相等<br>中心点的选取有两种<br>aba，中心点是 b<br>aa，中心点是两个 a 之间<br>所以共有两种组合可能<br>left：i，right：i<br>left：i，right：i+1<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600604571760-b7a042a7-39ba-4271-b0de-500bb9db42cf.png#align=left&display=inline&height=494&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=576&size=0&status=done&style=none&width=576"></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>  <span class="hljs-keyword">const</span> isReverse = <span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> s.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>) === s;<br>  &#125;;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; s.length + <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">let</span> str = s.slice(i, j);<br>      <span class="hljs-keyword">let</span> length = str.length;<br>      <span class="hljs-keyword">if</span> (isReverse(str) &amp;&amp; <span class="hljs-built_in">Math</span>.max(max, length) === length) &#123;<br>        max = length;<br>        res = str;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="中心拓展法"><a href="#中心拓展法" class="headerlink" title="中心拓展法"></a>中心拓展法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>,<br>    end = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> center = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) &#123;<br>      left--;<br>      right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>  &#125;;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (index &lt; s.length) &#123;<br>    <span class="hljs-keyword">let</span> maxLen = <span class="hljs-built_in">Math</span>.max(center(index, index), center(index, index + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">let</span> len1 = center(index, index);<br>    <span class="hljs-keyword">let</span> len2 = center(index, index + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (maxLen &gt; max) &#123;<br>      <span class="hljs-keyword">if</span> (maxLen % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>        max = maxLen;<br>        start = index - maxLen / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        end = index + maxLen / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        max = maxLen;<br>        start = index - (maxLen - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        end = index + (maxLen + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>      &#125;<br>    &#125;<br>    index++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.slice(start, end);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="寻找第-K-大"><a href="#寻找第-K-大" class="headerlink" title="寻找第 K 大"></a>寻找第 K 大</h1><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 K 大的数。<br>给定一个整数数组 a,同时给定它的大小 n 和要找的 K(K 在 1 到 n 之间)，请返回第 K 大的数，保证答案存在。<br>测试样例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1,3,5,2,2]</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span><br>返回：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>提示使用快速排序的思路，快排一次以后，一个下标的元素在排序后的数组中的位置已经确认。所以不需要全部排完再得到答案，判断当前下标的值大于或小于 K，大于 K 则需要在左边查找，小于 K 则在右边查找，直到查找到 K 为止，</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>a int整型一维数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>n int整型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>K int整型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findKth</span>(<span class="hljs-params">a, n, K</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">start, end</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> i = start;<br>    <span class="hljs-keyword">let</span> j = end;<br>    <span class="hljs-keyword">let</span> tmp = a[start];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= tmp) j--;<br>      <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= tmp) i++;<br>      [a[i], a[j]] = [a[j], a[i]];<br>    &#125;<br>    [a[start], a[i]] = [a[i], a[start]];<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">let</span> index = quickSort(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (index !== n - K) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; n - K) &#123;<br>      index = quickSort(<span class="hljs-number">0</span>, index - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      index = quickSort(index + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a[index];<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">findKth</span>: findKth,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表中的节点每-k-个一组翻转"><a href="#链表中的节点每-k-个一组翻转" class="headerlink" title="链表中的节点每 k 个一组翻转"></a>链表中的节点每 k 个一组翻转</h1><p>将给出的链表中的节点每 <em>k</em> 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是<em>k</em> 的倍数，将最后剩下的节点保持原样<br><strong>你不能更改节点中的值，只能更改节点本身。</strong><br>要求空间复杂度** <em>O</em>(1)**<br>例如：<br>给定的链表是 1→2→3→4→5<br>对于<em>k</em>=2, 你应该返回 2→1→4→3→5<br>对于<em>k</em>=3, 你应该返回 3→2→1→4→5<br><strong>示例 1</strong><br>输入</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="不限制空间复杂度及修改方式"><a href="#不限制空间复杂度及修改方式" class="headerlink" title="不限制空间复杂度及修改方式"></a>不限制空间复杂度及修改方式</h4><p>刚开始没看到限制空间复杂度为 O(1)，和不能直接修改值。若不限制有简单的实现方法。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="不限制空间复杂度及修改方式-1"><a href="#不限制空间复杂度及修改方式-1" class="headerlink" title="不限制空间复杂度及修改方式"></a>不限制空间复杂度及修改方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>k int整型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseKGroup</span>(<span class="hljs-params">head, k</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> tmp = head;<br>  <span class="hljs-keyword">while</span> (tmp) &#123;<br>    <span class="hljs-keyword">let</span> reverseStack = [];<br>    <span class="hljs-keyword">let</span> tmp2 = tmp;<br>    <span class="hljs-keyword">while</span> (reverseStack.length &lt; k &amp;&amp; tmp2) &#123;<br>      reverseStack.push(tmp2.val);<br>      tmp2 = tmp2.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (reverseStack.length === k) &#123;<br>      <span class="hljs-keyword">while</span> (reverseStack.length) &#123;<br>        tmp.val = reverseStack.pop();<br>        tmp = tmp.next;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">reverseKGroup</span>: reverseKGroup,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>比较简单，栈实现即可，使用一个对象来判断括号合法性</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>s string字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>bool布尔型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">const</span> valid = &#123;<br>    <span class="hljs-string">&quot;()&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;&#123;&#125;&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;[]&quot;</span>: <span class="hljs-literal">true</span>,<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (s.length % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> stack = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (stack.length) &#123;<br>      <span class="hljs-keyword">let</span> top = stack[stack.length - <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">let</span> str = top + arr;<br>      <span class="hljs-keyword">if</span> (valid[str]) stack.pop();<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      stack.push(arr);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">isValid</span>: isValid,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="斐波那契数列（跳楼梯）"><a href="#斐波那契数列（跳楼梯）" class="headerlink" title="斐波那契数列（跳楼梯）"></a>斐波那契数列（跳楼梯）</h1><p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0，第 1 项是 1）。<br>n&lt;=39</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>dp 求解即可</p><h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fibonacci</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> sum = a + b;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    a = b;<br>    b = sum;<br>    sum = a + b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">Fibonacci</span>: Fibonacci,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="实现二叉树先序，中序和后序遍历"><a href="#实现二叉树先序，中序和后序遍历" class="headerlink" title="实现二叉树先序，中序和后序遍历"></a>实现二叉树先序，中序和后序遍历</h1><p>分别按照二叉树先序，中序和后序打印所有的节点。<br><strong>示例 1</strong><br>输入</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>一次遍历即可建立好结果数组</p><h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function TreeNode(x) &#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.left = null;</span><br><span class="hljs-comment"> *   this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>root TreeNode类 the root of binary tree</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型二维数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeOrders</span>(<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> res = [[], [], []];<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    res[<span class="hljs-number">0</span>].push(root.val);<br>    visit(root.left);<br>    res[<span class="hljs-number">1</span>].push(root.val);<br>    visit(root.right);<br>    res[<span class="hljs-number">2</span>].push(root.val);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">threeOrders</span>: threeOrders,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表中是否有环"><a href="#链表中是否有环" class="headerlink" title="链表中是否有环"></a>链表中是否有环</h1><p>判断给定的链表中是否有环</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h4 id="hash-表"><a href="#hash-表" class="headerlink" title="hash 表"></a>hash 表</h4><p>通过 map 存节点，判断 map 中是否已有节点，已有则存在</p><h4 id="增加-isVisit-字段判断"><a href="#增加-isVisit-字段判断" class="headerlink" title="增加 isVisit 字段判断"></a>增加 isVisit 字段判断</h4><p>通过 js 特性来判断</p><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快指针走两次，慢指针走一次，如果有环，快指针会赶上慢指针。</p><h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><h4 id="hash-表-1"><a href="#hash-表-1" class="headerlink" title="hash 表"></a>hash 表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>bool布尔型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(head)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> map.set(head, <span class="hljs-literal">true</span>);<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">hasCycle</span>: hasCycle,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="增加-isVisit-字段判断-1"><a href="#增加-isVisit-字段判断-1" class="headerlink" title="增加 isVisit 字段判断"></a>增加 isVisit 字段判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>bool布尔型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    <span class="hljs-keyword">if</span> (head.isVisit) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    head.isVisit = <span class="hljs-literal">true</span>;<br>    head = head.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">hasCycle</span>: hasCycle,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>bool布尔型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> fast = head;<br>  <span class="hljs-keyword">let</span> slow = head;<br>  <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) &#123;<br>    fast = fast.next.next;<br>    slow = slow.next;<br>    <span class="hljs-keyword">if</span> (fast === slow) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">hasCycle</span>: hasCycle,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过 1000）</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>一个指向字符串头，一个指向字符串尾。当两个指针相遇强，不断交换指针的值，得到答案。</p><h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反转字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>str string字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>string字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = str.length - <span class="hljs-number">1</span>;<br>  str = str.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    [str[start], str[end]] = [str[end], str[start]];<br>    start++;<br>    end--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> str.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">solve</span>: solve,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并两个有序的数组"><a href="#合并两个有序的数组" class="headerlink" title="合并两个有序的数组"></a>合并两个有序的数组</h2><p>给出两个有序的整数数组 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344762-55ae2c98-51c5-4369-a913-7e6e2fde99b5.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">和 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344786-230a6125-5874-41ab-943f-9507234f1bfe.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">，请将数组 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344752-683cb4ef-bb87-4d01-a858-802ebe714688.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">合并到数组 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344762-5c4da8bd-f0df-4a23-aede-9274b469c084.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">中，变成一个有序的数组<br>注意：<br>可以假设 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344765-43c0172e-0669-417f-b9c4-786ad5fd7485.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">数组有足够的空间存放 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344748-a9c635e7-9cd9-4a43-ace5-da2ad5be3688.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">数组的元素， <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344796-7325b84f-1fad-4746-bcdd-b6e3b01cc5bb.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">和 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344789-6aba42d1-e033-4173-8683-eb0647e04ff4.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=21&size=0&status=done&style=none&width=16">中初始的元素数目分别为 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344822-f9be31b7-ff94-4ba1-8e27-bc679b470f12.svg#align=left&display=inline&height=11&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=24&size=0&status=done&style=none&width=18">和 <img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600592344823-cfb51322-7635-4efa-b2cb-d753ea1b5e59.svg#align=left&display=inline&height=12&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=18&size=0&status=done&style=none&width=14"></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>即归并排序中的合并原理，设置一个指针指向排序结果结尾下标 m+n-1，从这里开始排序。将两个指针指向 A、B 结尾，判断指针指向的值哪个大，大的放入结果指针指向的地方，令结果指针和大的那个值的数组指针减一，当 m、n 其中一个小于 0，结束循环，将另外一个数组剩下的元素赋值进 A 即可。</p><h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>A int整型一维数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>B int整型一维数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-variable">void</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">A, m, B, n</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">let</span> k = m + n - <span class="hljs-number">1</span>;<br>  m = m - <span class="hljs-number">1</span>;<br>  n = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (A[m] &gt; B[n]) &#123;<br>      A[k--] = A[m--];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      A[k--] = B[n--];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span>) &#123;<br>    A[k--] = A[m--];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>    A[k--] = B[n--];<br>  &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">merge</span>: merge,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表倒数第-k-个元素"><a href="#删除链表倒数第-k-个元素" class="headerlink" title="删除链表倒数第 k 个元素"></a>删除链表倒数第 k 个元素</h2><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针<br>例如，<br>  给出的链表为:1-&gt;2-&gt;3-&gt;4-&gt;5, n= 2.<br>  删除了链表的倒数第 n 个节点之后,链表变为 1-&gt;2-&gt;3-&gt;5.<br>备注：<br>题目保证 n 一定是有效的<br>请给出请给出时间复杂度为**<em>O</em>(<em>n</em>)**的算法</p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>使用队列存链表的值，删除倒数第 n 个元素，重新生成链表即可</p><h3 id="解答-9"><a href="#解答-9" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * function ListNode(x)&#123;</span><br><span class="hljs-comment"> *   this.val = x;</span><br><span class="hljs-comment"> *   this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>head ListNode类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>n int整型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">head, n</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>  <span class="hljs-keyword">const</span> queue = [];<br>  <span class="hljs-keyword">let</span> tmp = head;<br>  <span class="hljs-keyword">while</span> (tmp) &#123;<br>    queue.push(tmp.val);<br>    tmp = tmp.next;<br>  &#125;<br>  tmp = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-literal">null</span>);<br>  queue.splice(queue.length - n, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> res = tmp;<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    tmp.next = <span class="hljs-keyword">new</span> ListNode(queue.shift());<br>    tmp = tmp.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.next;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">removeNthFromEnd</span>: removeNthFromEnd,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组{1,2,3,2,2,2,5,4,2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>哈希表存储，如果出现的次数大于数组一半，返回值。不存在则返回 0</p><h3 id="解答-10"><a href="#解答-10" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MoreThanHalfNum_Solution</span>(<span class="hljs-params">numbers</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> number <span class="hljs-keyword">of</span> numbers) &#123;<br>    map.set(number, map.has(number) ? map.get(number) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (map.get(number) &gt; <span class="hljs-built_in">Math</span>.floor(numbers.length / <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span> number;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">MoreThanHalfNum_Solution</span>: MoreThanHalfNum_Solution,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>请实现有重复数字的有序数组的二分查找。<br>输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。<br><strong>示例 1</strong><br>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span>,<span class="hljs-number">4</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>判断数组第一个值是否大于查找值，是的话直接返回 1。后面是常规的二分查找，知道找到中点大于等于查找值，中点的前一个点小于查找值为止。</p><h3 id="解答-11"><a href="#解答-11" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二分查找</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>n int整型 数组长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>v int整型 查找值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>a int整型一维数组 有序数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upper_bound_</span>(<span class="hljs-params">n, v, a</span>) </span>&#123;<br>  <span class="hljs-comment">// write code here</span><br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] &gt;= v) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> end = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> middle = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    middle = <span class="hljs-built_in">Math</span>.floor((start + end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (a[middle] &gt;= v &amp;&amp; a[middle - <span class="hljs-number">1</span>] &lt; v) &#123;<br>      <span class="hljs-keyword">return</span> middle + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[middle] &gt;= v) &#123;<br>      end = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      start = middle + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">upper_bound_</span>: upper_bound_,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>二分算法</tag>
      
      <tag>快慢指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6,CommonJS 区别</title>
    <link href="/2020/09/20/yuque/ES6,CommonJS%20%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/09/20/yuque/ES6,CommonJS%20%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.cnblogs.com/whm-blog/p/9750021.html">https://www.cnblogs.com/whm-blog/p/9750021.html</a></p><p>es6 {<br>　　 export   :      ‘可以输出多个，输出方式为 {}’ ，<br>　　 export  default : ‘ 只能输出一个 ，可以与 export 同时输出，但是不建议这么做’，<br>　　解析阶段确定对外输出的接口，解析阶段生成接口，<br>　　模块不是对象，加载的不是对象，<br>　　可以单独加载其中的某个接口（方法），<br>　　<strong>静态引入**</strong>，编译时引用<strong>，输出的是值的</strong>引用<strong>，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变，<br>**只有 ES6 MODULE 才能静态分析，实现 Tree-shaking</strong><br>　　 this 指向 undefined<br>}<br>commonJS {<br>　　 module.exports =  …   :      ‘只能输出一个，且后面的会覆盖上面的’ ，<br>　　 exports. …  : ‘ 可以输出多个’，<br>　　<strong>运行阶段确定接口，运行时才会加载模块</strong>，<br><strong>动态引入，执行时引入</strong><br>　　模块是对象，加载的是该对象，<br>　　加载的是整个模块，即将所有的接口全部加载进来，<br>　　输出是值的*<em>拷贝\</em>*，即原来模块中的值改变不会影响已经加载的该值，<br>　　 this 指向当前模块<br>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gulp与Grunt</title>
    <link href="/2020/09/19/yuque/Gulp%E4%B8%8EGrunt/"/>
    <url>/2020/09/19/yuque/Gulp%E4%B8%8EGrunt/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.jianshu.com/p/1a255e740710">https://www.jianshu.com/p/1a255e740710</a>、<a href="https://juejin.im/post/6844903870456414216">https://juejin.im/post/6844903870456414216</a>、<a href="https://segmentfault.com/a/1190000019650765">https://segmentfault.com/a/1190000019650765</a></p><h3 id="1-Gulp"><a href="#1-Gulp" class="headerlink" title="1. Gulp"></a>1. Gulp</h3><blockquote><p>gulp 是基于 Nodejs 的自动任务运行器，能自动化的完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。</p></blockquote><p>通俗来讲，gulp 就是一个处理项目文件的工具，通过 gulp 建立一些任务，当我们对相应文件进行修改之后，会自动触发这些任务，自动的对文件进行了处理。不用我们手动的、反复的去处理这些文件，大大提高了我们的工作效率。<br>举个栗子：<br>现在已经开始用 less 来写样式（less 的优点很多，写起来要比 css 快很多，在此不多说，盆友们可以上网了解 less），在 html 使用这些样式，需要用一些工具将.less 文件转换为.css 文件，如果用 Sublime 敲代码的盆友可能知道它有插件自动生成 css，但是.less 和生成的.css 文件在同一目录下。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531104332-8a3394fa-af58-4363-abbf-771829d24747.webp#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=128&size=0&status=done&style=none&width=128"><br>目录.png</p><p>这只是文件比较少的情况，如果文件比较多呢？是不是也是一件很头疼的事情…<br>下面，上代码带你用 gulp 解决令人头疼的问题 ^ _ ^<br>前提我们已经创建好一个 nodejs 项目，这里我们安装两个插件: gulp 和 gulp-less(编译 less 文件)<br><code>npm install gulp --save-dev</code><br><code>npm install gulp-less --save-dev</code></p><blockquote><p>新建 gulpfile.js 文件</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 说明：gulpfile.js是gulp项目的配置文件，放项目根目录即可。<br><span class="hljs-regexp">//</span> 导入工具包<br>var gulp = require(<span class="hljs-string">&#x27;gulp&#x27;</span>),<br>    less = require(<span class="hljs-string">&#x27;gulp-less&#x27;</span>);<br><span class="hljs-regexp">//</span> 定义一个testLess任务（自定义任务名称）<br>gulp.task(<span class="hljs-string">&#x27;testLess&#x27;</span>, <span class="hljs-keyword">function</span> () &#123;<br>    gulp.src(<span class="hljs-string">&#x27;public/stylesheets/style.less&#x27;</span>) <span class="hljs-regexp">//</span>该任务针对的文件<br>        .pipe(less()) <span class="hljs-regexp">//</span>该任务调用的模块<br>        .pipe(gulp.dest(<span class="hljs-string">&#x27;public/css&#x27;</span>)); <span class="hljs-regexp">//</span>将会在public/css下生成style.css<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来，我们只需要在命令行输入<code>gulp testLess</code>我们就可以在 public/css 下看到生成的 style.css 文件了<br>but 这显然是我们手动来生成的，我们需要的是让它自动生成，那好吧，现在我们需要一个东西能够来监听 less 文件的修改，然后自动去执行任务</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">gulp.task(<span class="hljs-string">&#x27;testWatch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>    gulp.watch(<span class="hljs-string">&#x27;public/stylesheets/*.less&#x27;</span>, [<span class="hljs-string">&#x27;testLess&#x27;</span>]); <span class="hljs-comment">//当所有less文件发生改变时，调用testLess任务</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>好了，现在我们运行<code>gulp testWatch</code>当修改了 less 文件保存，会看到 css 文件也跟着变了^ _ ^<br>补充一点，我们在一个项目里使用 gulp 的时候，我们想启动项目，就自动启动了 testWatch，而不是启动项目之后，我们还要手动启动 testWatch，那么，加上下面代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>,[<span class="hljs-string">&#x27;testWatch&#x27;</span>]); <span class="hljs-regexp">//</span> 指定gulp默认启动任务<br></code></pre></td></tr></table></figure><h3 id="2-Grunt"><a href="#2-Grunt" class="headerlink" title="2. Grunt"></a>2. Grunt</h3><blockquote><p>Grunt 基于 Node.js ，用 JS 开发，这样就可以借助 Node.js 实现跨系统跨平台的桌面端的操作，例如文件操作等等。此外，Grunt 以及它的插件们，都作为一个 包 ，可以用 NPM 安装进行管理。</p></blockquote><p>Grunt 依赖 Node.js 所以在安装之前确保你安装了 Node.js。然后开始安装 Grunt。<br>Grunt 可以帮助我们减少很多的工作量，比如：检查每个 JS 文件语法、合并两个 JS 文件、将合并后的 JS 文件压缩、将 SCSS 文件编译等，包括我们上面提到的试用 gulp 将.less 文件转换为.css 文件，grunt 也是可以实现的，下面我们用 grunt 实现 gulp 的转换 less 的功能：<br>和 gulp 一样，首先我们先安装 grunt 以及 grunt-contrib-less<br><code>npm install grunt --save-dev</code><br><code>npm install grunt-contrib-less --save-dev</code></p><blockquote><p>新建 Gruntfile.js 文件</p></blockquote><p>使用 grunt，主要有三块代码：任务配置代码、插件加载代码、任务注册代码。<br>任务配置代码就是调用插件配置一下要执行的任务和实现的功能，插件加载代码就是把需要用到的插件加载进来，任务注册代码就是注册一个 task，里面包含刚在前面编写的任务配置代码。<br>需要注意的是，grunt 的配置代码放到</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">module.<span class="hljs-keyword">exports</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(grunt)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    ...</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span>;</span><br></code></pre></td></tr></table></figure><p>里面，没有为什么…</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 任务配置代码<br>grunt.initConfig(&#123;<br>    pkg: grunt.file.readJSON(<span class="hljs-string">&#x27;package.json&#x27;</span>),<br>    <span class="hljs-regexp">//</span>less插件配置<br>    less: &#123;<br>        main: &#123;<br>        options: &#123;<br>            compress: false,<br>            yuicompress: false<br>        &#125;,<br>        files: &#123;<br>            <span class="hljs-string">&#x27;./public/css/global.css&#x27;</span>: <span class="hljs-string">&#x27;./public/less/*.less&#x27;</span><br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;);<br><span class="hljs-regexp">//</span> pkg 功能是读取 package.json 文件，并把里面的信息获取出来，方便在后面任务中应用<br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 插件加载代码<br>grunt.loadNpmTasks(<span class="hljs-string">&#x27;grunt-contrib-less&#x27;</span>);<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 任务注册代码<br>grunt.registerTask(<span class="hljs-string">&#x27;lessjs&#x27;</span>, [<span class="hljs-string">&#x27;less&#x27;</span>]);<br></code></pre></td></tr></table></figure><p>到这一步，我们已经做好 grunt 配置文件了,控制台输入<code>grunt lessjs</code>即可实现同 gulp 一样的效果。<br>同样的，这一样使我们手动生成的，grunt 能像 gulp 一样自动为我们生成吗？答案是肯定的，grunt 同样也有 watch。<br>首先安装插件 grunt-contrib-watch<br><code>npm install grunt-contrib-watch --save-dev</code><br>在任务配置代码添加一个 watch 任务：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">watch: &#123;<br>    lesse<span class="hljs-variable">s:</span> &#123;<br>            <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> [<span class="hljs-string">&#x27;./public/less/*.less&#x27;</span>],<br>        task<span class="hljs-variable">s:</span> [<span class="hljs-string">&#x27;less&#x27;</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样需要加载插件代码，任务注册代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">grunt.load<span class="hljs-constructor">NpmTasks(&#x27;<span class="hljs-params">grunt</span>-<span class="hljs-params">contrib</span>-<span class="hljs-params">watch</span>&#x27;)</span>;<br>grunt.register<span class="hljs-constructor">Task(&#x27;<span class="hljs-params">default</span>&#x27;, [&#x27;<span class="hljs-params">less</span>&#x27;, &#x27;<span class="hljs-params">watch</span>&#x27;])</span>;<br></code></pre></td></tr></table></figure><h3 id="3-grunt-与-gulp-区别"><a href="#3-grunt-与-gulp-区别" class="headerlink" title="3. grunt 与 gulp 区别"></a>3. grunt 与 gulp 区别</h3><p>上面的学习，我们知道 grunt 和 gulp 能实现同样的功能，那么它们有什么区别？分别在什么场景下使用呢？<br>在我看来，其实 grunt 和 gulp 两个东西的功能是一样的，只不过是任务配置 JS 的语法不同，Gulp 配置文件的写法更加通俗易懂，上手更快。但是 Gulp 的插件感觉不如 Grunt，只能满足基本的工作需要；而 Grunt 官方提供了一些常见的插件，满足大部分日常工作，而且可靠值得信赖，而 Gulp 好像没有太多官方出品，各种插件不太规范。<br>至于在什么场景下使用哪个？这个看个人需要吧，grunt 远远不止上面写的那么简单，如果 gulp 能满足平时工作需要，可以使用 gulp。<br>总之，用网友的话说，Grunt 和 Gulp 就像 iPhone 与 Android 一样，一个质量高学习难一点，一个学起来简单但是有点那个，你懂得。</p><h3 id="什么是-gulp？"><a href="#什么是-gulp？" class="headerlink" title="什么是 gulp？"></a>什么是 gulp？</h3><p>gulp 文档上面有这么一句话<img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600531191139-913aa216-5842-48df-ab75-64f2d5097fea.svg#align=left&display=inline&height=27&margin=%5Bobject%20Object%5D&originHeight=27&originWidth=295&size=0&status=done&style=none&width=295"> ，也就是说 gulp 是一个自动化构建工具； gulp 的一些功能如下(包括但不限于):<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191355-be39dfb5-f574-405a-8835-609421bbc22d.webp#align=left&display=inline&height=674&margin=%5Bobject%20Object%5D&originHeight=674&originWidth=1222&size=0&status=done&style=none&width=1222"></p><h3 id="gulp-或-grunt-和-webpack-的区别"><a href="#gulp-或-grunt-和-webpack-的区别" class="headerlink" title="gulp 或 grunt 和 webpack 的区别"></a>gulp 或 grunt 和 webpack 的区别</h3><p>其实 Webpack 和另外两个并没有太多的可比性</p><ul><li><p>Gulp/Grunt 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案，不过 Webpack 的优点使得 Webpack 在很多场景下可以替代 Gulp/Grunt 类的工具。</p></li><li><p>Grunt 和 Gulp 的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191530-f10be477-6b85-4a4c-a735-4d3b39b67642.webp#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1240&size=0&status=done&style=none&width=1240"></p></li><li><p>Webpack 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的 JavaScript 文件。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191093-7fe5c467-a3b4-4de4-a36a-fe977e9a500c.webp#align=left&display=inline&height=536&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=1240&size=0&status=done&style=none&width=1240"><strong>上述内容转自@zhangwang 的<a href="https://www.jianshu.com/p/42e11515c10f">入门 Webpack，看这篇就够了</a></strong></p></li></ul><h3 id="gulp-起步"><a href="#gulp-起步" class="headerlink" title="gulp 起步"></a>gulp 起步</h3><p>傻瓜式起步照搬官网文档 1.安装</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 全局安装</span><br><span class="hljs-symbol">$</span> npm install -g gulp<br>或者<br><span class="hljs-symbol">$</span> npm install --global gulp<br><span class="hljs-comment">// 作为项目的开发依赖（devDependencies）安装：</span><br><span class="hljs-symbol">$</span> npm install --save-dev gulp<br>复制代码<br></code></pre></td></tr></table></figure><p>2.在项目根目录下创建一个名为 gulpfile.js 的文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br>gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将你的默认的任务代码放在这</span><br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>3.运行 gulp：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gulp<br>复制代码<br></code></pre></td></tr></table></figure><p>默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 具体详情可以查看<a href="https://www.gulpjs.com.cn/docs/">gulpjs.com 文档</a></p><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>新建一个项目 gulp-test 环境:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ node -v <span class="hljs-regexp">//</span> v9.<span class="hljs-number">1.0</span><br>$ npm -v <span class="hljs-regexp">//</span> <span class="hljs-number">6.5</span>.<span class="hljs-number">0</span><br>复制代码<br></code></pre></td></tr></table></figure><p>1.新建文件以下文件如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gulp-test/<br>          css/<br>               index<span class="hljs-selector-class">.scss</span><br>           js/<br>               helloworld<span class="hljs-selector-class">.js</span><br>           index<span class="hljs-selector-class">.html</span><br>           gulpfile<span class="hljs-selector-class">.js</span><br>复制代码<br></code></pre></td></tr></table></figure><p>其中 <strong>gulpfile.js</strong> 是我们 gulp 的配置文件，启动 gulp 默认会找个这个文件并执行； 2.接下来安装依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> init<br>复制代码<br></code></pre></td></tr></table></figure><p>一直按回车 Enter 初始化 package.json 文件(小技巧: <strong>npm iniy -y</strong> 可以免去繁琐的 enter 步骤) 此时我们的目录结构是这样了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gulp-test/<br>          css/<br>               index<span class="hljs-selector-class">.scss</span><br>           js/<br>               helloworld<span class="hljs-selector-class">.js</span><br>           index<span class="hljs-selector-class">.html</span><br>           gulpfile<span class="hljs-selector-class">.js</span><br>           package<span class="hljs-selector-class">.json</span><br>复制代码<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs q">npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp        <span class="hljs-comment">// gulp自动化构建工具</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-uglify <span class="hljs-comment">//js压缩</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-concat <span class="hljs-comment">//文件合并</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-jshint <span class="hljs-comment">//js语法检测</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-rename <span class="hljs-comment">//文件重命名</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-sass <span class="hljs-comment">//sass编译工具</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-minify-css <span class="hljs-comment">//css压缩</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> del       <span class="hljs-comment">//文件删除</span><br><span class="hljs-comment">// 以下三选一</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-connect       <span class="hljs-comment">// 自动刷新页面</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span>  browser-sync       <span class="hljs-comment">// 自动刷新页面</span><br>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> gulp-livereload       <span class="hljs-comment">// 自动刷新页面</span><br>复制代码<br></code></pre></td></tr></table></figure><p>这里页面实时刷新只讲这个<strong>gulp-connect</strong> ，其他详情可以参照<a href="http://www.browsersync.cn/docs/gulp/">Browsersync</a>和文章<a href="http://www.ydcss.com/archives/702">gulp-livereload</a><br>安装完依赖后配置 gulpfile.js 如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定义依赖项和插件<br>const gulp=require(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br>const  uglify=require(<span class="hljs-string">&#x27;gulp-uglify&#x27;</span>); <span class="hljs-regexp">//</span>js压缩<br>const  concat=require(<span class="hljs-string">&#x27;gulp-concat&#x27;</span>); <span class="hljs-regexp">//</span>文件合并<br>const jshint = require(<span class="hljs-string">&#x27;gulp-jshint&#x27;</span>); <span class="hljs-regexp">//</span>js语法检测<br>const rename = require(<span class="hljs-string">&#x27;gulp-rename&#x27;</span>); <span class="hljs-regexp">//</span> 重命名<br>const sass = require(<span class="hljs-string">&#x27;gulp-sass&#x27;</span>); <span class="hljs-regexp">//</span> 编译scss<br>const  minifycss = require(<span class="hljs-string">&#x27;gulp-minify-css&#x27;</span>); <span class="hljs-regexp">//</span> 压缩css<br><span class="hljs-regexp">//</span> const livereload = require(<span class="hljs-string">&#x27;gulp-livereload&#x27;</span>); <span class="hljs-regexp">//</span> 自动刷新页面<br>const  del = require(<span class="hljs-string">&#x27;del&#x27;</span>); <span class="hljs-regexp">//</span>文件删除<br>const connect = require(<span class="hljs-string">&#x27;gulp-connect&#x27;</span>); <span class="hljs-regexp">//</span> 自动刷新页面<br>gulp.task(<span class="hljs-string">&#x27;server&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  connect.server(&#123;<br>    port: <span class="hljs-number">8080</span>, <span class="hljs-regexp">//</span>指定端口号，在浏览器中输入localhost:<span class="hljs-number">8080</span>就可以直接访问生成的html页面<br>    root: <span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-regexp">//</span>指定html文件起始的根目录<br>    livereload: true <span class="hljs-regexp">//</span>启动实时刷新功能（配合上边的connect.reload()方法同步使用）<br>  &#125;);<br>&#125;);<br><span class="hljs-regexp">//</span> 定义名为 <span class="hljs-string">&quot;my-task&quot;</span> 的任务压缩js<br>gulp.task(<span class="hljs-string">&#x27;my-task-js&#x27;</span>, <span class="hljs-keyword">function</span>()&#123;<br>  gulp.src(<span class="hljs-string">&#x27;./js/*.js&#x27;</span>)<br>    .pipe(jshint())<br>    .pipe(uglify())<br>    .pipe(concat(<span class="hljs-string">&#x27;all.js&#x27;</span>))<br>    .pipe(rename(&#123;suffix: <span class="hljs-string">&#x27;.min&#x27;</span>&#125;))<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/js&#x27;</span>))<br>    .pipe(connect.reload())<br>&#125;);<br><span class="hljs-regexp">//</span> 定义名为 <span class="hljs-string">&quot;my-task-css&quot;</span> 的任务编译scss压缩css<br>gulp.task(<span class="hljs-string">&#x27;my-task-css&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  gulp.src(<span class="hljs-string">&#x27;./css/*.scss&#x27;</span>)<br>    .pipe(sass().on(<span class="hljs-string">&#x27;error&#x27;</span>, sass.logError))<br>    .pipe(concat(<span class="hljs-string">&#x27;all.css&#x27;</span>))<br>    .pipe(rename(&#123;suffix: <span class="hljs-string">&#x27;.min&#x27;</span>&#125;))<br>    .pipe(minifycss())<br>    .pipe(connect.reload())<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/css&#x27;</span>))<br>&#125;);<br>gulp.task(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-keyword">function</span>()&#123;<br>  gulp.src(<span class="hljs-string">&#x27;*.html&#x27;</span>)<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;dist/html&#x27;</span>))<br>    .pipe(connect.reload())<br>&#125;)<br><span class="hljs-regexp">//</span>执行压缩前，先删除以前压缩的文件<br>gulp.task(<span class="hljs-string">&#x27;clean&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  return del([<span class="hljs-string">&#x27;./dist/css/all.css&#x27;</span>, <span class="hljs-string">&#x27;./dist/css/all.min.css&#x27;</span>, <span class="hljs-string">&#x27;./dist/all.js&#x27;</span>,<span class="hljs-string">&#x27;./dist/all.min.js&#x27;</span>, <span class="hljs-string">&#x27;./dist/html&#x27;</span>])<br>&#125;);<br><span class="hljs-regexp">//</span> 定义默认任务<br>gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>,[<span class="hljs-string">&#x27;clean&#x27;</span>],<span class="hljs-keyword">function</span>() &#123;<br>  gulp.start(<span class="hljs-string">&#x27;my-task-js&#x27;</span>, <span class="hljs-string">&#x27;my-task-css&#x27;</span>, <span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-string">&#x27;server&#x27;</span> );<br>&#125;);<br><span class="hljs-regexp">//</span> 任务监听<br>gulp.task(<span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  <span class="hljs-regexp">//</span> Watch.js files<br>  gulp.watch(<span class="hljs-string">&#x27;./js/*.js&#x27;</span>, [<span class="hljs-string">&#x27;my-task-js&#x27;</span>]);<br>  <span class="hljs-regexp">//</span> Watch .scss files<br>  gulp.watch(<span class="hljs-string">&#x27;./css/*.scss&#x27;</span>, [<span class="hljs-string">&#x27;my-task-css&#x27;</span>]);<br>  <span class="hljs-regexp">//</span> Watch .html files<br>  gulp.watch(<span class="hljs-string">&#x27;./*.html&#x27;</span>, [<span class="hljs-string">&#x27;html&#x27;</span>]);<br>  <span class="hljs-regexp">//</span> Watch any files <span class="hljs-keyword">in</span> dist/, reload on change<br>  <span class="hljs-regexp">//</span> gulp.watch([<span class="hljs-string">&#x27;dist/!**&#x27;</span>]).on(<span class="hljs-string">&#x27;change&#x27;</span>, livereload.changed);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>大概讲解一下 gulpfile.js:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ...<br><span class="hljs-regexp">//</span> 定义名为 <span class="hljs-string">&quot;my-task&quot;</span> 的任务压缩js<br>gulp.task(<span class="hljs-string">&#x27;my-task-js&#x27;</span>, <span class="hljs-keyword">function</span>()&#123;<br>  gulp.src(<span class="hljs-string">&#x27;./js/*.js&#x27;</span>)<br>    .pipe(jshint()) <span class="hljs-regexp">//</span>js检测<br>    .pipe(uglify()) <span class="hljs-regexp">//</span>js压缩<br>    .pipe(concat(<span class="hljs-string">&#x27;all.js&#x27;</span>)) <span class="hljs-regexp">//</span>合并为all.js<br>    .pipe(rename(&#123;suffix: <span class="hljs-string">&#x27;.min&#x27;</span>&#125;)) <span class="hljs-regexp">//</span> 重命名为all.mim.js<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/js&#x27;</span>)) <span class="hljs-regexp">//</span>输出到<span class="hljs-regexp">/dist/</span>js目录<br>    .pipe(connect.reload()) <span class="hljs-regexp">//</span> 更新页面<br>&#125;);<br><span class="hljs-regexp">//</span> ...<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>gulp.task</strong>是 gulp 的 api 定义一个使用 <a href="https://github.com/robrich/orchestrator">Orchestrator</a> 实现的任务（task） 如上我们定义了<strong>my-task-js</strong>，<strong>my-task-css</strong>，<strong>html</strong>，<strong>clean</strong>，<strong>default</strong>，<strong>watch</strong>，<strong>server</strong>等任务，其中:</p><ul><li><p><strong>my-task-js</strong> 是将 符合所提供的匹配模式的 js 进行检测(gulp-jshint)、压缩(gulp-uglify)、合并(gulp-concat)、重命名(gulp-rename)、输出(gulp.dest)到/dist/js 目录下；</p></li><li><p><strong>my-task-css</strong> 是将 符合所提供的匹配模式的 sass 进行编译(gulp-sass)、压缩(gulp-uglify)、合并(gulp-concat)、重命名(gulp-rename)、输出(gulp.dest)到/dist/css 目录下；</p></li><li><p><strong>html</strong> 是将 符合所提供的匹配模式的 html 进行监听，如果有变化则 connect.reload()</p></li><li><p><strong>clean</strong> 是如果任务重新启动时 删除旧文件；</p></li><li><p><strong>default</strong> gulp 默认启动的任务</p></li><li><p><strong>watch</strong> gulp 的 api 监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。</p></li><li><p><strong>server</strong> 依赖 gulp-connect 启动一个服务器</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">gulp.task(<span class="hljs-string">&#x27;server&#x27;</span>, <span class="hljs-keyword">function</span>() &#123;<br>  connect.server(&#123;<br>    port: <span class="hljs-number">8080</span>, <span class="hljs-regexp">//</span>指定端口号，在浏览器中输入localhost:<span class="hljs-number">8080</span>就可以直接访问生成的html页面<br>    root: <span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-regexp">//</span>指定html文件起始的根目录<br>    livereload: true <span class="hljs-regexp">//</span>启动实时刷新功能（配合上边的connect.reload()方法同步使用）<br>  &#125;);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>配置完 gulpfile.js 之后，我们给 js 和 css 及 html 加点东西:<br>首先 js/helloworld.js</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// helloworld.js</span><br>console.<span class="hljs-built_in">log</span>(&#x27;hello world&#x27;)<br>复制代码<br></code></pre></td></tr></table></figure><p>css/index.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// index.scss</span><br><span class="hljs-comment">// 变量测试</span><br><span class="hljs-variable">$fontColor</span>:  #red;<br><span class="hljs-variable">$backColor</span>: aqua;<br><span class="hljs-comment">// 嵌套类测试</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$fontColor</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-variable">$backColor</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>gulp-study<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">/dist/css/all.min.css</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">stylesheet</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;firstDiv&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是gulp<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/dist/js/all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>运行 gulp</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gulp<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191399-7a26b8b5-e2cc-4eb9-b167-70b8f56eef32.webp#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=1240&size=0&status=done&style=none&width=1240"></p><hr><p>浏览器效果:<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191104-4d0dd021-4a20-497d-b2c7-949ec439b422.webp#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=880&size=0&status=done&style=none&width=880"><br>接下来我们修改 helloworld.js 来看看是否能实时刷新 修改如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// helloworld.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-keyword">let</span> firstDiv =  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;firstDiv&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(firstDiv)<br>复制代码<br></code></pre></td></tr></table></figure><p>按保存之后，终端给我们报了一个错:<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191192-3cceec5a-b26f-4d26-9d61-496838275cd0.webp#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=1240&size=0&status=done&style=none&width=1240"><br>查看 js 发现我们用了 es6 语法的声明语句<img src="https://cdn.nlark.com/yuque/0/2020/svg/1639155/1600531191234-4f7dd82c-3f7b-4b97-b53e-3139ec54839d.svg#align=left&display=inline&height=17&margin=%5Bobject%20Object%5D&originHeight=17&originWidth=21&size=0&status=done&style=none&width=21"> 但当前 gulp 无法处理 es6 语法，有问题解决问题，es6=&gt;es5<br>解决方案: 安装 gulp-babel babel-core babel-preset-es2015</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm i  --save-dev  gulp-<span class="hljs-keyword">babel </span><span class="hljs-keyword">babel-core </span><span class="hljs-keyword">babel-preset-es2015</span><br><span class="hljs-keyword"></span>复制代码<br></code></pre></td></tr></table></figure><p>gulpfile.js 修改如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ...<br>const babel = require(<span class="hljs-string">&#x27;gulp-babel&#x27;</span>);<br><span class="hljs-regexp">//</span> ...<br><span class="hljs-regexp">//</span> 定义名为 <span class="hljs-string">&quot;my-task&quot;</span> 的任务压缩js<br>gulp.task(<span class="hljs-string">&#x27;my-task-js&#x27;</span>, <span class="hljs-keyword">function</span>()&#123;<br>  gulp.src(<span class="hljs-string">&#x27;./js/*.js&#x27;</span>)<br>    .pipe(babel())<br>    .pipe(jshint())<br>    .pipe(uglify())<br>    .pipe(concat(<span class="hljs-string">&#x27;all.js&#x27;</span>))<br>    .pipe(rename(&#123;suffix: <span class="hljs-string">&#x27;.min&#x27;</span>&#125;))<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/js&#x27;</span>))<br>    .pipe(connect.reload())<br>&#125;);<br><span class="hljs-regexp">//</span> ...<br>复制代码<br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gulp<br>复制代码<br></code></pre></td></tr></table></figure><p>依然报上面的错；找了一些原因发现，虽然安装了相关依赖，却没有配置.babelrc 文件，即 babel 还没转化 es6<br>根目录添加.babelrc 文件</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br><span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;es2015&quot;</span>]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>重新运行:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gulp<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191286-3fe41a9b-e7b7-4919-b501-d71c5cd9ef78.webp#align=left&display=inline&height=618&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=828&size=0&status=done&style=none&width=828"><br>查看 dist 下的 js 文件<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191139-d4e53a7c-014a-4e83-a388-3b37298f7251.webp#align=left&display=inline&height=284&margin=%5Bobject%20Object%5D&originHeight=284&originWidth=1240&size=0&status=done&style=none&width=1240"><br>改变 helloworld.js 检查页面是否刷新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// helloworld.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-keyword">let</span> firstDiv =  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;firstDiv&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(firstDiv)<br>firstDiv.style.backgroundColor = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>保存，页面的天空蓝换成你们喜欢的 yellow 颜色<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191357-ecf28fa9-1e15-4c16-8117-3a1b02bec657.webp#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=1210&size=0&status=done&style=none&width=1210"><br>修改 index.scss 查看是否会刷新页面</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// index.scss</span><br><span class="hljs-comment">// 变量测试</span><br><span class="hljs-variable">$fontColor</span>:  #red;<br><span class="hljs-variable">$backColor</span>: aqua;<br><span class="hljs-comment">// 嵌套类测试</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$fontColor</span>;<br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-variable">$backColor</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191139-d14bf071-f015-4945-ae0b-492ed0891cdc.webp#align=left&display=inline&height=585&margin=%5Bobject%20Object%5D&originHeight=585&originWidth=1165&size=0&status=done&style=none&width=1165"><br>最后修改 index.html 查看是否会刷新页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>gulp-study<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">/dist/css/all.min.css</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">stylesheet</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;firstDiv&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是gulp<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是真的皮<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/dist/js/all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600531191361-7b8b0383-f60d-41dd-9c34-86222c390bac.webp#align=left&display=inline&height=865&margin=%5Bobject%20Object%5D&originHeight=865&originWidth=1096&size=0&status=done&style=none&width=1096"></p><h1 id="Webpack-与-Grunt、Gulp-的区别？"><a href="#Webpack-与-Grunt、Gulp-的区别？" class="headerlink" title="Webpack 与 Grunt、Gulp 的区别？"></a><a href="https://segmentfault.com/a/1190000019650765">Webpack 与 Grunt、Gulp 的区别？</a></h1><p>随着前端发展如日冲天，前端项目也越来越复杂，得益于 Nodejs 的发展，前端模块化、组件化、工程化也大势所趋。这些年 Grunt、Gulp 到 Webpack 随着工程化的发展都大行其道。<br><strong>前端工程化的早期</strong>，主要是解决重复任务的问题。Grunt、Gulp 就是其中代表。比如: 压缩、编译 less、sass、地址添加 hash、替换等。<br>Grunt 官网中就说：<br>对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting 等，完成大部分无聊的工作。<br>而如今的 Webpack 更像<strong>一套前端工程化解决方案</strong>。利用强大插件机制，解决前端静态资源依赖管理的问题。</p><h3 id="Webpack-作者-Tobias-回复与-Grunt-Gulp-NPM-脚本的比较"><a href="#Webpack-作者-Tobias-回复与-Grunt-Gulp-NPM-脚本的比较" class="headerlink" title="Webpack 作者 Tobias 回复与 Grunt Gulp NPM 脚本的比较"></a>Webpack 作者 Tobias 回复与 Grunt Gulp NPM 脚本的比较</h3><p><strong>Tobias：</strong> NPM 脚本对我而言足矣。实际上，说 webpack 是 Grunt/Gulp 的替代器并不完全准确。Grunt 和 Gulp 以及 NPM 脚本都是<strong><em>任务执行程序</em></strong>。<br>Webpack 是**<em>模块打包程序**</em>。这两类程序的目标不一样。但 webpack 简化了必须“过度使用”Grunt 和 Gulp 和 NPM 脚本才能实现的 Web 开发任务也是事实。NPM 脚本才是 Grunt 和 Gulp 的替代品。<br>不过，除了纯粹的构建之外，任务运行程序也有存在的理由，比如部署、代码检查、版本管理，等等。</p><h3 id="Webpack-与-Grunt、Gulp-运行机制"><a href="#Webpack-与-Grunt、Gulp-运行机制" class="headerlink" title="Webpack 与 Grunt、Gulp 运行机制"></a>Webpack 与 Grunt、Gulp 运行机制</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># grunt gulp 思路<br>【遍历源文件】-&gt;【匹配规则】-&gt;【打包】<br>做不到按需加载，对打包的资源，是否用到，打包过程不关心。<br># webpack<br>【入口】-&gt;【模块依赖加载】-&gt;【依赖分析】-&gt;【打包】<br>在加载、分析、打包的过程中，可以针对性的做一些解决方案。比如：<span class="hljs-keyword">code</span> split(拆分公共代码)<br></code></pre></td></tr></table></figure><h3 id="Grunt-与-Gulp-性能比较"><a href="#Grunt-与-Gulp-性能比较" class="headerlink" title="Grunt 与 Gulp 性能比较"></a>Grunt 与 Gulp 性能比较</h3><p><strong>Grunt:</strong> 每个任务处理完成后存放在本地磁盘.tmp 目录中，有本地磁盘的 I/O 操作，会导致打包速度比较慢。<br>**Gulp: **gulp 与 grunt 都是按任务执行，gulp 有一个文件流的概念。每一步构建的结果并不会存在本地磁盘，而是保存在内存中，下一个步骤是可以使用上一个步骤的内存，大大增加了打包的速度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack loader和plugin编写</title>
    <link href="/2020/09/19/yuque/webpack%20loader%E5%92%8Cplugin%E7%BC%96%E5%86%99/"/>
    <url>/2020/09/19/yuque/webpack%20loader%E5%92%8Cplugin%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.jianshu.com/p/0fc6bb85ef5b">https://www.jianshu.com/p/0fc6bb85ef5b</a>、<a href="https://juejin.im/post/6844903689442820110">https://juejin.im/post/6844903689442820110</a></p><h1 id="webpack-中-loader-和-plugin-的区别"><a href="#webpack-中-loader-和-plugin-的区别" class="headerlink" title="webpack 中 loader 和 plugin 的区别"></a>webpack 中 loader 和 plugin 的区别</h1><h2 id="一、webpack-的常见配置"><a href="#一、webpack-的常见配置" class="headerlink" title="一、webpack 的常见配置"></a>一、webpack 的常见配置</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs dts">const webpack = require(<span class="hljs-string">&quot;webpack&quot;</span>);<br>const path = require(<span class="hljs-string">&quot;path&quot;</span>);<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br>module.exports = &#123;<br>    <span class="hljs-comment">// 入口文件</span><br><span class="hljs-symbol">    entry:</span> &#123;<br><span class="hljs-symbol">        app:</span> path.join(__dirname, <span class="hljs-string">&quot;../src/js/index.js&quot;</span>)<br>    &#125;,<br>    <span class="hljs-comment">// 输出文件</span><br><span class="hljs-symbol">    output:</span> &#123;<br><span class="hljs-symbol">        filename:</span> <span class="hljs-string">&quot;[name].bundle.js&quot;</span>,<br><span class="hljs-symbol">        path:</span> path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br><span class="hljs-symbol">        publicPath:</span> <span class="hljs-string">&quot;/&quot;</span><br>    &#125;,<br>    <span class="hljs-comment">// loader配置</span><br><span class="hljs-symbol">    module:</span> &#123;<br><span class="hljs-symbol">        rules:</span> [<br>            &#123;<br><span class="hljs-symbol">                test:</span> /\.scss/,<br><span class="hljs-symbol">                use:</span> [<br>                    <span class="hljs-string">&quot;style-loader&quot;</span>,<br>                    <span class="hljs-string">&quot;css-loader&quot;</span><br>                ]<br>            &#125;<br>            ......<br>        ]<br>    &#125;,<br>    <span class="hljs-comment">// plugins配置</span><br><span class="hljs-symbol">    plugins:</span> [<br>        <span class="hljs-comment">// 重新创建html文件</span><br>        new HtmlWebpackPlugin(&#123;<br><span class="hljs-symbol">            title:</span> <span class="hljs-string">&quot;首页&quot;</span>,<br><span class="hljs-symbol">            filename:</span> <span class="hljs-string">&quot;index.html&quot;</span>,<br><span class="hljs-symbol">            template:</span> path.resolve(__dirname, <span class="hljs-string">&quot;../src/index.html&quot;</span>)<br>        &#125;)<br>        ......<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、webpack-的打包原理"><a href="#二、webpack-的打包原理" class="headerlink" title="二、webpack 的打包原理"></a>二、webpack 的打包原理</h2><ol><li>识别入口文件</li><li>通过逐层识别模块依赖(Commonjs、amd 或者 es6 的 import，webpack 都会对其进行分析，来获取代码的依赖)</li><li>webpack 做的就是分析代码，转换代码，编译代码，输出代码</li><li>最终形成打包后的代码</li></ol><h2 id="三、什么是-loader"><a href="#三、什么是-loader" class="headerlink" title="三、什么是 loader"></a>三、什么是 loader</h2><p>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p><ol><li>处理一个文件可以使用多个 loader，loader 的执行顺序和配置中的顺序是相反的，即最后一个 loader 最先执行，第一个 loader 最后执行</li><li>第一个执行的 loader 接收源文件内容作为参数，其它 loader 接收前一个执行的 loader 的返回值作为参数，最后执行的 loader 会返回此模块的 JavaScript 源码</li></ol><h2 id="四、什么是-plugin"><a href="#四、什么是-plugin" class="headerlink" title="四、什么是 plugin"></a>四、什么是 plugin</h2><p>在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;MyPlugin constructor:&quot;</span>, options);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">compiler</span>)</span>&#123;<br>        compiler.plugin(<span class="hljs-string">&quot;compilation&quot;</span>, <span class="hljs-function"><span class="hljs-params">compilation</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;MyPlugin&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = MyPlugin;<br><br><br>webpack.config.js配置：<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> MyPlugin(&#123;<span class="hljs-attr">param</span>: <span class="hljs-string">&quot;my plugin&quot;</span>&#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>使用该 plugin 后，执行的顺序：</p><ol><li>webpack 启动后，在读取配置的过程中会执行 new MyPlugin(options)初始化一个 MyPlugin 获取其实例</li><li>在初始化 compiler 对象后，就会通过 compiler.plugin(事件名称，回调函数)监听到 webpack 广播出来的事件</li><li>并且可以通过 compiler 对象去操作 webpack</li></ol><h2 id="五、loader-和-plugin-的区别"><a href="#五、loader-和-plugin-的区别" class="headerlink" title="五、loader 和 plugin 的区别"></a>五、loader 和 plugin 的区别</h2><p>对于 loader，它是一个转换器，将 A 文件进行编译形成 B 文件，这里操作的是文件，比如将 A.scss 转换为 A.css，单纯的文件转换过程<br>plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务</p><h1 id="webpack-loader-和-plugin-编写"><a href="#webpack-loader-和-plugin-编写" class="headerlink" title="webpack loader 和 plugin 编写"></a>webpack loader 和 plugin 编写</h1><h2 id="1-基础回顾"><a href="#1-基础回顾" class="headerlink" title="1 基础回顾"></a>1 基础回顾</h2><p>首先我们先回顾一下 webpack 常见配置，因为后面会用到，所以简单介绍一下。</p><h3 id="1-1-webpack-常见配置"><a href="#1-1-webpack-常见配置" class="headerlink" title="1.1 webpack 常见配置"></a>1.1 webpack 常见配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/js/index.js&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 输出文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>     <span class="hljs-comment">//确保文件资源能够在 http://localhost:3000 下正确访问</span><br>  &#125;,<br>  <span class="hljs-comment">// 开发者工具 source-map</span><br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;inline-source-map&#x27;</span>,<br>  <span class="hljs-comment">// 创建开发者服务器</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>                <span class="hljs-comment">// 热更新</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 删除dist目录</span><br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin([<span class="hljs-string">&#x27;dist&#x27;</span>]),<br>    <span class="hljs-comment">// 重新穿件html文件</span><br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Output Management&#x27;</span><br>    &#125;),<br>    <span class="hljs-comment">// 以便更容易查看要修补(patch)的依赖</span><br>    <span class="hljs-keyword">new</span> webpack.NamedModulesPlugin(),<br>    <span class="hljs-comment">// 热更新模块</span><br>    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()<br>  ],<br>  <span class="hljs-comment">// 环境</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-comment">// loader配置</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span><br>        ]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;file-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这里面我们重点关注 module 和 plugins 属性，因为今天的重点是编写 loader 和 plugin，需要配置这两个属性。</p><h3 id="1-2-打包原理"><a href="#1-2-打包原理" class="headerlink" title="1.2 打包原理"></a>1.2 打包原理</h3><ul><li>识别入口文件</li><li>通过逐层识别模块依赖。（Commonjs、amd 或者 es6 的 import，webpack 都会对其进行分析。来获取代码的依赖）</li><li>webpack 做的就是分析代码。转换代码，编译代码，输出代码</li><li>最终形成打包后的代码</li></ul><p>这些都是 webpack 的一些基础知识，对于理解 webpack 的工作机制很有帮助。</p><h2 id="2-loader"><a href="#2-loader" class="headerlink" title="2 loader"></a>2 loader</h2><p>OK 今天第一个主角登场</p><h3 id="2-1-什么是-loader？"><a href="#2-1-什么是-loader？" class="headerlink" title="2.1 什么是 loader？"></a>2.1 什么是 loader？</h3><p>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p><ul><li>处理一个文件可以使用多个 loader，loader 的执行顺序是和本身的顺序是相反的，即最后一个 loader 最先执行，第一个 loader 最后执行。</li><li>第一个执行的 loader 接收源文件内容作为参数，其他 loader 接收前一个执行的 loader 的返回值作为参数。最后执行的 loader 会返回此模块的 JavaScript 源码</li></ul><h3 id="2-2-手写一个-loader"><a href="#2-2-手写一个-loader" class="headerlink" title="2.2 手写一个 loader"></a>2.2 手写一个 loader</h3><p>需求：</p><ol><li>处理.txt 文件</li><li>对字符串做反转操作</li><li>首字母大写<blockquote><p>例如：abcdefg 转换后为 Gfedcba</p></blockquote></li></ol><p>OK，我们开始<br>1）首先创建两个 loader（这里以本地 loader 为例）</p><blockquote><p>为什么要创建两个 laoder？理由后面会介绍</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524708867-33123dac-e8ab-4dab-8d46-a5e124965d21.webp#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=200&size=0&status=done&style=none&width=200"><br>reverse-loader.js</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(src)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (src) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;--- reverse-loader input:&#x27;</span>, src)<br>    src = src.split(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;--- reverse-loader output:&#x27;</span>, src)<br>  &#125;<br>  <span class="hljs-keyword">return</span> src;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>uppercase-loader.js</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = <span class="hljs-keyword">function</span> (src) &#123;<br>  <span class="hljs-keyword">if</span> (src) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--- uppercase-loader input:&#x27;</span>, src)<br>    src = src.charAt(<span class="hljs-number">0</span>).toUpperCase() + src.slice(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--- uppercase-loader output:&#x27;</span>, src)<br>  &#125;<br>  <span class="hljs-regexp">// 这里为什么要这么写？因为直接返回转换后的字符串会报语法错误，</span><br><span class="hljs-regexp">  //</span> 这么写<span class="hljs-keyword">import</span>后转换成可以使用的字符串<br>  <span class="hljs-keyword">return</span> `<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = <span class="hljs-string">&#x27;$&#123;src&#125;&#x27;</span>`<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>看，loader 结构是不是很简单，接收一个参数，并且 return 一个内容就 ok 了。<br>然后创建一个 txt 文件<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524708875-aca47fa1-01f2-4a7f-ac14-e5c439c366f0.webp#align=left&display=inline&height=420&margin=%5Bobject%20Object%5D&originHeight=420&originWidth=201&size=0&status=done&style=none&width=201"><br>2）mytest.txt</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abcdefg</span><br>复制代码<br></code></pre></td></tr></table></figure><p>3）现在开始配置 webpack</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nim">module.exports = &#123;<br>  entry: &#123;<br>    index: &#x27;./src/js/index.js&#x27;<br>  &#125;,<br>  plugins: [...],<br>  optimization: <span class="hljs-meta">&#123;...&#125;</span>,<br>  output: <span class="hljs-meta">&#123;...&#125;</span>,<br>  module: &#123;<br>    rules: [<br>      ...,<br>      &#123;<br>        test: /\.txt$/,<br>        use: [<br>          &#x27;./loader/uppercase-loader.js&#x27;,<br>          &#x27;./loader/reverse-loader.js&#x27;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这样就配置完成了<br>4）我们在入口文件中导入这个脚本</p><blockquote><p>为什么这里需要导入呢，我们不是配置了 webapck 处理所有的.txt 文件么？</p></blockquote><p>因为 webpack 会做过滤，如果不引用该文件的话，webpack 是不会对该文件进行打包处理的，那么你的 loader 也不会执行</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-keyword">import</span> txt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../txt/mytest.txt&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../css/style.css&#x27;</span><br><span class="hljs-keyword">function</span> component() &#123;<br>  <span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <span class="hljs-keyword">var</span> br = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;br&#x27;</span>);<br>  button.innerHTML = <span class="hljs-string">&#x27;Click me and look at the console!&#x27;</span>;<br>  element.innerHTML = _.join(<span class="hljs-string">&#x27;【&#x27;</span> + txt + <span class="hljs-string">&#x27;】&#x27;</span>);<br>  element.className = <span class="hljs-string">&#x27;hello&#x27;</span><br>  element.appendChild(br);<br>  element.appendChild(button);<br>  <span class="hljs-regexp">// Note that because a network request is involved, some indication</span><br><span class="hljs-regexp">  //</span> <span class="hljs-keyword">of</span> loading would need <span class="hljs-keyword">to</span> be shown <span class="hljs-keyword">in</span> a production-level site/app.<br>  button.onclick = e =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;print&quot; */</span> <span class="hljs-string">&#x27;./print&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-built_in">module</span> =&gt; &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">module</span>.<span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">print</span>();<br>  &#125;);<br>  <span class="hljs-keyword">return</span> element;<br>&#125;<br><span class="hljs-built_in">document</span>.body.appendChild(component());<br>复制代码<br></code></pre></td></tr></table></figure><p>package.json 配置</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">&#123;<br>  ...,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config webpack.prod.js&quot;</span>,<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open --config webpack.dev.js&quot;</span>,<br>    <span class="hljs-string">&quot;server&quot;</span>: <span class="hljs-string">&quot;node server.js&quot;</span><br>  &#125;,<br>  ...<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>然后执行命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> build<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524708877-a9146920-f5ab-4218-873c-a138b1c0b38c.webp#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&originHeight=314&originWidth=556&size=0&status=done&style=none&width=556"><br>这样我们的 loader 就写完了。</p><blockquote><p>现在回答为什么要写两个 loader？</p></blockquote><p>看到执行的顺序没，我们的配置的是这样的</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span>: [<br>  <span class="hljs-string">&#x27;./loader/uppercase-loader.js&#x27;</span>,<br>  <span class="hljs-string">&#x27;./loader/reverse-loader.js&#x27;</span><br>]<br>复制代码<br></code></pre></td></tr></table></figure><p>正如前文所说，<strong>处理一个文件可以使用多个 loader，loader 的执行顺序是和本身的顺序是相反的</strong><br>我们也可以自己写 loader 解析自定义模板，像 vue-loader 是非常复杂的，它内部会写大量的对.vue 文件的解析，然后会生成对应的 html、js 和 css。<br>我们这里只是讲述了一个最基础的用法，如果有更多的需要，可以查看 <a href="https://www.webpackjs.com/api/loaders/">《loader 官方文档》</a></p><h2 id="3-plugin"><a href="#3-plugin" class="headerlink" title="3 plugin"></a>3 plugin</h2><h3 id="3-1-什么是-plugin？"><a href="#3-1-什么是-plugin？" class="headerlink" title="3.1 什么是 plugin？"></a>3.1 什么是 plugin？</h3><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><blockquote><p>plugin 和 loader 的区别是什么？</p></blockquote><p>对于 loader，它就是一个转换器，将 A 文件进行编译形成 B 文件，这里操作的是文件，比如将 A.scss 或 A.less 转变为 B.css，单纯的文件转换过程<br>plugin 是一个扩展器，它丰富了 wepack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p><h3 id="3-2-一个最简的插件"><a href="#3-2-一个最简的插件" class="headerlink" title="3.2 一个最简的插件"></a>3.2 一个最简的插件</h3><p>/plugins/MyPlugin.js（本地插件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> </span>&#123;<br>  <span class="hljs-comment">// 构造方法</span><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;MyPlugin constructor:&#x27;</span>, options)<br>  &#125;<br>  <span class="hljs-comment">// 应用函数</span><br>  apply (compiler) &#123;<br>    <span class="hljs-comment">// 绑定钩子事件</span><br>    compiler.plugin(<span class="hljs-string">&#x27;compilation&#x27;</span>, <span class="hljs-function"><span class="hljs-params">compilation</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>)<br>    ))<br>  &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = MyPlugin<br>复制代码<br></code></pre></td></tr></table></figure><p>webpack 配置</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> MyPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./plugins/MyPlugin&#x27;</span>)<br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: &#123;<br>    index: <span class="hljs-string">&#x27;./src/js/index.js&#x27;</span><br>  &#125;,<br>  plugins: [<br>    ...,<br>    <span class="hljs-keyword">new</span> MyPlugin(&#123;param: <span class="hljs-string">&#x27;xxx&#x27;</span>&#125;)<br>  ],<br>  ...<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>这就是一个最简单的插件（虽然我们什么都没干）</p><ul><li><p>webpack 启动后，在读取配置的过程中会先执行 new MyPlugin(options) 初始化一个 MyPlugin 获得其实例。</p></li><li><p>在初始化 compiler 对象后，再调用 myPlugin.apply(compiler) 给插件实例传入 compiler 对象。</p></li><li><p>插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。</p></li><li><p>并且可以通过 compiler 对象去操作 webpack。</p><blockquote><p>看到这里可能会问 compiler 是啥，compilation 又是啥？</p></blockquote></li><li><p><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息</strong>，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p></li><li><p><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</p></li></ul><h4 id="Compiler-和-Compilation-的区别在于："><a href="#Compiler-和-Compilation-的区别在于：" class="headerlink" title="Compiler 和 Compilation 的区别在于："></a>Compiler 和 Compilation 的区别在于：</h4><p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p><h3 id="3-3-事件流"><a href="#3-3-事件流" class="headerlink" title="3.3 事件流"></a>3.3 事件流</h3><ul><li>webpack 通过  Tapable  来组织这条复杂的生产线。</li><li>webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</li><li>webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。</li></ul><p>绑定事件</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">compiler.plugin(<span class="hljs-string">&#x27;event-name&#x27;</span>, <span class="hljs-keyword">params</span> =&gt; &#123;<br>  <span class="hljs-params">...</span><br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>触发事件</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">compiler.<span class="hljs-built_in">apply</span>(<span class="hljs-string">&#x27;event-name&#x27;</span>,<span class="hljs-built_in">params</span>)<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="3-4-需要注意的点"><a href="#3-4-需要注意的点" class="headerlink" title="3.4 需要注意的点"></a>3.4 需要注意的点</h3><ul><li>只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。</li><li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。</li><li><strong>有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 webpack，才会进入下一处理流程</strong>。例如：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">compiler.plugin(<span class="hljs-string">&#x27;emit&#x27;</span>,<span class="hljs-keyword">function</span>(compilation, callback) &#123;<br>  ...<br><br>  <span class="hljs-regexp">//</span> 处理完毕后执行 callback 以通知 Webpack<br>  <span class="hljs-regexp">//</span> 如果不执行 callback，运行流程将会一直卡在这不往下执行<br>  callback();<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><p>关于 complier 和 compilation，webpack 定义了大量的钩子事件。开发者可以根据自己的需要在任何地方进行自定义处理。<br><a href="https://www.webpackjs.com/api/compiler-hooks/">《compiler 钩子文档》</a><br><a href="https://www.webpackjs.com/api/compilation-hooks/">《compilation 钩子文档》</a></p><h3 id="3-5-手写一个-plugin"><a href="#3-5-手写一个-plugin" class="headerlink" title="3.5 手写一个 plugin"></a>3.5 手写一个 plugin</h3><p>场景：<br>小程序 mpvue 项目，通过 webpack 编译，生成子包（我们作为分包引入到主程序中），然后考入主包当中。生成子包后，里面的公共静态资源 wxss 引用地址需要加入分包的前缀：/subPages/enjoy_given。<br>在未编写插件前，生成的资源是这样的，这个路径如果作为分包引入主包，是没法正常访问资源的。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524709227-f4e5d394-ded3-4bbc-9d18-0f60e91e151c.webp#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&originHeight=417&originWidth=629&size=0&status=done&style=none&width=629"><br>所以需求来了：<br>修改 dist/static/css/pages 目录下，所有页面的样式文件(wxss 文件)引入公共资源的路径。<br>因为所有页面的样式都会引用通用样式 vender.wxss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">那么就需要把<span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;/static/css/vendor.wxss&quot;</span>; 改为：<span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;/subPages/enjoy_given/static/css/vendor.wxss&quot;</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>OK 开始！<br>1）创建插件文件 CssPathTransfor.js<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524708880-021a2f3e-0b25-4dba-b9ca-148275cd0a89.webp#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&originHeight=586&originWidth=204&size=0&status=done&style=none&width=204"><br>CssPathTransfor.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CssPathTransfor</span> </span>&#123;<br>  apply (compiler) &#123;<br>    compiler.plugin(<span class="hljs-string">&#x27;emit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--CssPathTransfor emit&#x27;</span>)<br>      <span class="hljs-comment">// 遍历所有资源文件</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> filePathName <span class="hljs-keyword">in</span> compilation.assets) &#123;<br>        <span class="hljs-comment">// 查看对应的文件是否符合指定目录下的文件</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/static\/css\/pages/i</span>.test(filePathName)) &#123;<br>          <span class="hljs-comment">// 引入路径正则</span><br>          <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\/static\/css\/vendor\.wxss/i</span><br>          <span class="hljs-comment">// 需要替换的最终字符串</span><br>          <span class="hljs-keyword">const</span> finalStr = <span class="hljs-string">&#x27;/subPages/enjoy_given/static/css/vendor.wxss&#x27;</span><br>          <span class="hljs-comment">// 获取文件内容</span><br>          <span class="hljs-keyword">let</span> content = compilation.assets[filePathName].source() || <span class="hljs-string">&#x27;&#x27;</span><br><br>          content = content.replace(reg, finalStr)<br>          <span class="hljs-comment">// 重写指定输出模块内容</span><br>          compilation.assets[filePathName] = &#123;<br>            source () &#123;<br>              <span class="hljs-keyword">return</span> content;<br>            &#125;,<br>            size () &#123;<br>              <span class="hljs-keyword">return</span> content.length;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      callback()<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = CssPathTransfor<br>复制代码<br></code></pre></td></tr></table></figure><p>看着挺多，实际就是遍历 compilation.assets 模块。对符合要求的文件进行正则替换。<br>2）修改 webpack 配置</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> baseWebpackConfig = require(&#x27;./webpack.base.conf&#x27;)<br><span class="hljs-keyword">var</span> <span class="hljs-type">CssPathTransfor</span> = require(&#x27;../plugins/<span class="hljs-type">CssPathTransfor</span>.js&#x27;)<br><span class="hljs-keyword">var</span> webpackConfig = merge(baseWebpackConfig, &#123;<br>  module: <span class="hljs-meta">&#123;...&#125;</span>,<br>  devtool: config.build.productionSourceMap ? &#x27;<span class="hljs-comment">#source-map&#x27; : false,</span><br>  output: <span class="hljs-meta">&#123;...&#125;</span>,<br>  plugins: [<br>    ...,<br>    // 配置插件<br>    new <span class="hljs-type">CssPathTransfor</span>(),<br>  ]<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>插件编写完成后，执行编译命令<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600524708987-85c6eb19-cb5e-4b3f-8137-78752e75549b.webp#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=734&size=0&status=done&style=none&width=734"><br>搞定~<br>如果有更多的需求可以参考<a href="https://www.webpackjs.com/contribute/writing-a-plugin/">《如何写一个插件》</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存，304</title>
    <link href="/2020/09/19/yuque/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%8C304/"/>
    <url>/2020/09/19/yuque/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%8C304/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903763665240072">https://juejin.im/post/6844903763665240072</a></p><h1 id="浏览器缓存；缓存相关的字段（Etag-与-last-modified-对比区别）"><a href="#浏览器缓存；缓存相关的字段（Etag-与-last-modified-对比区别）" class="headerlink" title="浏览器缓存；缓存相关的字段（Etag 与 last-modified 对比区别）"></a>浏览器缓存；缓存相关的字段（Etag 与 last-modified 对比区别）</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><strong>浏览器缓存</strong> 是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。<br>但也不是说缓存没有缺点，如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。<br>缓存的优点：</p><ul><li>减少了冗余的数据传输，节省网费</li><li>减少服务器的负担，提升网站性能</li><li>加快了客户端加载网页的速度</li></ul><h2 id="2-缓存流程"><a href="#2-缓存流程" class="headerlink" title="2. 缓存流程"></a>2. 缓存流程</h2><p>这里先介绍一下浏览器缓存资源的一个大概的流程。<br>我们可以认为，浏览器里有一个专门存放缓存规则的一个数据库，也可以说是一个映射表，把缓存资源信息，同电脑磁盘中的实际文件的地址，对应起来。（大概意思，别较真）<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004228-e1b783b8-88ba-4ef1-a58a-c714d0740d4d.webp#align=left&display=inline&height=470&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=938&size=0&status=done&style=none&width=938"><br>而这个缓存规则的表，在浏览器中是可以看到的： chrome://cache/<br>不过我升级了浏览器之后，就不好使了，但是找到了 chrome://net-internals/#httpCache ，不知道是不是就是原来的，知道的同学也可以反馈一下<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004168-014c28f4-f7ed-46b4-afe0-59598b1d55f7.webp#align=left&display=inline&height=554&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=720&size=0&status=done&style=none&width=720"><br><strong>浏览器第一次请求资源时</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004329-50ec1799-37bf-4421-93dc-fd604083b0a8.webp#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&originHeight=417&originWidth=872&size=0&status=done&style=none&width=872"><br>上面所说的 <strong>缓存规则</strong>，就是声明所请求的这个资源，要采取哪种缓存策略？缓存多长时间？等等。。。而这个规则，是在 http 的 header 中的返回来的。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004475-05327a89-9e57-47f0-bf3a-749f64d136b6.webp#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=177&originWidth=505&size=0&status=done&style=none&width=505"><br><strong>注意：</strong> 是 response header ，而不是 request header ！！！<br>而实际上， request header 中也会携带规则信息，下面会讲，要区分 request 和 response</p><h2 id="3-缓存规则"><a href="#3-缓存规则" class="headerlink" title="3. 缓存规则"></a>3. 缓存规则</h2><p><strong>强缓存</strong>和协商缓存。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存**"></a>强缓存**</h3><p>简单粗暴，如果资源没过期，就取缓存，如果过期了，则请求服务器。<br>如何判断资源是否过期呢，也就是说强缓存的规则怎么看？<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004332-7d2dd0f5-79d4-4669-bda8-4c28d908aed7.webp#align=left&display=inline&height=164&margin=%5Bobject%20Object%5D&originHeight=164&originWidth=598&size=0&status=done&style=none&width=598"><br>主要是看 response headers 中的 Cache-Control 的值，图中的 max-age = 31xxxxxxx，就是说在这些秒内，都直接使用缓存，超过了就继续请求服务器<br>而和 Cache-Control 并列的，还有一个 Expires ，已经基本淘汰了，所以不用管</p><h4 id="Cache-Control-的几个取值含义："><a href="#Cache-Control-的几个取值含义：" class="headerlink" title="Cache-Control 的几个取值含义："></a>Cache-Control 的几个取值含义：</h4><p><code>**private**</code><strong>：</strong> 仅浏览器可以缓存<br><code>**public**</code><strong>：</strong> 浏览器和代理服务器都可以缓存（对于 private 和 public，前端可以认为一样，不用深究）<br><code>**max-age=xxx**</code> <strong>过期时间</strong>（重要）<br><code>**no-cache**</code> <strong>不进行强缓存</strong>（重要）<br><code>**no-store**</code> 不强缓存，也不协商缓存，基本不用，缓存越多才越好呢<br>注意：规则可以同时多个<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004092-4d8553a2-fed6-47b4-ab68-9c2bd9bf4ae0.webp#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&originHeight=96&originWidth=335&size=0&status=done&style=none&width=335"><br>所以，对于强缓存，我们主要研究 Cache-Control 中的 max-age 和 no-cache<br>所以，判断该资源是否命中强缓存，就看 response 中 Cache-Control 的值，如果有 max-age=xxx 秒，则命中强缓存。如果 Cache-Control 的值是 no-cache，说明没命中强缓存，走协商缓存。</p><h4 id="强缓存流程"><a href="#强缓存流程" class="headerlink" title="强缓存流程"></a>强缓存流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004253-e01f839d-c513-417e-bd34-4378f3731776.webp#align=left&display=inline&height=504&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=863&size=0&status=done&style=none&width=863"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004396-b0eeacbf-a6e9-4d03-a96c-bc2c2dab3191.webp#align=left&display=inline&height=510&margin=%5Bobject%20Object%5D&originHeight=510&originWidth=894&size=0&status=done&style=none&width=894"><br>所以强缓存步骤已经很清晰了：</p><ol><li>第一次请求 a.js ，缓存表中没该信息，直接请求后端服务器。</li><li>后端服务器返回了 a.js ，且 http response header 中 cache-control 为 max-age=xxxx，所以是强缓存规则，存入缓存表中。</li><li>第二次请求 a.js ，缓存表中是 max-age， 那么命中强缓存，然后判断是否过期，如果没过期，直接读缓存的 a.js，如果过期了，则执行协商缓存的步骤了。</li></ol><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>触发条件：</p><ol><li><code>Cache-Control 的值为 no-cache</code> （不强缓存）</li><li>或者<code> max-age 过期</code>了 （强缓存，但总有过期的时候）</li></ol><p>也就是说，不管怎样，都可能最后要进行协商缓存（no-store 除外）<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004462-f7fe8b60-4815-4df7-887b-3fedfd26ad22.webp#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=409&size=0&status=done&style=none&width=409"><br>这个图，虽然强缓存命中，但是也有 ETag 和 Last-Modified ，这两个就是协商缓存的相关规则。虽然之前的强缓存流程和他俩没关。。。<br><strong><code>ETag</code>**：每个文件有一个，改动文件了就变了，可以看似 md5<br>**<code>Last-Modified</code>**：文件的修改时间<br>也就是说，每次 http 返回来 **response</strong> header 中的 ETag 和 Last-Modified，在下次请求时在 <strong>request</strong> header 就把这两个带上（但是名字变了 ETag–&gt;If-None-Match，Last-Modified–&gt;If-Modified-Since ），服务端把你带过来的标识，资源目前的标识，进行对比，然后判断资源是否更改了。<br>这个过程是循环往复的，即缓存表在每次请求成功后都会更新规则。<br><strong>1. 第 n 次请求成功时：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004414-417dc8f2-99d3-4cd4-a871-8acf29c440a7.webp#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=461&size=0&status=done&style=none&width=461"><br><strong>2. 缓存表中更新该资源的 ETag 值</strong><br><strong>3. 第 n+1 次请求：</strong><br>从缓存表中取该资源最新的 ETag，然后加在 request header 中, 注意变名字了，由 ETag – &gt; If-None-Match<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004456-5ffbd3bb-c331-44bc-b352-a83c935abee0.webp#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=755&size=0&status=done&style=none&width=755"><br>图：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004201-e989da33-f921-4421-9199-a8c35680cac1.webp#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=926&size=0&status=done&style=none&width=926"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004386-f5271f6b-1eed-4acc-90c6-5543733822ef.webp#align=left&display=inline&height=507&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=904&size=0&status=done&style=none&width=904"><br>所以协商缓存步骤总结：</p><ol><li>请求资源时，把用户本地该资源的 ETag 同时带到服务端，服务端和最新资源做对比。</li><li>如果资源没更改，返回 304，浏览器读取本地缓存。</li><li>如果资源有更改，返回 200，返回最新的资源。</li></ol><h2 id="4-缓存命中显示"><a href="#4-缓存命中显示" class="headerlink" title="4. 缓存命中显示"></a>4. 缓存命中显示</h2><h3 id="1-从服务器获取新的资源"><a href="#1-从服务器获取新的资源" class="headerlink" title="1. 从服务器获取新的资源"></a>1. 从服务器获取新的资源</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004581-eb2cc554-90e1-412d-b201-250618ac0966.webp#align=left&display=inline&height=91&margin=%5Bobject%20Object%5D&originHeight=91&originWidth=1017&size=0&status=done&style=none&width=1017"></p><h3 id="2-命中强缓存，且资源没过期，直接读取本地缓存"><a href="#2-命中强缓存，且资源没过期，直接读取本地缓存" class="headerlink" title="2. 命中强缓存，且资源没过期，直接读取本地缓存"></a>2. 命中强缓存，且资源没过期，直接读取本地缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004424-9bfd17e7-03e5-408c-be24-43e06430c32b.webp#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&originHeight=232&originWidth=620&size=0&status=done&style=none&width=620"></p><h3 id="3-命中协商缓存，且资源未更改，读取本地缓存"><a href="#3-命中协商缓存，且资源未更改，读取本地缓存" class="headerlink" title="3. 命中协商缓存，且资源未更改，读取本地缓存"></a>3. 命中协商缓存，且资源未更改，读取本地缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004243-19a75c69-59a0-41df-8b61-f50388b498c3.webp#align=left&display=inline&height=113&margin=%5Bobject%20Object%5D&originHeight=113&originWidth=649&size=0&status=done&style=none&width=649"><br>注意：协商缓存无论如果，都要向服务端发请求的，只不过，资源未更改时，返回的只是 header 信息，所以 size 很小；而资源有更改时，还要返回 body 数据，所以 size 会大。</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p><strong>0. 怎么配置资源的缓存规则</strong><br>可以有后端服务器配置，也可以在 nginx 中配置，稍后会更新一张 nginx 的配置<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004442-3902b161-74f3-47cb-8d89-0de12cced022.webp#align=left&display=inline&height=584&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=580&size=0&status=done&style=none&width=580"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004328-18ee0569-e907-48f4-9cda-4830802d419d.webp#align=left&display=inline&height=138&margin=%5Bobject%20Object%5D&originHeight=138&originWidth=402&size=0&status=done&style=none&width=402"></p><h3 id="1-为什么要有-Etag"><a href="#1-为什么要有-Etag" class="headerlink" title="1. 为什么要有 Etag"></a>1. 为什么要有 Etag</h3><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？HTTP1.1 中 Etag 的出现（也就是说，ETag 是新增的，为了解决之前只有 If-Modified 的缺点）主要是为了解决几个 Last-Modified 比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><h3 id="2-强缓存与协商缓存的区别可以用下表来表示："><a href="#2-强缓存与协商缓存的区别可以用下表来表示：" class="headerlink" title="2. 强缓存与协商缓存的区别可以用下表来表示："></a>2. 强缓存与协商缓存的区别可以用下表来表示：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004421-3b5bcccd-6a74-4e6a-9cd7-49fcfc5ff96f.webp#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=637&size=0&status=done&style=none&width=637"></p><h3 id="3-用户行为对缓存的影响"><a href="#3-用户行为对缓存的影响" class="headerlink" title="3. 用户行为对缓存的影响"></a>3. 用户行为对缓存的影响</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004246-f526bf6c-9254-4261-8cfc-197b9b93db87.webp#align=left&display=inline&height=293&margin=%5Bobject%20Object%5D&originHeight=293&originWidth=708&size=0&status=done&style=none&width=708"><br>即：F5 会 跳过强缓存规则，直接走协商缓存；；；Ctrl+F5 ，跳过所有缓存规则，和第一次请求一样，重新获取资源</p><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><h3 id="Expires-和-max-age-的区别"><a href="#Expires-和-max-age-的区别" class="headerlink" title="Expires 和 max-age 的区别"></a>Expires 和 max-age 的区别</h3><p>Expires 和 max-age 都可以用来指定文档的过期时间，但是二者有一些细微差别 1.<code>Expires</code>在<code>HTTP/1.0</code>中已经定义，<code>Cache-Control:max-age</code>在<code>HTTP/1.1</code>中才有定义，为了向下兼容，仅使用 max-age 不够；<br>2.Expires 指定一个<code>绝对的过期时间</code>(GMT 格式),这么做会导致至少 2 个问题 1)客户端和服务器时间不同步导致 Expires 的配置出现问题 2）很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象；<br>3.max-age 指定的是从文档<code>被访问后的存活时间</code>，这个时间是个相对值(比如:3600s),相对的是文档第一次被请求时服务器记录的 Request_time(请求时间)<br>4.Expires 指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime),而 max-age 相对对的是文档的请求时间(Atime) 5.在 Apache 中，max-age 是根据 Expires 的时间来计算出来的 max-age = expires- request_time:(mod_expires.c)</p><h3 id="expire-和-etag-last-modified-的优先级问题"><a href="#expire-和-etag-last-modified-的优先级问题" class="headerlink" title="expire 和 etag,last-modified 的优先级问题"></a>expire 和 etag,last-modified 的优先级问题</h3><p>转自：<a href="https://segmentfault.com/q/1010000022541364">https://segmentfault.com/q/1010000022541364</a><br><code>Expires</code> 已经没啥用了，更多的是为了兼容旧浏览器（只支持 HTTP/1.0 的上古时代浏览器）的响应标头。<br>从 HTTP/1.1 以后就有了 <code>Cache-Control</code> 标头中的 <code>max-age</code>，与上者几乎等效，也就是设值有所不同，前者是设一个具体的时间点、后者是设一个秒数。但显然 <code>Expires</code> 可能因为客户端与服务端时间不一致、或网络延迟导致过期时间不准确，并且 <code>Cache-Control</code> 能设的值更多也就更灵活。<br>如果两者同时存在，以 <code>Cache-Control</code> 为准。</p><hr><p>如果同时设了 <code>ETag</code> 和 <code>Last-Modified</code>，那么必须同时满足条件才会 304，不存在谁更优先就使用谁一说。<br>但一般分布式环境下（比如 CDN）很少使用 <code>ETag</code>，因为 <code>ETag</code> 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 <code>ETag</code> 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 <code>ETag</code>，并不绝对。</p><hr><p>顺序的话是先判断 <code>Cache-Control</code>／<code>Expires</code>，再 <code>ETag</code>，最后 <code>Last-Modified</code>，都满足就 304，有一项不满足就 200。</p><p><code>max-age</code>  为 0 表示强制检查  <code>Last-Modified</code>／<code>ETag</code>，可以近似理解为与  <code>no-cache</code>  等效。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>借两个图<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004465-c0fda00e-abf8-461b-9d08-963ca647e3ee.webp#align=left&display=inline&height=635&margin=%5Bobject%20Object%5D&originHeight=635&originWidth=643&size=0&status=done&style=none&width=643"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1598797004449-575cc4e4-6adc-4ee6-bfa0-121cc00c5810.webp#align=left&display=inline&height=1031&margin=%5Bobject%20Object%5D&originHeight=1031&originWidth=692&size=0&status=done&style=none&width=692"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见请求头、响应头</title>
    <link href="/2020/09/19/yuque/%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%81%E5%93%8D%E5%BA%94%E5%A4%B4/"/>
    <url>/2020/09/19/yuque/%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%81%E5%93%8D%E5%BA%94%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903674183942152#heading-8">https://juejin.im/post/6844903674183942152#heading-8</a>、<a href="https://juejin.im/post/6844903957593063432">https://juejin.im/post/6844903957593063432</a><br>请求头：<code>**origin、referer、content-type、user-agent、expires、If-None-Match、If-Modified-Since**</code><br>响应头：<code>**cache-control、access-control-allow-origin、etag、last-modified**</code></p><h1 id="http-请求头与响应头的应用"><a href="#http-请求头与响应头的应用" class="headerlink" title="http 请求头与响应头的应用"></a>http 请求头与响应头的应用</h1><h2 id="Chap1-发现-headers"><a href="#Chap1-发现-headers" class="headerlink" title="Chap1 发现 headers"></a>Chap1 发现 headers</h2><p>当我们随便打开一个网址（比如大家经常拿来测试网络的百度）时，打开<code>Network</code>,会看到如下请求头，响应头：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600520929236-cb519fb6-83c0-49a8-8dfe-8492af59fe8f.webp#align=left&display=inline&height=1072&margin=%5Bobject%20Object%5D&originHeight=1072&originWidth=960&size=0&status=done&style=none&width=960">究竟这些 headers 都有什么用呢？ 咱们挨个探个究竟。</p><h2 id="Chap2-headers-用途"><a href="#Chap2-headers-用途" class="headerlink" title="Chap2 headers 用途"></a>Chap2 headers 用途</h2><h3 id="2-1-Content-Type"><a href="#2-1-Content-Type" class="headerlink" title="2.1 Content-Type"></a>2.1 Content-Type</h3><p><code>Content-Type</code>表示请求头或响应头的内容类型。作为请求头时，利用它可以进行<a href="https://www.npmjs.com/package/body-parser">body-parser</a>。 Sooo~ <em>What is <code>body-parser</code>?</em><br>body-parser 是 node 常用的中间件，其作用是:</p><blockquote><p>Parse incoming request bodies in a middleware before your handlers, available under the req.body property.</p></blockquote><p>即在处理数据之前用中间件对 post 请求体进行解析。 <a href="https://www.npmjs.com/package/body-parser">body-parser</a>的例子为：</p><blockquote><p>下面的例子展示了如何给路由添加<code>body parser</code>。通常，这是在<code>express</code>中最为推荐的使用<code>body-parser</code>的方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;body-parser&quot;</span>);<br><span class="hljs-keyword">var</span> app = express();<br><span class="hljs-comment">// create application/json parser</span><br><span class="hljs-keyword">var</span> jsonParser = bodyParser.json();<br><span class="hljs-comment">// create application/x-www-form-urlencoded parser</span><br><span class="hljs-keyword">var</span> urlencodedParser = bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;);<br><span class="hljs-comment">// POST /login gets urlencoded bodies</span><br>app.post(<span class="hljs-string">&quot;/login&quot;</span>, urlencodedParser, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!req.body) <span class="hljs-keyword">return</span> res.sendStatus(<span class="hljs-number">400</span>);<br>  res.send(<span class="hljs-string">&quot;welcome, &quot;</span> + req.body.username);<br>&#125;);<br><span class="hljs-comment">// POST /api/users gets JSON bodies</span><br>app.post(<span class="hljs-string">&quot;/api/users&quot;</span>, jsonParser, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!req.body) <span class="hljs-keyword">return</span> res.sendStatus(<span class="hljs-number">400</span>);<br>  <span class="hljs-comment">// create user in req.body</span><br>&#125;);<br>复制代码;<br></code></pre></td></tr></table></figure><p><code>body-parser</code>核心源码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// this uses a switch for static require analysis</span><br><span class="hljs-keyword">switch</span> (parserName) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:<br>    parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/types/json&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;raw&quot;</span>:<br>    parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/types/raw&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;text&quot;</span>:<br>    parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/types/text&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;urlencoded&quot;</span>:<br>    parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/types/urlencoded&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以<code>json</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> contentType = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;content-type&quot;</span>);<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the charset of a request.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">req</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@api <span class="hljs-variable">private</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCharset</span>(<span class="hljs-params">req</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> (contentType.parse(req).parameters.charset || <span class="hljs-string">&quot;&quot;</span>).toLowerCase();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">// assert charset per RFC 7159 sec 8.1</span><br><span class="hljs-keyword">var</span> charset = getCharset(req) || <span class="hljs-string">&quot;utf-8&quot;</span>;<br><span class="hljs-keyword">if</span> (charset.substr(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) !== <span class="hljs-string">&quot;utf-&quot;</span>) &#123;<br>  debug(<span class="hljs-string">&quot;invalid charset&quot;</span>);<br>  next(<br>    createError(<span class="hljs-number">415</span>, <span class="hljs-string">&#x27;unsupported charset &quot;&#x27;</span> + charset.toUpperCase() + <span class="hljs-string">&#x27;&quot;&#x27;</span>, &#123;<br>      <span class="hljs-attr">charset</span>: charset,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;charset.unsupported&quot;</span>,<br>    &#125;)<br>  );<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出：其背后工作原理就是通过分析请求头中的<code>Content-Type</code>的类型，根据不同的类型进行相应数据处理，我们自己模拟一下：<br>step1: 先建立<code>server.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> r = Buffer.concat(arr).toString();<br>  <span class="hljs-comment">// body-parser  解析请求，根据不同的格式进行不同的解析</span><br>  <span class="hljs-keyword">if</span> (req.headers[<span class="hljs-string">&quot;content-type&quot;</span>] === www.js) &#123;<br>    <span class="hljs-keyword">let</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;querystring&quot;</span>);<br>    r = querystring.parse(r); <span class="hljs-comment">// a=1&amp;b=2</span><br>    <span class="hljs-built_in">console</span>.log(r, <span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.headers[<span class="hljs-string">&quot;content-type&quot;</span>] === <span class="hljs-string">&quot;application/json&quot;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.parse(r), <span class="hljs-number">2</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(r, <span class="hljs-number">3</span>);<br>  &#125;<br>  res.end(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>step2: 客户端模拟请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> opts = &#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/hello&quot;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>    <span class="hljs-string">&quot;Content-Length&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-comment">//模拟的时候需要带上长度，不然客户端会当成没有传递数据</span><br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> client = http.request(opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>  res.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data.toString());<br>  &#125;);<br>&#125;);<br>client.end(<span class="hljs-string">&#x27;&#123;&quot;a&quot;:1&#125;&#x27;</span>); <span class="hljs-comment">// 表示把请求发出去</span><br>复制代码;<br></code></pre></td></tr></table></figure><p>step3: 测试。 先启动 server,再启动 client，服务端收到按照<code>application/json</code>格式解析的数据： <code>&#123; a: 1 &#125; 2</code>. <code>Content-Type</code>与<code>body-parser</code>之间的关系就先分析到这里了。 后面我们接着看请求头。</p><h4 id="form-的-enctype-属性总共有三种值"><a href="#form-的-enctype-属性总共有三种值" class="headerlink" title="form 的 enctype 属性总共有三种值"></a>form 的 enctype 属性总共有三种值</h4><ol><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ol><p>分别说一下，这三种类型的使用：</p><ul><li><code>application/x-www-form-urlencoded</code></li></ul><p>用于<code>普通字段的表单数据</code>，表单数据会在请求体中，数据以符合某种格式(就是 application/x-www-form-urlencoded 这个格式啦，这真不是废话)发送给服务端，至于这个具体是什么样的格式，看 MDN 就可以知道了，总之，这个不是重点，因为就是一种格式而已。</p><ul><li><code>multipart/form-data</code></li></ul><p>用于<code>文件</code>或<code>二进制</code>数据，数据会按照某种格式(就是 multipart/form-data 这种格式啦，这真不是废话)，你想知道这种格式具体是什么样的就看 MDN，因为这并不是重点，就是一种格式而已。</p><ul><li><code>text/plain</code></li></ul><p>永远不要使用这个值，因为不会被可靠的去解析。**</p><h3 id="2-2-Range-bytes"><a href="#2-2-Range-bytes" class="headerlink" title="2.2 Range:bytes"></a>2.2 Range:bytes</h3><p>请求头通过 Range:bytes 可以请求资源的某一部分。利用这个字段可模拟部分读取。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> range = req.headers[<span class="hljs-string">&#x27;range&#x27;</span>];<br> &#125;）<br></code></pre></td></tr></table></figure><p>server:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">let</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-comment">// 当前要下载的文件的大小</span><br><span class="hljs-keyword">let</span> size = fs.statSync(path.join(__dirname, <span class="hljs-string">&quot;my.txt&quot;</span>)).size;<br><span class="hljs-keyword">let</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> range = req.headers[<span class="hljs-string">&quot;range&quot;</span>]; <span class="hljs-comment">// 0-3</span><br>  <span class="hljs-keyword">if</span> (range) &#123;<br>    <span class="hljs-comment">// 模拟请求 curl -v --header &quot;Range:bytes=0-3&quot; http://localhost:3000</span><br>    <span class="hljs-keyword">let</span> [, start, end] = range.match(<span class="hljs-regexp">/(\d*)-(\d*)/</span>);<br>    start = start ? <span class="hljs-built_in">Number</span>(start) : <span class="hljs-number">0</span>;<br>    end = end ? <span class="hljs-built_in">Number</span>(end) : size - <span class="hljs-number">1</span>; <span class="hljs-comment">// 10个字节 size 10  （0-9）</span><br>    res.setHeader(<span class="hljs-string">&quot;Content-Range&quot;</span>, <span class="hljs-string">`bytes <span class="hljs-subst">$&#123;start&#125;</span>-<span class="hljs-subst">$&#123;end&#125;</span>/<span class="hljs-subst">$&#123;size - <span class="hljs-number">1</span>&#125;</span>`</span>);<br>    fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;my.txt&quot;</span>), &#123; start, end &#125;).pipe(<br>      res<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 会把文件的内容写给客户端</span><br>    fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;my.txt&quot;</span>)).pipe(res);<br>    <span class="hljs-comment">//可读流可以通过pipe导到可写流</span><br>  &#125;<br>&#125;);<br>server.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>client:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> opts = &#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>  <span class="hljs-attr">headers</span>: &#123;&#125;,<br>&#125;;<br><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;<br>  opts.headers.Range = <span class="hljs-string">`bytes=<span class="hljs-subst">$&#123;start&#125;</span>-<span class="hljs-subst">$&#123;start + <span class="hljs-number">3</span>&#125;</span>`</span>;<br>  start += <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`start is <span class="hljs-subst">$&#123;start&#125;</span>`</span>);<br>  <span class="hljs-keyword">let</span> client = http.request(opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> total = res.headers[<span class="hljs-string">&quot;content-range&quot;</span>].split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// console.log(half)</span><br>    res.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      fs.appendFileSync(<span class="hljs-string">&quot;./download1.txt&quot;</span>, data);<br>    &#125;);<br>    res.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!pause &amp;&amp; start &lt; total) download();<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>  &#125;);<br>  client.end();<br>&#125;<br>download();<br></code></pre></td></tr></table></figure><p>分段读取添加暂停功能，监听用户输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pause = <span class="hljs-literal">false</span>;<br>process.stdin.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (data.toString().includes(<span class="hljs-string">&quot;p&quot;</span>)) &#123;<br>    pause = <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    pause = <span class="hljs-literal">false</span>;<br>    download();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>测试结果：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600521008038-16438801-db3c-4cf1-b98b-a49d0def6f81.webp#align=left&display=inline&height=416&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=716&size=0&status=done&style=none&width=716"><br>分段读取有以下好处：</p><ul><li>提高读取速度，多线程并行，分块读取</li><li>断点续传</li></ul><p>模拟并行下载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> halfFlag = <span class="hljs-number">20</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;<br>  opts.headers.Range = <span class="hljs-string">`bytes=<span class="hljs-subst">$&#123;start&#125;</span>-<span class="hljs-subst">$&#123;start+<span class="hljs-number">3</span>&#125;</span>`</span>;<br>  start+=<span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`start is <span class="hljs-subst">$&#123;start&#125;</span>`</span>)<br>  <span class="hljs-keyword">let</span> client = http.request(opts,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> total = res.headers[<span class="hljs-string">&#x27;content-range&#x27;</span>].split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> halfFlag = <span class="hljs-built_in">Math</span>.floor(total/<span class="hljs-number">2</span>)<br>      <span class="hljs-comment">// console.log(half)</span><br>      res.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        fs.appendFileSync(<span class="hljs-string">&#x27;./download1.txt&#x27;</span>,data);<br>      &#125;);<br>      res.on(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> ((!pause)&amp;&amp;(start &lt; halfFlag))<br>            download();<br>        &#125;, <span class="hljs-number">1000</span>);<br>      &#125;)<br>  &#125;);<br>  client.end();<br>&#125;<br><span class="hljs-keyword">let</span> half = halfFlag<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadTwo</span>(<span class="hljs-params"></span>) </span>&#123;<br>opts.headers.Range = <span class="hljs-string">`bytes=<span class="hljs-subst">$&#123;half&#125;</span>-<span class="hljs-subst">$&#123;half+<span class="hljs-number">3</span>&#125;</span>`</span>;<br>half+=<span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`half is <span class="hljs-subst">$&#123;half&#125;</span>`</span>)<br><span class="hljs-keyword">let</span> client = http.request(opts,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br><span class="hljs-keyword">let</span> total = res.headers[<span class="hljs-string">&#x27;content-range&#x27;</span>].split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>];<br>res.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>fs.appendFileSync(<span class="hljs-string">&#x27;./download2.txt&#x27;</span>,data);<br>&#125;);<br>res.on(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (!pause&amp;½ &lt; total)<br>downloadTwo();<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br>&#125;);<br>client.end();<br>&#125;<br>download();<br>downloadTwo();<br></code></pre></td></tr></table></figure><p>运行结果，会把原文件分成两部分下载到 download1.txt 和 download2.txt。 测试：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600521021752-07f45fed-5bf4-4f14-9fb0-bc35c1ba7bbe.webp#align=left&display=inline&height=416&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=740&size=0&status=done&style=none&width=740"><br>理论上，这样的下载方式会比第一种方法节约一半的时间。但是实际中的文件下载怎样实现加速以及并行下载的，还有待考究。</p><h3 id="2-3-Cache-Control-与-Expires-之强制缓存"><a href="#2-3-Cache-Control-与-Expires-之强制缓存" class="headerlink" title="2.3 Cache-Control 与 Expires 之强制缓存"></a>2.3 Cache-Control 与 Expires 之强制缓存</h3><p>Response Header 响应头中<code>Cache-Control: max-age=1233</code>可以设置相对当前的时间的强制缓存，与它相关的 <code>Expires</code>可以设置某个绝对时间点限定读取缓存的时间。 模拟实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;url&quot;</span>); <span class="hljs-comment">// 专门用来处理url路径的核心模块</span><br><span class="hljs-comment">// http://username:password@hostname:port/pathname?query</span><br><span class="hljs-keyword">let</span> server = http<br>  .createServer(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(req.url);<br>    <span class="hljs-keyword">let</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// true就是将query转化成对象</span><br>    <span class="hljs-keyword">let</span> readPath = path.join(__dirname, <span class="hljs-string">&quot;public&quot;</span>, pathname);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> statObj = <span class="hljs-keyword">await</span> stat(readPath);<br>      <span class="hljs-comment">// 根客户端说 10s 内走缓存</span><br>      res.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;max-age=10&quot;</span>);<br>      res.setHeader(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>).toGMTString());<br>      <span class="hljs-comment">// 10s之内的请求都会走cache 返回200， (from disk cache)不发生请求</span><br>      <span class="hljs-keyword">if</span> (statObj.isDirectory()) &#123;<br>        <span class="hljs-keyword">let</span> p = path.join(readPath, <span class="hljs-string">&quot;index.html&quot;</span>);<br>        <span class="hljs-keyword">await</span> stat(p);<br>        <span class="hljs-comment">// 如果当前目录下有html那么就返回这个文件</span><br>        fs.createReadStream(p).pipe(res);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fs.createReadStream(readPath).pipe(res);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      res.statusCode = <span class="hljs-number">404</span>;<br>      res.end(<span class="hljs-string">`Not found`</span>);<br>    &#125;<br>  &#125;)<br>  .listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>测试：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600521029041-f80bcc04-3e81-4f12-bdd9-db95fa432f5f.webp#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&originHeight=82&originWidth=1280&size=0&status=done&style=none&width=1280">10s 内刷新：<img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600521029025-b92755d1-f73a-4494-9c80-31e10a9e1d1c.webp#align=left&display=inline&height=119&margin=%5Bobject%20Object%5D&originHeight=119&originWidth=1280&size=0&status=done&style=none&width=1280"></p><h3 id="2-4-对比缓存之-Last-Modified-和-If-Modified-Since"><a href="#2-4-对比缓存之-Last-Modified-和-If-Modified-Since" class="headerlink" title="2.4 对比缓存之 Last-Modified 和 If-Modified-Since"></a>2.4 对比缓存之 Last-Modified 和 If-Modified-Since</h3><p>对比响应头 Last-Modified and 与请求头 If-Modified-Since，可以通过文件修改时间看文件是否修改，从而决定是重新请求还是走缓存。 模拟如下： step1 不设置强制缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">res.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br></code></pre></td></tr></table></figure><p>step2 应用文件修改时间比对是否修改，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">res.setHeader(<span class="hljs-string">&quot;Last-Modified&quot;</span>, statObj.ctime.toGMTString());<br><span class="hljs-keyword">if</span> (req.headers[<span class="hljs-string">&quot;if-modified-since&quot;</span>] === statObj.ctime.toGMTString()) &#123;<br>  res.statusCode = <span class="hljs-number">304</span>;<br>  res.end();<br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 走缓存</span><br>&#125;<br>fs.createReadStream(readPath).pipe(res);<br></code></pre></td></tr></table></figure><p>测试：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600520929369-49ed2753-bfb6-4681-a44d-a2e0ed5a3e42.webp#align=left&display=inline&height=860&margin=%5Bobject%20Object%5D&originHeight=860&originWidth=966&size=0&status=done&style=none&width=966"></p><h3 id="2-5-对比缓存之-Etag-和-If-None-Match"><a href="#2-5-对比缓存之-Etag-和-If-None-Match" class="headerlink" title="2.5 对比缓存之 Etag 和 If-None-Match"></a>2.5 对比缓存之 Etag 和 If-None-Match</h3><p>对比响应头:Etag 与请求头:If-None-Match，Etag 和 If-None-Match 如果相等，即返回 304。 etag 如何添加?</p><blockquote><p>根据文件内容,生成一个 md5 的摘要，给实体加一个标签。</p></blockquote><p>这种方法虽然比较耗性能，但是能够更加精确的对比出文件是否进行了修改。依靠文件修改时间进行对比并不够准确。因为有时文件有改动 Last-Modified 发生了变化，但是文件的内容可能根本没有变化。所以这种方案要优于 2.4.<br>实现方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rs = fs.createReadStream(p);<br><span class="hljs-keyword">let</span> md5 = crypto.createHash(<span class="hljs-string">&quot;md5&quot;</span>); <span class="hljs-comment">// 不能写完响应体再写头</span><br><span class="hljs-keyword">let</span> arr = [];<br>rs.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>  md5.update(data);<br>  arr.push(data);<br>&#125;);<br></code></pre></td></tr></table></figure><p>设置 Etag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">rs.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> r = md5.digest(<span class="hljs-string">&quot;base64&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Etag&quot;</span>, r);<br>  <span class="hljs-keyword">if</span> (req.headers[<span class="hljs-string">&quot;if-none-match&quot;</span>] === r) &#123;<br>    res.statusCode = <span class="hljs-number">304</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  res.end(Buffer.concat(arr));<br>&#125;);<br></code></pre></td></tr></table></figure><p>测试：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600520929341-410b0dbf-016d-41d6-9bcb-0676178c758f.webp#align=left&display=inline&height=826&margin=%5Bobject%20Object%5D&originHeight=826&originWidth=966&size=0&status=done&style=none&width=966"></p><h3 id="2-6-Accept-Encoding"><a href="#2-6-Accept-Encoding" class="headerlink" title="2.6 Accept-Encoding"></a>2.6 Accept-Encoding</h3><p>依靠请求头： Accept-Encoding: gzip, deflate, br 告诉服务端可接受的数据格式。服务端返回后会把数据格式通过响应格式通过 Content-Encoding 来标记。 在客户端接受 gzip 的格式下，后端可通过文件压缩处理传递，提高性能。 node api 中提供了<a href="http://nodejs.cn/api/zlib.html#zlib_class_zlib_gzip">zlib</a>模块:</p><blockquote><p>zlib 模块提供通过 Gzip 和 Deflate/Inflate 实现的压缩功能</p></blockquote><p>下面我们来应用 zlib 与请求头 Accept-Encoding 来实现压缩功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;zlib&quot;</span>);<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">let</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gzip</span>(<span class="hljs-params">filePath</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> transform = zlib.createGzip(); <span class="hljs-comment">//转化流通过transform压缩，然后再写</span><br>  fs.createReadStream(filePath)<br>    .pipe(transform)<br>    .pipe(fs.createWriteStream(filePath + <span class="hljs-string">&quot;.gz&quot;</span>));<br>&#125;<br>gzip(<span class="hljs-string">&quot;2.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>解压：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gunzip</span>(<span class="hljs-params">filePath</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> transform = zlib.createGunzip();<br>  fs.createReadStream(filePath)<br>    .pipe(transform)<br>    .pipe(fs.createWriteStream(path.basename(filePath, <span class="hljs-string">&quot;.gz&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>path.basename(filePath,&#39;.gz&#39;)</code>用来去掉 filePath 文件名的后缀<code>.gz</code>。<br>根据请求头接受的类型后端的具体操作 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/download&quot;</span>) &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment&quot;</span>);<br>  <span class="hljs-keyword">return</span> fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>)).pipe(res);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">let</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">let</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;zlib&quot;</span>);<br>http<br>  .createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/download&quot;</span>) &#123;<br>      res.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment&quot;</span>);<br>      <span class="hljs-keyword">return</span> fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>)).pipe(res);<br>    &#125;<br>    <span class="hljs-keyword">let</span> rule = req.headers[<span class="hljs-string">&quot;accept-encoding&quot;</span>];<br>    <span class="hljs-keyword">if</span> (rule) &#123;<br>      <span class="hljs-keyword">if</span> (rule.match(<span class="hljs-regexp">/\bgzip\b/</span>)) &#123;<br>        res.setHeader(<span class="hljs-string">&quot;Content-Encoding&quot;</span>, <span class="hljs-string">&quot;gzip&quot;</span>);<br>        fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>))<br>          .pipe(zlib.createGzip())<br>          .pipe(res);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rule.match(<span class="hljs-regexp">/\bdeflate\b/</span>)) &#123;<br>        res.setHeader(<span class="hljs-string">&quot;Content-Encoding&quot;</span>, <span class="hljs-string">&quot;deflate&quot;</span>);<br>        fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>))<br>          .pipe(zlib.createDeflate())<br>          .pipe(res);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>)).pipe(res);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;1.html&quot;</span>)).pipe(res);<br>    &#125;<br>  &#125;)<br>  .listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>test deflate:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">curl -v --header <span class="hljs-string">&quot;Accept-Encoding:deflate&quot;</span> http:<span class="hljs-comment">//localhost:3000</span><br>* Rebuilt URL to: http:<span class="hljs-comment">//localhost:3000/</span><br>*   Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>* TCP_NODELAY set<br>* Connected to localhost (<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>) port <span class="hljs-number">3000</span> (#<span class="hljs-number">0</span>)<br>&gt; GET / HTTP/<span class="hljs-number">1.1</span><br>&gt; Host: localhost:<span class="hljs-number">3000</span><br>&gt; User-Agent: curl/<span class="hljs-number">7.54</span><span class="hljs-number">.0</span><br>&gt; Accept: *<span class="hljs-comment">/*</span><br><span class="hljs-comment">&gt; Accept-Encoding:deflate</span><br><span class="hljs-comment">&gt;</span><br><span class="hljs-comment">&lt; HTTP/1.1 200 OK</span><br><span class="hljs-comment">&lt; Content-Encoding: deflate</span><br><span class="hljs-comment">&lt; Date: Thu, 23 Aug 2018 03:01:13 GMT</span><br><span class="hljs-comment">&lt; Connection: keep-alive</span><br><span class="hljs-comment">&lt; Transfer-Encoding: chunked</span><br></code></pre></td></tr></table></figure><p>test others:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">curl -v --header <span class="hljs-string">&quot;Accept-Encoding:nn&quot;</span> http:<span class="hljs-comment">//localhost:3000</span><br>* Rebuilt URL to: http:<span class="hljs-comment">//localhost:3000/</span><br>*   Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>* TCP_NODELAY set<br>* Connected to localhost (<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>) port <span class="hljs-number">3000</span> (#<span class="hljs-number">0</span>)<br>&gt; GET / HTTP/<span class="hljs-number">1.1</span><br>&gt; Host: localhost:<span class="hljs-number">3000</span><br>&gt; User-Agent: curl/<span class="hljs-number">7.54</span><span class="hljs-number">.0</span><br>&gt; Accept: *<span class="hljs-comment">/*</span><br><span class="hljs-comment">&gt; Accept-Encoding:nn</span><br><span class="hljs-comment">&gt;</span><br><span class="hljs-comment">&lt; HTTP/1.1 200 OK</span><br><span class="hljs-comment">&lt; Date: Thu, 23 Aug 2018 03:02:51 GMT</span><br><span class="hljs-comment">&lt; Connection: keep-alive</span><br><span class="hljs-comment">&lt; Transfer-Encoding: chunked</span><br><span class="hljs-comment">&lt;</span><br><span class="hljs-comment">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-comment">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-comment">&lt;head&gt;</span><br><span class="hljs-comment">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-comment">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="hljs-comment">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="hljs-comment">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="hljs-comment">&lt;/head&gt;</span><br><span class="hljs-comment">&lt;body&gt;</span><br><span class="hljs-comment">  你好</span><br><span class="hljs-comment">&lt;/body&gt;</span><br><span class="hljs-comment">* Connection #0 to host localhost left intact</span><br><span class="hljs-comment">&lt;/html&gt;%</span><br></code></pre></td></tr></table></figure><h3 id="2-7-referer"><a href="#2-7-referer" class="headerlink" title="2.7 referer"></a>2.7 referer</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600521099503-22fae1f8-11e3-49a4-a3ee-445339e4ff03.webp#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&originHeight=140&originWidth=1220&size=0&status=done&style=none&width=1220"><br>referer 表示请求文件的网址，请求时会携带。为了防止自己网站的文件被外网直接引用，可以通过比较 referer，即请求的地址，与本地地址比较，设置防盗链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">let</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;url&quot;</span>);<br><span class="hljs-keyword">let</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-comment">// 这是百度的服务器</span><br><span class="hljs-keyword">let</span> server = http<br>  .createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> &#123; pathname &#125; = url.parse(req.url);<br>    <span class="hljs-keyword">let</span> realPath = path.join(__dirname, pathname);<br>    fs.stat(realPath, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, statObj</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        res.statusCode = <span class="hljs-number">404</span>;<br>        res.end();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> referer = req.headers[<span class="hljs-string">&quot;referer&quot;</span>] || req.headers[<span class="hljs-string">&quot;referred&quot;</span>];<br>        <span class="hljs-keyword">if</span> (referer) &#123;<br>          <span class="hljs-keyword">let</span> current = req.headers[<span class="hljs-string">&quot;host&quot;</span>]; <span class="hljs-comment">// 代表的是当前图片的地址</span><br>          referer = url.parse(referer).host; <span class="hljs-comment">// 引用图片的网址</span><br>          <span class="hljs-keyword">if</span> (current === referer) &#123;<br>            fs.createReadStream(realPath).pipe(res);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            fs.createReadStream(path.join(__dirname, <span class="hljs-string">&quot;images/2.jpg&quot;</span>)).pipe(res);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          fs.createReadStream(realPath).pipe(res);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;)<br>  .listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h3 id="2-8-Accept-Language"><a href="#2-8-Accept-Language" class="headerlink" title="2.8 Accept-Language"></a>2.8 Accept-Language</h3><blockquote><p>请求头：Accept-Language: zh-CN,zh;q=0.9 多个语言用 ‘,’ 分隔，权重用 ‘=’ 表示’,没有默认权重为 1</p></blockquote><p>后端根据请求接受语言的权重一次查找，查找到就返回，找不到就用默认语言</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> langs = &#123;<br>  <span class="hljs-attr">en</span>: <span class="hljs-string">&quot;hello world&quot;</span>,<br>  <span class="hljs-string">&quot;zh-CN&quot;</span>: <span class="hljs-string">&quot;你好世界&quot;</span>,<br>  <span class="hljs-attr">zh</span>: <span class="hljs-string">&quot;你好&quot;</span>,<br>  <span class="hljs-attr">ja</span>: <span class="hljs-string">&quot;こんにちは、世界&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> defualtLanguage = <span class="hljs-string">&quot;en&quot;</span>;<br><span class="hljs-comment">// 多语言之服务端方案：来做 (浏览器会发一个头) 前端来做</span><br><span class="hljs-comment">// 通过url实现多语言</span><br><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br>http<br>  .createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> lan = req.headers[<span class="hljs-string">&quot;accept-language&quot;</span>];<br>    <span class="hljs-comment">//[[zh,q=0.9],[zh-CN]] =&gt;[&#123;name:&#x27;zh-CN&#x27;,q=1&#125;,&#123;name:&#x27;zh&#x27;,q:0.9&#125;]</span><br>    <span class="hljs-keyword">if</span> (lan) &#123;<br>      lan = lan.split(<span class="hljs-string">&quot;,&quot;</span>);<br>      lan = lan<br>        .map(<span class="hljs-function">(<span class="hljs-params">l</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> [name, q] = l.split(<span class="hljs-string">&quot;;&quot;</span>);<br>          q = q ? <span class="hljs-built_in">Number</span>(q.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]) : <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">return</span> &#123; name, q &#125;;<br>        &#125;)<br>        .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.q - a.q); <span class="hljs-comment">// 排出 权重数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lan.length; i++) &#123;<br>        <span class="hljs-comment">// 将每个人的名字 取出来</span><br>        <span class="hljs-keyword">let</span> name = lan[i].name;<br>        <span class="hljs-keyword">if</span> (langs[name]) &#123;<br>          <span class="hljs-comment">//去语言包查找 查找到就返回</span><br>          res.end(langs[name]);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>      res.end(langs[defualtLanguage]); <span class="hljs-comment">// 默认语言</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.end(langs[defualtLanguage]); <span class="hljs-comment">// 默认语言</span><br>    &#125;<br>  &#125;)<br>  .listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>测试：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600520929754-4346b8fd-56db-418d-9f2b-b96c6fd3b4d7.webp#align=left&display=inline&height=869&margin=%5Bobject%20Object%5D&originHeight=869&originWidth=1280&size=0&status=done&style=none&width=1280"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请求头与响应头在前后端联调时会经常使用。了解了他们的妙用前后端配合会更加和谐顺畅~</p><blockquote><p>Author: Yanni Jia<br>Nickname: 非常兔<br>Email: <a href="mailto:385067638@qq.com">385067638@qq.com</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见的请求状态码</title>
    <link href="/2020/09/19/yuque/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2020/09/19/yuque/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h1><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational(信息性状态码)</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success(成功状态码)</td><td align="center">请求正在处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection(重定向状态码)</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error(客户端错误状态码)</td><td align="center">客户端错误，请求包含语法错误或服务器无法完成请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error(服务器错误状态码)</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h1 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h1><h2 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h2><p>表明目前为止都很正常，客户端可以继续发送请求或忽略这个响应</p><h1 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h1><h2 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h2><p>从客户端发来的请求在服务器被正常处理了</p><h1 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h1><h2 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h2><p>永久性重定向。<br>请求的资源已经被分配新的 URI。<br>旧资源已经被永久的移除。</p><h2 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h2><p>临时重定向。<br>请求的资源已被分配了新的 URI(暂时)，希望用户(本次)能使用新的 URI 访问。</p><h2 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h2><p>客户端发送附带条件的请求(GET)，服务器找到请求的资源，但不符合请求的条件。</p><h1 id="4XX-客户端错误，请求包含语法错误或服务端无法完成请求"><a href="#4XX-客户端错误，请求包含语法错误或服务端无法完成请求" class="headerlink" title="4XX 客户端错误，请求包含语法错误或服务端无法完成请求"></a>4XX 客户端错误，请求包含语法错误或服务端无法完成请求</h1><h2 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h2><p>请求报文中存在语法错误。服务器无法理解<br>需要修改请求的内容后再次发送请求。<br>浏览器会像 200 OK 一样对待改状态码。</p><h2 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h2><p>发送的请求需要有通过 HTTP 认证(BASIC 认证，DIGEST 认证)的认证信息。<br>第一次接收：弹出认证用对话窗口（例如输入账号密码）<br>之后接收：用户认证失败</p><h2 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h2><p>请求资源的访问被服务器拒绝。</p><h2 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h2><p>服务器上无法找到请求的资源。</p><h1 id="5XX-服务器处理请求出错"><a href="#5XX-服务器处理请求出错" class="headerlink" title="5XX 服务器处理请求出错"></a>5XX 服务器处理请求出错</h1><h2 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h2><p>服务器执行请求时发生了错误。<br>也有可能是 Web 应用存在 bug 或某些临时的故障。</p><h2 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h2><p>服务器暂时处于超复杂或正在进行停机维护，现在无法处理请求。<br>若事先得知解除以上状况所需要的时间，最好写入 Retry-After 首部字段返回给客户端。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="/2020/09/19/yuque/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/09/19/yuque/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903800336023560">https://juejin.im/post/6844903800336023560</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络协议是每个前端工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。**</p><h2 id="一、TCP-IP-网络模型"><a href="#一、TCP-IP-网络模型" class="headerlink" title="一、TCP/IP 网络模型"></a>一、TCP/IP 网络模型</h2><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。<br>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。<br>TCP/IP 模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装 IP 报文，发送和接受 ARP/RARP 报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS、SMTP 等。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518415754-0ad394fc-52bb-4f1d-818e-ede41fea69c3.webp#align=left&display=inline&height=400&margin=%5Bobject%20Object%5D&originHeight=400&originWidth=1033&size=0&status=done&style=none&width=1033"><br>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍 TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h2 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h2><p>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。<br>它有以下几个特点：</p><h3 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1.面向无连接"></a>1.面向无连接</h3><p>首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><h3 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2.有单播，多播，广播的功能"></a>2.有单播，多播，广播的功能</h3><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h3 id="3-UDP-是面向报文的"><a href="#3-UDP-是面向报文的" class="headerlink" title="3.UDP 是面向报文的"></a>3.UDP 是面向报文的</h3><p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h3 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4.不可靠性"></a>4.不可靠性</h3><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/1639155/1600518415735-008c0141-7724-4d04-b117-bcb43bb0bf26.gif#align=left&display=inline&height=233&margin=%5Bobject%20Object%5D&originHeight=233&originWidth=451&size=0&status=done&style=none&width=451">从上面的动态图可以得知，UDP 只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p><h3 id="5-头部开销小，传输数据报文时是很高效的。"><a href="#5-头部开销小，传输数据报文时是很高效的。" class="headerlink" title="5.头部开销小，传输数据报文时是很高效的。"></a>5.头部开销小，传输数据报文时是很高效的。</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518415702-483bc67b-be6f-49de-90f9-f09e1111e556.webp#align=left&display=inline&height=110&margin=%5Bobject%20Object%5D&originHeight=110&originWidth=678&size=0&status=done&style=none&width=678">UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h2 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h2><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 TCP。<br>TCP 协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h3 id="1-TCP-连接过程"><a href="#1-TCP-连接过程" class="headerlink" title="1.TCP 连接过程"></a>1.TCP 连接过程</h3><p>如下图所示，可以看到建立一个 TCP 连接的过程为（三次握手的过程）:<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518415751-7e5becd4-24ef-4e06-a2aa-e4762b2df582.webp#align=left&display=inline&height=344&margin=%5Bobject%20Object%5D&originHeight=344&originWidth=553&size=0&status=done&style=none&width=553"><br><strong>第一次握手</strong><br>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br><strong>第二次握手</strong><br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br><strong>第三次握手</strong><br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。<br>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/1639155/1600518586856-408a5910-d0c6-455d-afff-f9cf2e5fbba3.gif#align=left&display=inline&height=233&margin=%5Bobject%20Object%5D&originHeight=233&originWidth=451&size=0&status=done&style=none&width=451"></p><h3 id="2-TCP-断开链接"><a href="#2-TCP-断开链接" class="headerlink" title="2.TCP 断开链接"></a>2.TCP 断开链接</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518586766-c3688c6a-9936-4d6e-924a-7e55ef56d875.webp#align=left&display=inline&height=414&margin=%5Bobject%20Object%5D&originHeight=414&originWidth=553&size=0&status=done&style=none&width=553"><br>TCP 是<strong>全双工</strong>的，在断开连接时两端都需要发送 FIN 和 ACK。<br><strong>第一次握手</strong><br>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次握手</strong><br>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次握手</strong><br>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br><strong>第四次握手</strong><br>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h3 id="3-TCP-协议的特点"><a href="#3-TCP-协议的特点" class="headerlink" title="3.TCP 协议的特点"></a>3.TCP 协议的特点</h3><ul><li>面向连接</li></ul><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><ul><li>仅支持单播传输</li></ul><p>每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li>面向字节流</li></ul><p>TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ul><li>可靠传输</li></ul><p>对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><ul><li>提供拥塞控制</li></ul><p>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li>TCP 提供全双工通信</li></ul><p>TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）</p><h2 id="四、TCP-和-UDP-的比较"><a href="#四、TCP-和-UDP-的比较" class="headerlink" title="四、TCP 和 UDP 的比较"></a>四、TCP 和 UDP 的比较</h2><h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1.对比"></a>1.对比</h3><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅 8 字节</td><td>首部最小 20 字节，最大 60 字节</td></tr><tr><td>适用场景</td><td>适用于实时应用（IP 电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><ul><li>TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用 TCP</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对称加密和非对称加密</title>
    <link href="/2020/09/19/yuque/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <url>/2020/09/19/yuque/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844903950513078280">https://juejin.im/post/6844903950513078280</a></p><p>加密在编程中的应用的是非常广泛的，尤其是在各种网络协议之中，对称/非对称加密则是经常被提及的两种加密方式。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>我们平时碰到的绝大多数加密就是对称加密，比如：指纹解锁，PIN 码锁，保险箱密码锁，账号密码等都是使用了对称加密。</p><blockquote><p>对称加密：加密和解密用的是同一个密码或者同一套逻辑的加密方式。</p></blockquote><p>这个密码也叫对称秘钥，其实这个对称和不对称指的就是<strong>加密和解密用的秘钥是不是同一个</strong>。<br>我在上大学的时候做过一个命令行版的图书馆管理系统作为 C 语言课设。登入系统时需要输入账号密码，当然，校验用户输入的密码本身就是一种对称加密，<strong>用户必须输入的密码必须和你之前设置的账号密码相同</strong>。<br>当时我选择将账号密码存放在本地文件中，但是如果这个文件被窃取了，而且没有对密码本身进行加密的话密码就泄露了。那么如何对存储在文件中的密码进行加密呢？我当时采取的方式（也可以理解为一种加密算法）是：将用户设置的账号密码的每一个字符取它的码值然后加上一个固定的值比如 6，然后存储的时候存储计算后的码值字符串。用 js 来模拟一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 加密用户密码过程</span><br><span class="hljs-keyword">const</span> sourcePassword = <span class="hljs-string">&#x27;abcdef&#x27;</span>; <span class="hljs-comment">// 用户账号密码</span><br><span class="hljs-comment">// 加密后的存储在本地文件的账号密码</span><br><span class="hljs-keyword">const</span> encryptedPassword = [...sourcePassword].map(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> char.codePointAt(<span class="hljs-number">0</span>) + <span class="hljs-number">6</span>).join();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`加密后的账号密码是：<span class="hljs-subst">$&#123;encryptedPassword&#125;</span>`</span>) <span class="hljs-comment">// =&gt; 加密后的账号密码是：103,104,105,106,107,108</span><br><span class="hljs-comment">// 解密过程</span><br><span class="hljs-keyword">const</span> decryptedPassword = encryptedPassword.split(<span class="hljs-string">&#x27;,&#x27;</span>).map(<span class="hljs-function">(<span class="hljs-params">codePoint</span>) =&gt;</span> <span class="hljs-built_in">String</span>.fromCodePoint(codePoint - <span class="hljs-number">6</span>)).join(<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`解密后的账号密码是：<span class="hljs-subst">$&#123;decryptedPassword&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 解密后的账号密码是：abcdef</span><br>复制代码<br></code></pre></td></tr></table></figure><p>上面对用户账号密码加密的过程虽然没有明显涉及到用于加密的密码，但是加密解密用的都是<strong>同一套逻辑</strong>：取字符的 ascii 码值加 6，其实这也是对称加密。其实也可以理解为加密密码就是加密算法本身，知道了加密算法就能解码出账号密码。<br>有些软件支持对数据进行加密如 rar 加密的时候需要你输入密码，然后解密的时候需要我们输入设置的加密密码。其实回到到我上面说的那个很简单的加密算法，系统可以设计成让用户可以设置一个用于加密账号密码的加密密码。这里简化为一个数字，然后系统在存储用户账号密码的时候就不是像之前那样每个用户都是加上固定的 6 了，而是加上用户设置的这个数字。现在你这个加密逻辑就可以像 rar 公开压缩算法那样公开，即便是被攻击者知道了加密算法和加密后的账号密码，如果不知道加密密码还是无法获取用户账号密码。这里的加密密码和解密密码用的都是<strong>同一个密码</strong>，对应到上面那个系统就是 6，所以也是对称加密。</p><h3 id="使用-nodejs-来进行对称加密"><a href="#使用-nodejs-来进行对称加密" class="headerlink" title="使用 nodejs 来进行对称加密"></a>使用 nodejs 来进行对称加密</h3><p>nodejs 的 crypto 模块是一个专门用于各种加密的模块，可以用来取摘要（hash），加盐摘要（hmac），对称加密，非对称加密等。使用 crypto 进行对称加密很简单，crypto 模块提供了 Cipher 类用于加密数据，Decipher 用于解密。<br>常见的对称加密算法有<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">DES</a>、<a href="https://zh.wikipedia.org/wiki/3DES">3DES</a>、<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES</a>、<a href="https://zh.wikipedia.org/wiki/Blowfish_(%E5%AF%86%E7%A0%81%E5%AD%A6)">Blowfish</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">IDEA</a>、<a href="https://zh.wikipedia.org/wiki/RC5">RC5</a>、<a href="https://zh.wikipedia.org/wiki/RC6">RC6，</a>这里演示下使用 AES 算法进行对称加密。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对称加密字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>password 用于对称加密的秘钥</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>string 被加密的数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;String&#125;</span> </span>encryptedString 加密后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> encrypt = <span class="hljs-function">(<span class="hljs-params">password, <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 使用的对称加密算法是：aes-192-cbc</span><br>  <span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">&#x27;aes-192-cbc&#x27;</span>;<br>  <span class="hljs-comment">// 生成对称加密秘钥，salt 用于生成秘钥，24 指定秘钥长度是 24 位</span><br>  <span class="hljs-keyword">const</span> key = crypto.scryptSync(password, <span class="hljs-string">&#x27;salt&#x27;</span>, <span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;key:&#x27;</span>, key); <span class="hljs-comment">// =&gt; key: &lt;Buffer f0 ca 6c ac 39 3c b3 f9 77 13 0d d9 bc cb dd 9d 86 f7 96 e0 75 53 7f 8a&gt;</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`秘钥长度： <span class="hljs-subst">$&#123;key.length&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 秘钥长度： 24</span><br>  <span class="hljs-comment">// 初始化向量</span><br>  <span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 获得 Cipher 加密类</span><br>  <span class="hljs-keyword">const</span> cipher = crypto.createCipheriv(algorithm, key, iv);<br>  <span class="hljs-comment">// utf-8 指定被加密的数据字符编码，hex 指定输出的字符编码</span><br>  <span class="hljs-keyword">let</span> encryptedString = cipher.update(<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-string">&#x27;hex&#x27;</span>);<br>  encryptedString += cipher.final(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>  <span class="hljs-keyword">return</span> encryptedString;<br>&#125;;<br><span class="hljs-keyword">const</span> PASSWORD = <span class="hljs-string">&#x27;lyreal666&#x27;</span>;<br><span class="hljs-keyword">const</span> encryptedString = encrypt(PASSWORD, <span class="hljs-string">&#x27;天分不够努力来凑&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`加密后的数据是：<span class="hljs-subst">$&#123;encryptedString&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 加密后的数据是：1546756bb4e530fc1fbae7fd2cf9aeac0368631b54581a39e5c53ee3172638de </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解密字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>password 加密密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>encryptedString 加密后的字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;String&#125;</span> </span>decryptedString 解密后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> decrypt = <span class="hljs-function">(<span class="hljs-params">password, encryptedString</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">&#x27;aes-192-cbc&#x27;</span>;<br>  <span class="hljs-comment">// 采用相同的算法生成相同的秘钥</span><br>  <span class="hljs-keyword">const</span> key = crypto.scryptSync(password, <span class="hljs-string">&#x27;salt&#x27;</span>, <span class="hljs-number">24</span>);<br>  <span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 生成 Decipher 解密类</span><br>  <span class="hljs-keyword">const</span> decipher = crypto.createDecipheriv(algorithm, key, iv);<br>  <span class="hljs-keyword">let</span> decryptedString = decipher.update(encryptedString, <span class="hljs-string">&#x27;hex&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>  decryptedString += decipher.final(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br>  <span class="hljs-keyword">return</span> decryptedString;<br>&#125;;<br><span class="hljs-keyword">const</span> decryptedString = decrypt(PASSWORD, encryptedString);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`解密后的数据时：<span class="hljs-subst">$&#123;decryptedString&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 解密后的数据时：天分不够努力来凑</span><br>复制代码<br></code></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密用的是一对秘钥，分别叫做公钥（public key）和私钥（private key），也叫非对称秘钥。非对称秘钥既可以用于加密还可以用于认证，咱先聊加密。</p><blockquote><p>加密有一个密码就行了，为啥要整个非对称加密要两个密码呢？<br>黑人问号.jpg</p></blockquote><p>我相信肯定会有人和我一样有过这样的想法。其实对称加密只要保证加密的密码长度足够长的话，被加密的数据在拿不到密码本身的情况下一般是安全的。但是有个问题就是在实际应用中比如加密网络数据，因为加密和解密使用的是同一个秘钥，所以，服务器和客户端必然是要交换秘钥的，而正是因为非对称秘钥由于有一个交换秘钥这一过程可能会被中间人窃取秘钥，一旦对称加密秘钥被窃取，而且被分析出加密算法的话，那么传输的数据对于中间人来说就是透明的。所以<strong>对称加密的致命性缺点就是无法保证秘钥的安全性</strong>。<br>那么非对称加密就能保证秘钥的安全性了吗？是的，秘钥可以大胆的公开，被公开的秘钥就叫公钥。非对称加密的秘钥由加密算法计算得出，是成对的，<strong>可以被公开的那个秘钥称之为公钥</strong>，<strong>不能公开的那个私有的秘钥叫私钥</strong>。<br>在使用 github 等 git 仓库托管平台的时候，我们一般都会配置 ssh 公钥，生成一对秘钥我们可以采用下面的命令：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518228786-b1f15ada-a6e4-4d9f-a4c0-82b9e4574147.webp#align=left&display=inline&height=702&margin=%5Bobject%20Object%5D&originHeight=702&originWidth=1280&size=0&status=done&style=none&width=1280"><br>上面使用 <code>ssh-keygen</code> 程序指定加密算法为 rsa，在当前目录生成一对秘钥 <code>key</code>，<code>key.pub</code>。<code>key</code> 是私钥，<code>key.pub</code> 是公钥，后缀 pub 全拼明显是 public 嘛。来看一下生成的具体内容：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1600518228804-d117bbc5-67f4-4ca7-a0ba-7083d8578704.webp#align=left&display=inline&height=626&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=1280&size=0&status=done&style=none&width=1280"><br>这个 key.pub 是个公钥，公钥就是被设计来可以随意公开的。我们把这个公钥配置到托管平台，就可以不用每次和 github 通信都要输入密码了。<br>这对公私钥有一个特点，同时也是非对称加密为什么安全的关键就是：<strong>使用秘钥对中的一个秘钥加密，加密后的数据只能通过另一个秘钥解密</strong>。也就是说使用一对秘钥中的公钥加密数据，只能通过另一个私钥解密出数据。或者反过来，使用一对秘钥中的私钥进行加密的数据，只能通过另一个公钥解密出来。由此可见，从加密的角度来看，公钥和私钥其实作用是等同的，都可以用于加密或解密，只不过当我们使用非对称秘钥用于加密数据时往往是用公钥进行加密。<br>在 https 的加密中，加密传输的数据本身使用的是对称加密，加密对称秘钥时使用的非对称加密。整个过程是这样的：server 端先生成一对非对称秘钥，将可以公开的公钥发送给 client 端，client 端也决定此次数据传输使用的对称加密算法和对称秘钥，然后利用 server 端给的公钥，对对称秘钥进行加密传输。server 端接受到 client 端发送的对称加密算法和秘钥后，server 端和 client 端的数据传输都使用这个对称秘钥和算法进行对称加密。整个过程中即便 server 端的公钥被中间人知道了内容，但是没有保存在 server 端的私钥，你是无法破译使用公钥加密的对称秘钥的。公钥原本就是可以被随意公开的，拿到也没用，解密需要的是私钥。非对称加密或者说公钥加密之所以能保证加密安全就是因为<strong>私钥是保密不公开的，攻击者没有私钥无法破译</strong>。<br>可能会有人有疑问：为什么需要使用非对称加密对对称秘钥加密呢？那是因为交换对称秘钥时可能被第三方窃取，对称秘钥被窃取了那对称加密就没意义了。还有为什么不直接使用非对称加密来加密传输内容而只是加密对称秘钥？非对称加密不是对称加密更安全吗？这就和对称加密与非对称加密的特点有关系了。</p><h3 id="非对称加密和对称加密对比"><a href="#非对称加密和对称加密对比" class="headerlink" title="非对称加密和对称加密对比"></a>非对称加密和对称加密对比</h3><ol><li>对称加密是一个秘钥，非对称加密是一对，两个秘钥</li><li>非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系</li><li>由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多</li><li>非对称秘钥还可以用于认证</li></ol><p>由于以上第三条，所以在 https 中传输数据时不会使用非对称加密加密传输数据，传输数据时有可能数据本身很大，那样的话非对称加密更耗时了，所以传输数据时不会使用非对称加密的方式加密。</p><h3 id="使用-nodejs-演示非对称加密"><a href="#使用-nodejs-演示非对称加密" class="headerlink" title="使用 nodejs 演示非对称加密"></a>使用 nodejs 演示非对称加密</h3><p>常见的非对称加密有 RSA、ECC（椭圆曲线加密算法）、Diffie-Hellman、El Gamal、DSA（数字签名用），这里演示一下 RSA 加密。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><span class="hljs-comment">// 秘钥加密短语</span><br><span class="hljs-keyword">const</span> passphrase = <span class="hljs-string">&#x27;lyreal666&#x27;</span>;<br><span class="hljs-comment">// rsa 指定非对称秘钥算法为 rsa</span><br><span class="hljs-keyword">const</span> &#123; publicKey, privateKey &#125; = crypto.generateKeyPairSync(<span class="hljs-string">&#x27;rsa&#x27;</span>, &#123;<br>  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">4096</span>, <span class="hljs-comment">// 指定秘钥长度</span><br>  <span class="hljs-attr">publicKeyEncoding</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;spki&#x27;</span>, <span class="hljs-comment">// 公钥编码格式</span><br>    <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;pem&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">privateKeyEncoding</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;pkcs8&#x27;</span>, <span class="hljs-comment">// 私钥编码格式</span><br>    <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;pem&#x27;</span>,<br>    <span class="hljs-attr">cipher</span>: <span class="hljs-string">&#x27;aes-256-cbc&#x27;</span>,<br>    passphrase,<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用公钥加密</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>publicKey 用于对称加密的秘钥</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>string 被加密的数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;String&#125;</span> </span>encryptedString 加密后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> encrypt = <span class="hljs-function">(<span class="hljs-params">publicKey, <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 使用公钥加密</span><br>  <span class="hljs-keyword">return</span> crypto.publicEncrypt(&#123; <span class="hljs-attr">key</span>: publicKey, passphrase &#125; , Buffer.from(<span class="hljs-built_in">string</span>)).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用私钥解密字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>privateKey 私钥</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>encryptedString 加密后的字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;String&#125;</span> </span>decryptedString 解密后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> decrypt = <span class="hljs-function">(<span class="hljs-params">privateKey, encryptedString</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> crypto.privateDecrypt(&#123; <span class="hljs-attr">key</span>: privateKey, passphrase &#125; , Buffer.from(encryptedString, <span class="hljs-string">&#x27;hex&#x27;</span>));<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;说好不哭，不爱我就拉倒ヽ(｀⌒´)ﾉ&#x27;</span>;<br><span class="hljs-keyword">const</span> encryptedString = encrypt(publicKey, <span class="hljs-built_in">string</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`公钥加密后的结果：<span class="hljs-subst">$&#123;encryptedString&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 公钥加密后的结果：caf7535c46146f5...</span><br><span class="hljs-keyword">const</span> decryptedString = decrypt(privateKey, encryptedString);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`私钥解密后的结果：<span class="hljs-subst">$&#123;decryptedString&#125;</span>`</span>); <span class="hljs-comment">// =&gt; 私钥解密后的结果：说好不哭，不爱我就拉倒ヽ(｀⌒´)ﾉ </span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="非对称密钥认证"><a href="#非对称密钥认证" class="headerlink" title="非对称密钥认证"></a>非对称密钥认证</h3><p>非对称加密有时也叫<strong>公钥加密</strong>，而非对称秘钥认证也被称为<strong>私钥认证</strong>。我们说使用非对称秘钥对数据进行认证其实就是说确认一个数据是否有没有被篡改过。非对称秘钥除了用于加密数据，用于认证也是非常广泛的，比如手机 apk 的签名， https 中的证书。<br>原理很简单：比如现在我要认证一个 apk 的代码是否被串改过，首先准备一对非对称秘钥，一般来自权威机构。官方在打包 apk 时不但包含应用代码，还带上一个签名，这个签名这里简单理解为使用私钥对应用代码的 hash 值加密后的数据。在安装 apk 时，android 系统会提取 apk 中的签名，使用公钥解密签名得到原始应用代码的 hash，然后和原始应用代码的 hash 进行比对，如果内容相同，那么 apk 没有被篡改过。如果 apk 的应用代码被第三方修改了，那么从签名中解密出来的 hash 和应用代码的 hash 肯定是不同的。所以可以起到确保应用代码没有篡改，也就是<strong>认证</strong>。<br>认证的关键其实是因为签名的存在，签名必须保证能拿到 apk 原始应用代码的 hash。至于如何保证签名没有被篡改不在本文讨论范围。<br>可能有人看了上面对 apk 认证的过程会有这么一个疑问：使用私钥对内容加密可以达到认证的目的，那能不能使用公钥加密来认证呢？<br>答案肯定是不能的，如果你使用公钥对内容进行加密，那中间人要篡改你的内容，伪造签名超简单，直接使用公钥对伪造后的内容的 hash 加密就可以了。所以使用非对称秘钥可以用于认证的另一个关键就是私钥是不公开的，中间人没法获取私钥，也就没法伪造签名。</p><h2 id="几个疑问"><a href="#几个疑问" class="headerlink" title="几个疑问"></a>几个疑问</h2><h3 id="hash-算是加密吗？"><a href="#hash-算是加密吗？" class="headerlink" title="hash 算是加密吗？"></a>hash 算是加密吗？</h3><p>我觉得不算，hash 是不可逆的，加密应该是可以根据加密后的数据还原的。</p><h3 id="base-64-算是加密吗？"><a href="#base-64-算是加密吗？" class="headerlink" title="base 64 算是加密吗？"></a>base 64 算是加密吗？</h3><p>是对称加密，对称秘钥就是 base 64 字符码表。</p><h3 id="非对称加密绝对安全吗？"><a href="#非对称加密绝对安全吗？" class="headerlink" title="非对称加密绝对安全吗？"></a>非对称加密绝对安全吗？</h3><p>没有什么加密是绝对安全的，非对称加密存在交换公钥时公钥被篡改的问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>了解TCP、UDP、TLS</title>
    <link href="/2020/09/19/yuque/%E4%BA%86%E8%A7%A3TCP%E3%80%81UDP%E3%80%81TLS/"/>
    <url>/2020/09/19/yuque/%E4%BA%86%E8%A7%A3TCP%E3%80%81UDP%E3%80%81TLS/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.2">https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.2</a><br>了解一点底层网络通信原理，对日常工作有很大的帮助，减少与后端工程师的“日常沟通摩擦”，增强共鸣和互信与理解。而在面试过程中，很多公司会考察前端工程师的知识广度，TCP/IP、TCP、UDP、TLS 是被高频问到的。<br>TCP/IP 协议是一个协议集，里面包括很多协议的，TCP、UDP、TLS 等只是其中的协议。<br>TCP/IP 协议集包括<strong>应用层</strong>，<strong>传输层</strong>，<strong>网络层</strong>，<strong>网络访问层</strong>。<br>应用层包括：</p><ul><li><p>超文本传输协议(HTTP)：万维网的基本协议；</p></li><li><p>文件传输(TFTP 简单文件传输协议)；</p></li><li><p>远程登录(Telnet)，提供远程访问其它主机功能，它允许用户登录；</p></li><li><p>internet 主机，并在这台主机上执行命令；</p></li><li><p>网络管理(SNMP 简单网络管理协议)，该协议提供了监控网络设备的方法，以及配置管理,统计信息收集，性能管理及安全管理等；</p></li><li><p>域名系统(DNS)，该系统用于在 internet 中将域名及其公共广播的网络节点转换成 IP 地址。</p></li></ul><p>传输层包括：</p><ul><li>TLS，也即 SSL(Secure Sockets Layer，安全套接字层)协议，后来 IETF 在标准化 SSL 协议时，将其改名为 Transport Layer Security（TLS，传输层安全）。</li></ul><p>网络层包括：</p><ul><li><p>Internet 协议(IP)</p></li><li><p>Internet 控制信息协议(ICMP)</p></li><li><p>地址解析协议(ARP)</p></li><li><p>反向地址解析协议(RARP)** **</p></li></ul><p>网络访问层：</p><ul><li>网络访问层又称作主机到网络层(host-to-network)。网络访问层的功能包括 IP 地址与物理地址硬件的映射，以及将 IP 封装成帧。基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接。</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h1><table><thead><tr><th align="left">术语</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SYN</td><td align="left">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1。</td></tr><tr><td align="left">ACK</td><td align="left">确认号是否有效，一般置为 1。</td></tr><tr><td align="left">FIN</td><td align="left">希望断开连接。</td></tr><tr><td align="left">URG</td><td align="left">紧急指针是否有效。为 1，表示某一位需要被优先处理。</td></tr><tr><td align="left">PSH</td><td align="left">提示接收端应用程序立即从 TCP 缓冲区把数据读走。</td></tr><tr><td align="left">RST</td><td align="left">对方要求重新建立连接，复位。</td></tr></tbody></table><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1600517087824-9ab36a57-1a17-42f8-b2be-2bae27213b8e.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=566&size=0&status=done&style=none&width=566"><br>如上图，三次握手分别是：</p><ol><li><p><strong>SYN</strong>客户端选择一个随机序列号 x，并发送一个 SYN 数据包，其中可能还包括其他 TCP 标志和选项。</p></li><li><p><strong>SYN ACK</strong>服务器给 x 加 1，并选择自己的一个随机序列号 y，追加自己的标志和选项，然后返回响应。</p></li><li><p><strong>ACK</strong>客户端给 x 和 y 加 1 并发送握手期间的最后一个 ACK 数据包。</p></li></ol><h2 id="握手对延迟的影响"><a href="#握手对延迟的影响" class="headerlink" title="握手对延迟的影响"></a><strong>握手对延迟的影响</strong></h2><p>三次握手完成后，客户端与服务器之间就可以通信了。客户端可以在发送 ACK 分组之后立即发送数据，而服务器必须等接收到 ACK 分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接，因此对所有使用 TCP 的应用具有非常大的性能影响，因为每次传输应用数据之前，都必须经历一次完整的往返。<br>举个例子，如果客户端在纽约，服务器在伦敦，要通过光纤启动一次新的 TCP 连接，光握手至少就要花 56 ms：向伦敦发送分组需要 28 ms，响应发回纽约又要 28 ms。在此，连接的带宽对时间没有影响，延迟完全取决于客户端和服务器之间的往返时间，这其中主要是纽约到伦敦之间的传输时间。 三次握手带来的延迟使得每创建一个新 TCP 连接都要付出很大代价。而这也决定了提高 TCP 应用性能的关键，在于想办法重用连接。<br>重用 TCP 连接有一个方案叫“TCP Fast Open”（TFO），Linux 3.7 及之后的内核已经在客户端和服务器中支持 TFO，具体内容可以查阅<a href="https://tools.ietf.org/html/rfc7413">IETF 规范</a>。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><a href="https://juejin.im/post/6844903625513238541">跟着动画来学习 TCP 三次握手和四次挥手</a></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="**常见面试题 **"></a>**常见面试题 **</h2><h3 id="1-为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#1-为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="1.为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a><strong>1.为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></h3><p>答：因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p><h3 id="2-为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态？"><a href="#2-为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态？" class="headerlink" title="2.为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？"></a><strong>2.为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？</strong></h3><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p><h3 id="3-为什么不能用两次握手进行连接？"><a href="#3-为什么不能用两次握手进行连接？" class="headerlink" title="3.为什么不能用两次握手进行连接？"></a><strong>3.为什么不能用两次握手进行连接？</strong></h3><p>答：3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h3 id="4-如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#4-如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="4.如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>4.如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></h3><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h1><p>1980 年 8 月，<strong>UDP（User Datagram Protocol，用户数据报协议）</strong>被 John Postel 加入了核心网络协议套件。UDP 的主要功能和亮点并不在于它引入了什么特性，而在于它忽略的那些特性。UDP 经常被称为无（Null）协议，RFC 768 描述了其运作机制，全文完全可以写在一张餐巾纸上。</p><h2 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a><strong>数据报</strong></h2><p>数据报（Datagram）为一个完整、独立的数据实体，携带着从源节点到目的地节点的足够信息，对这些节点间之前的数据交换和传输网络没有任何依赖。 数据报（datagram）和数据包（packet）是两个经常被人混用的词，实际上它们还是有区别的。数据包可以用来指代任何格式化的数据块，而数据报则通常只用来描述那些通过不可靠的服务传输的数据包，既不保证送达，也不发送失败通知。正因为如此，很多场合下人们都把 UDP 中 User（用户）的 U，改成 Unreliable（不可靠）的 U，于是 UDP 就成了“不可靠数据报协议”（Unreliable Datagram Protocol）。这也是为什么把 UDP 数据包称为数据报更为恰当的原因。</p><h2 id="UDP-的“无协议”是怎么回事呢？"><a href="#UDP-的“无协议”是怎么回事呢？" class="headerlink" title="UDP 的“无协议”是怎么回事呢？"></a><strong>UDP 的“无协议”是怎么回事呢？</strong></h2><p>要理解为什么 UDP 被人称作“无协议”，必须从作为 TCP 和 UDP 下一层的 IP 协议说起。<br>IP 层的主要任务就是按照地址从源主机向目标主机发送数据报（Datagram）。为此，消息会被封装在一个 IP 分组内（如下图），其中载明了源地址和目标地址，以及其他一些路由参数。</p><blockquote><p>注意，数据报这个词暗示了一个重要的信息：IP 层不保证消息可靠的交付，也不发送失败通知，实际上是把底层网络的不可靠性直接暴露给了上一层。</p></blockquote><p>如果某个路由节点因为网络拥塞、负载过高或其他原因而删除了 IP 分组，那么在必要的情况下，IP 的上一层协议要负责检测、恢复和重发数据。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1600517087457-c9cdb195-61d9-4b54-b078-b9c00ceb3e37.jpeg#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=566&size=0&status=done&style=none&width=566"><br>IPV4 首部<br>而 UDP 协议会用自己的分组结构（如下图）封装用户消息，它只增加了 4 个字段：源端口、目标端口、分组长度和校验和。这样，当 IP 把分组送达目标主机时，该主机能够拆开 UDP 分组，根据目标端口找到目标应用程序，然后再把消息发送过去。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1600517089879-6a62e434-a8a9-42e2-a485-645131c51435.jpeg#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=566&size=0&status=done&style=none&width=566"><br>UDP 首部<br>事实上，UDP 数据报中的源端口和校验和字段都是可选的。IP 分组的首部也有校验和，应用程序可以忽略 UDP 校验和。也就是说，所有错误检测和错误纠正工作都可以委托给上层的应用程序。说到底，UDP 仅仅是在 IP 层之上通过嵌入应用程序的源端口和目标端口，提供了一个“应用程序多路复用”机制。明白了这一点，就可以总结一下 UDP 的无服务是怎么回事了：</p><ol><li><p><strong>不保证消息交付</strong>不确认，不重传，无超时。_ _</p></li><li><p><strong>不保证交付顺序</strong>不设置包序号，不重排，不会发生队首阻塞。</p></li><li><p><strong>不跟踪连接状态</strong>不必建立连接或重启状态机。</p></li><li><p><strong>不需要拥塞控制</strong>不内置客户端或网络反馈机制。</p></li></ol><h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a><strong>应用场合</strong></h2><p>TCP 是一个面向字节流的协议，能够以多个分组形式发送应用程序消息，且对分组中的消息范围没有任何明确限制。因此，TCP 连接的两端存在一个连接状态，每个分组都有序号，丢失还要重发，并且要按顺序交付。相对来说，UDP 数据报有明确的限制：数据报必须封装在 IP 分组中，应用程序必须读取完整的消息。换句话说，数据报不能分片。<br>UDP 是一个简单、无状态的协议，适合作为其他上层应用协议的辅助。实际上，这个协议的所有决定都需要由上层的应用程序作出。<br>有些应用程序可能并不需要可靠的交付或者不需要按顺序交付。比如，每个分组都是独立的消息，那么按顺序交付就没有任何必要。而且，如果每个消息都会覆盖之前的消息，那么可靠交付同样也没有必要了。可惜的是，TCP 不支持这种情况，所有分组必须按顺序交付。<br>无需按序交付数据或能够处理分组丢失的应用程序，以及对延迟或抖动要求很高的应用程序，最好选择 UDP 等协议。</p><h1 id="TLS-1-2"><a href="#TLS-1-2" class="headerlink" title="TLS 1.2"></a><strong>TLS 1.2</strong></h1><p>Netscape（网景公司） 在 1994 年时提出了 SSL 协议的原始规范， TLS 协议也经过了很多次版本的更新。目前低版本的 TLS （例如：SSL 3.0/TLS 1.0 等）存在许多严重漏洞。另外根据 Nist（美国国家标准与技术研究院）所说，现在没有补丁或修复程序能够充分修复低版本 TLS 的漏洞，尽快升级到高版本的 TLS 是最好的方法。<br>目前行业正处于 TLS 1.2 取代 TLS 1/1.1 的过渡时期，将来会有越来越多的互联网安全企业启用 TLS 1.2。它引入了 SHA-256 哈希算法，摒弃了 SHA-1，对增强数据完整性有着显著优势。</p><h2 id="TLS-的四次握手"><a href="#TLS-的四次握手" class="headerlink" title="TLS 的四次握手"></a><strong>TLS 的四次握手</strong></h2><p>客户端与服务器在通过 TLS 交换数据之前，必须协商建立加密信道。协商内容包括 TLS 版本、加密套件，必要时还会验证证书。然而，协商过程的每一步都需要一个分组在客户端和服务器之间往返一次（如下图，绿色部分代表 TLS 的四次握手），因而所有 TLS 连接启动时都要经历一定的延迟。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1600517087441-3af4dfd4-551f-4ebf-a69f-d20d22a786e7.jpeg#align=left&display=inline&height=432&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=566&size=0&status=done&style=none&width=566"></p><h2 id="详细解说如下"><a href="#详细解说如下" class="headerlink" title="详细解说如下"></a><strong>详细解说如下</strong></h2><h3 id="1-客户端发出请求（ClientHello）"><a href="#1-客户端发出请求（ClientHello）" class="headerlink" title="1.客户端发出请求（ClientHello）"></a><strong>1.客户端发出请求（ClientHello）</strong></h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。在这一步，客户端主要向服务器提供以下信息：</p><ul><li><p>支持的协议版本，比如 TLS 1.0 版。</p></li><li><p>一个客户端生成的随机数，稍后用于生成“对话密钥”。</p></li><li><p>支持的加密方法，比如 RSA 公钥加密。</p></li><li><p>支持的压缩方法。</p></li></ul><h3 id="2-服务器回应（SeverHello）"><a href="#2-服务器回应（SeverHello）" class="headerlink" title="2.服务器回应（SeverHello）"></a><strong>2.服务器回应（SeverHello）</strong></h3><ul><li><p>确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p></li><li><p>确认使用的加密方法，比如 RSA 公钥加密，返回加密公钥。</p></li><li><p>服务器证书。</p></li></ul><h3 id="3-客户端回应"><a href="#3-客户端回应" class="headerlink" title="3.客户端回应"></a><strong>3.客户端回应</strong></h3><ul><li><p>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</p></li><li><p>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</p></li><li><p>使用约定好的 HASH 计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p></li></ul><h3 id="4-服务器"><a href="#4-服务器" class="headerlink" title="4.服务器"></a><strong>4.服务器</strong></h3><ul><li><p>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。</p></li><li><p>使用密码加密一段握手消息内容为”Finished”，发送给浏览器。</p></li></ul><h1 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a><strong>TLS 1.3</strong></h1><p>2018 年 8 月份，IETF 正式宣布 TLS 1.3 规范真正落地了，标准规范（Standards Track）定义在 <a href="https://tools.ietf.org/html/rfc8446">rfc8446</a>，这里概要性的了解下 TLS 1.3 协议的特性，并解释各个组织对于该版本的支持。<br>TLS 1.3 版本从 2014 年开始开发，到 2018 年 8 月份历经了四年，可见是非常大的一个工程，一共有 28 个草案。<br>作为 TLS1.3 协议最重要、最著名的实现，OpenSSL 也发布了 OpenSSL 1.1.1 版本，该版本全面支持 TLS 1.3，是一个长期支持版本（LTS），将会有 5 年的支持，该版本兼容 1.1.0 版本，OpenSSL 官方建议尽快从 1.1.0 版本升级到 1.1.1 版本。<br>另外 Facebook 开源了一个 TLS 1.3 协议实现软件 Fizz，仅仅支持 TLS 1.3 版本，不用考虑老的 TLS 版本，会让代码简洁不少。<br>另外一个比较流行的 TLS 协议实现就是 NSS，其 3.39 版本也全面支持 TLS 1.3（rfc8446）协议了。<br>作为世界上最流行的 Web 服务器，Nginx 从 1.13.0 版本开始支持 TLS 1.3 协议，但真正支持还是依赖于其引用的协议实现（比如 OpenSSL、NSS）。<br>说完服务器支持 TLS 1.3，接下去说下浏览器对于该版本的支持。不管是 Chrome 还是 Firefox 都可以手动配置支持 TLS 1.3（当然是 draf 草案）。目前两大浏览器厂商宣布：</p><ul><li><p>chrome70（桌面版）开始，将默认开启支持 TLS 1.3（rfc8446），潜台词 70 以前的版本可以手动启用 TLS 1.3（draf）。</p></li><li><p>firefox63 版本（201810 月），将默认开启支持 TLS 1.3（rfc8446）。</p></li></ul><p>国外的一些云服务厂商也全面支持 TLS 1.3 协议了，比如 CloudFlare 从 2016 年就启用 TLS 1.3 支持了，KeyCDN 也已经全面支持了，国内在这方面还差了不少。<br>解密 HTTPS 流量的 Wireshark，从 2.6.3 版本开始，Wireshark 也将支持 TLS 1.3（rfc8446）。<br>另外一个著名的 HTTP 协议调试工具 Curl，从 7.52.0 版本开始也已经支持 TLS 1.3 协议，但真正支持还是依赖于其引用的协议实现（比如 OpenSSL、NSS）。</p><h2 id="TLS-1-3-协议做了那些改变？"><a href="#TLS-1-3-协议做了那些改变？" class="headerlink" title="TLS 1.3 协议做了那些改变？"></a><strong>TLS 1.3 协议做了那些改变？</strong></h2><ul><li><p>性能提升，主要是减少了握手次数，甚至可以做到 0-RTT，了解 TLS 协议的同学都知道，TLS 握手延迟是 TLS 性能最大的杀手。</p></li><li><p>安全性提升，比如说仅仅支持 AEAD 密码套件，废除了 AES-CBC 密码套件（使用不当会存在安全问题）；整个握手协议也使用签名保证握手消息的完整性（在 TLS 1.2 协议使用 MAC 算法验证握手消息），同时握手协议也是加密的（在 TLS 1.2 协议中，握手消息是明文的）。</p></li><li><p>协议设计的全方位改革，和 TLS 1.2 协议完全是不兼容的，可以说是一次大手术，完全不同的设计理念，比如说仅仅只支持 5 种密码套件，进一步保障了安全性。</p></li></ul><p>如果你想详细了解 TLS 1.3 协议，<a href="https://www.oschina.net/translate/rfc-8446-aka-tls-1-3">这篇文章</a>也被开源中国翻译了，有兴趣可以看看。</p><h2 id="我们是否可以全面拥抱-TLS-1-3？"><a href="#我们是否可以全面拥抱-TLS-1-3？" class="headerlink" title="我们是否可以全面拥抱 TLS 1.3？"></a><strong>我们是否可以全面拥抱 TLS 1.3？</strong></h2><p>对于服务提供者来说，现在可以支持 TLS 1.3 了，但不能废弃其他的 TLS 版本（比如 TLS 1.2），原因在于：<br>1）很多老的客户端（比如浏览器）版本可能比较低，根本不支持较新的一些密码套件，所以旧的 TLS 版本存活时间是比较长的，想想现在 TLS 1.1 版本还不能强制下线，TLS 1.2 从 2016 年开始启用，到现在已经 12 年了，某些网站还没有支持 TLS 1.2，可见从兼容性的角度看，TLS 老版本仍然会存在很长的生命周期。最近几年 HTTPS 应用越来越普及了，但并不是所有人（包括技术层面）对它还并不是特别了解，就我预估 TLS 1.2 协议至少还会存活十年以上。<br>2）TLS1.3 是个新版本，认知度和可信任度还比较欠缺，CloudFlare 和 Firefox 在 2017 年统计过，仅有 5%的用户支持 TLS 1.3（当然是草案），所以各个服务全面支持 TLS 1.3 还有很大的时间，比如服务器可能不会轻易升级 OpenSSL，拿我们公司来说，很多服务器 OpenSSL 版本还是 OpenSSL 1.0.1e。另外很多服务都会使用 OpenSSL，轻易是不敢升级的。后续估计各个 Linux 发行版会发布 OpenSSL 1.1.1 的 APT 或 RPM 包。<br>3）<strong>TLS1.3 版本是完全不兼容老版本的</strong>，HTTPS 协议是 TLS 协议最大的是使用者，其本质上还是 HTTP 协议，而 HTTP 应用非常的灵活，在互联网中，有很多的代理服务器或网关，他们为了各种各样的目的，都会透明解析 TLS 协议，CloudFlare 称之为 「middleboxes」，TLS 1.2 版本已经有 12 年历史了，这些代理服务器和网关也逐步能够解析 TLS 协议了，但 TLS1.3 版本的来临，其解析规则全部失效，那么对于用户来说，他们可能就无法使用 TLS1.3 协议了，这也是 TLS1.3 协议非常重要的一个问题。<br>总结来说，TLS 1.3 的普及还需要很长时间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Websocket，服务器发送事件(SSE)和HTTP2的服务器推送之间有什么区别？</title>
    <link href="/2020/09/19/yuque/Websocket%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6(SSE)%E5%92%8CHTTP2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2020/09/19/yuque/Websocket%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6(SSE)%E5%92%8CHTTP2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>Websockets</strong>：<br>双向异步通信。到目前为止，HTTP / 2 不能很好地工作，但是正在努力使之成为现实。 (例如 WISH 和 websockets2-over-http2。)<br><strong>SSE</strong>：<br>服务器可以将事件通知浏览器。使用普通的 HTTP，即使在使用 HTTP / 2 时也能很好地工作。通过使用常规 POST 请求从客户端向服务器发出通知，可以通过 SSE 在两个方向上模拟异步通信，在 HTTP / 2 中，这些请求与同一个源的所有其他对象都放在同一个套接字中，因此建立新连接的成本是可以避免的。但是，在服务器端处理 POST 请求的处理成本可能会比使用本机 Websocket 更高。<br><strong>HTTP / 2 推送</strong>：<br>与上述两者绝对无关，它是服务器将资产提前推送到浏览器的一种机制。可能的应用程序：在 PHP 引擎创建 HTML 的同时发送 CSS 和 Javascript。从理论上讲，可以将 HTTP / 2 推送和 SSE 结合使用，以使浏览器可以使用事件，而无需初始往返延迟。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP1.1、HTTP2.0的区别</title>
    <link href="/2020/09/19/yuque/HTTP1.1%E3%80%81HTTP2.0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/09/19/yuque/HTTP1.1%E3%80%81HTTP2.0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.3">https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.5.3</a></p><h1 id="Http-几个版本的区别"><a href="#Http-几个版本的区别" class="headerlink" title="Http 几个版本的区别"></a>Http 几个版本的区别</h1><p>《<a href="https://link.zhihu.com/?target=https://http2.akamai.com/demo">HTTP/2: the Future of the Internet</a>》 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从 Load time 的对比可以看出 HTTP/2 在速度上的优势。</p><h1 id="HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性"></a><strong>HTTP2.0 和 HTTP1.X 相比的新特性</strong></h1><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a><strong>二进制分帧层</strong></h2><p>HTTP2.0 性能增强的核心，全在于新增的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。这里所谓的“层”，指的是位于套接字接口与应用可见高层 HTTP API 之间的一个新机制：HTTP 语义，包括各种动词、方法、首部，都不受影响，不同的是传输期间对它们的编码方式变了。HTTP1.x 以换行符作为纯文本的分隔符，而 HTTP2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。<br>这样一来，客户端和服务器为了相互理解，必须都使用新的二进制编码机制：HTTP1.x 客户端无法理解只支持 HTTP2.0 的服务器，反之亦然。不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器会替它们完成必要的分帧工作。<br>HTTPS 是二进制分帧的另一个典型示例：所有 HTTP 消息都以透明的方式为我们编码和解码，从而实现客户端与服务器安全通信，但不必对应用进行任何修改。HTTP2.0 的工作原理差不多也是这样。</p><h2 id="流、消息和帧"><a href="#流、消息和帧" class="headerlink" title="流、消息和帧"></a><strong>流、消息和帧</strong></h2><p>新的二进制分帧机制改变了客户端与服务器之间交互数据的方式。为了说明这个过程，我们需要了解 HTTP2.0 的几个新概念：</p><blockquote><p><strong>流</strong> 已建立的连接上的双向字节流。 <strong>消息</strong> 与逻辑消息对应的完整的一系列数据帧。 <strong>帧</strong> HTTP2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。</p></blockquote><p>HTTP2.0 通信都在一个连接上完成，这个连接可以承载任意数据量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。HTTP2.0 的所有帧都采用二进制编码，所有首部数据都会被压缩。<br>这简简单单的几句话里浓缩了大量的信息：</p><ul><li><p>所有通信都在一个 TCP 连接上完成；</p></li><li><p>流是连接中的一个虚拟信道，可以承载双向的消息。每个流都有一个唯一的整数标识符；</p></li><li><p>消息是指逻辑上的 HTTP 消息，比如请求、相应等，由一或多个帧组成；</p></li><li><p>帧是最小的通信单位，承载这特定类型的数据，如 HTTP 首部、负荷等；</p></li></ul><p>简言之，HTTP2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行的在同一个 TCP 连接上交换消息。</p><h2 id="多路复用（MultiPlexing）"><a href="#多路复用（MultiPlexing）" class="headerlink" title="多路复用（MultiPlexing）"></a><strong>多路复用（MultiPlexing）</strong></h2><p>在 HTTP1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接。这是 HTTP1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。<br>HTTP2.0 中新的<strong>二进制分帧层</strong>突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。<br>把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP2.0 最重要的一项增强。事实上，这个机制会在整个 Web 技术栈中引发一系列连锁反应，从而带来巨大的性能提升，因为：</p><ul><li><p>可以并行交错的发送请求，请求之间互不影响；</p></li><li><p>可以并行交错的发送响应，响应之间互不干扰；</p></li><li><p>只使用一个连接即可并行发送多个请求和响应；</p></li><li><p>消除不必要的延迟，从而减少页面加载的时间；</p></li><li><p>不必再为绕过 HTTP1.x 限制而多做很多工作。</p></li></ul><p>总之，HTTP2.0 的二进制分帧机制解决了 HTTP1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果就是应用速度更快、开发更简单、部署成本更低。<br>支持多向请求和响应，可以省掉对 HTTP1.x 限制所费的那些工作，比如拼接文件、图片精灵、域名分区。类似地，通过减少 TCP 连接的数量，HTTP2.0 也会减少客户端和服务器的 CPU 及内存占用。</p><h2 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a><strong>请求优先级</strong></h2><p>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：</p><blockquote><p>0 表示最高优先级； (2^31)-1 表示最低优先级。</p></blockquote><p>有了这个优先值，客户端和服务器就可以在处理不同的流时采用不同的策略，以最优的方式发送流、消息和帧。具体来讲，服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将高优先级的帧发送给客户端。<br>浏览器在渲染页面时，并非所有资源都具有相同的优先级：HTML 文档本身对构建 DOM 不可或缺，CSS 对构建 CSSOM 不可或缺，而 DOM 和 CSSOM 的构建都可能会受到 JavaScript 资源的阻塞，其他资源（如图片）的优先级都可以降低。为加快页面加载的速度，所有现代浏览器都会基于资源的类型以及它在页面中的位置排定请求的优先次序，甚至通过之前的访问来学习优先级模式–比如，之前的渲染如果被某些资源阻塞了，那么同样的资源在下一次访问时可能就会被赋予更高的优先级。</p><h2 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a><strong>每个来源一个连接</strong></h2><p>有了新的分帧机制后，HTTP2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有 HTTP2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。<br>每个来源一个连接显著减少了相关资源的占用：连接路径上的套接字管理工作量少了，内存占用少了，连接的吞吐量大了。此外，从上到下所有层面上也都获得了相应的好处：</p><ul><li><p>所有话剧流的优先次序始终如一；</p></li><li><p>压缩上下文单一使得压缩效果更好；</p></li><li><p>由于 TCP 连接减少而使网络拥塞状况得以改观；</p></li><li><p>慢启动时间减少，拥塞和丢包回复速度更快。</p></li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p>在同一个 TCP 上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题，HTTP2.0 为数据流和连接的流量控制提供了一个简单的机制：</p><ul><li><p>流量控制基于每一跳进行，而非端到端的控制；</p></li><li><p>流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及整个连接要接收多少字节；</p></li><li><p>流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；</p></li><li><p>流量控制有方向性，即接收放可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；</p></li><li><p>流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。</p></li></ul><p>HTTP2.0 建立连接之后，客户端与服务器交换 SETTINGS 帧，目的是设置双向的流量控制窗口大小。除此之外，任何一端都可以选择禁用个别流或整个连接的流量控制。</p><h2 id="服务端推送（server-push）"><a href="#服务端推送（server-push）" class="headerlink" title="服务端推送（server push）"></a><strong>服务端推送（server push）</strong></h2><p>HTTP2.0 新增的一个强大的新功能，就是<strong>服务器可以对一个客户端请求发送多个响应</strong>。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的请求。<br>建立 HTTP2.0 连接后，客户端与服务器交换 SETTINGS 帧，借此可以限定双向并发的流的最大数量。因此，客户端可以限定推送流的数量，或者通过设置为 0 而完全禁用服务器推送。<br>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h2 id="首部（header）压缩"><a href="#首部（header）压缩" class="headerlink" title="首部（header）压缩"></a><strong>首部（header）压缩</strong></h2><p>HTTP 的每次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP1.x 中这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500-800 字节的负担。如果算上 Cookie，增加的负担更重。为减少这些，HTTP2.0 会压缩首部元数据。 HTTP2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送； 首部表在 HTTP2.0 的连接存续期内始终存在，有客户端和服务器共同更新； 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。<br>于是，HTTP2.0 连接的两端都知道已经发送了哪些首部。请求与响应首部的定义在 HTTP2.0 中基本没有改变，只是所有的首部健必须全部小写。</p><h1 id="HTTP2-0-的升级改造"><a href="#HTTP2-0-的升级改造" class="headerlink" title="HTTP2.0 的升级改造"></a><strong>HTTP2.0 的升级改造</strong></h1><p>HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 chrome，firefox 表示还是只支持基于 TLS 部署的 HTTP2.0 协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。<br>当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX，只要在配置文件中启动相应的协议就可以了，可以参考 NGINX 白皮书，NGINX 配置 HTTP2.0 官方指南 <a href="https://www.nginx.com/blog/nginx-1-9-5/%E3%80%82">https://www.nginx.com/blog/nginx-1-9-5/。</a><br>使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办，这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。</p><h1 id="HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？"><a href="#HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？" class="headerlink" title="HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？"></a><strong>HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？</strong></h1><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</p><h1 id="为什么需要头部压缩？"><a href="#为什么需要头部压缩？" class="headerlink" title="为什么需要头部压缩？"></a>为什么需要头部压缩？</h1><p>假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的）, 而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 Cookie 和引用等东西的存在）, 则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP 头部，大大降低因头部传输产生的流量。</p><h1 id="HTTP2-0-多路复用有多好？"><a href="#HTTP2-0-多路复用有多好？" class="headerlink" title="HTTP2.0 多路复用有多好？"></a>HTTP2.0 多路复用有多好？</h1><p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GET请求和POST请求有何区别？</title>
    <link href="/2020/09/19/yuque/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2020/09/19/yuque/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://juejin.im/post/6844904097091420174">https://juejin.im/post/6844904097091420174</a></p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><ol><li>它是 <code>HTTP</code> 常见的请求类型，最常见于向服务器查询某些信息。</li><li>可以将查询参数追加到 <code>URL</code>末尾，以便将信息发送给服务器。</li><li>对查询字符串的格式有要求，每个参数名称和值必须使用<code>encodeURIComponent</code>进行编码，才能放到<code>URL</code>末尾，必须用<code>&amp;</code>符号隔开。例如：baidu.com/index.php?name=111&amp;id=222</li><li>GET 请求产生一个数据包。对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li></ol><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><ol><li>它是 <code>HTTP</code> 常见的请求类型，最常见于向服务器发送应该被保存的信息或者查询某些信息。</li><li>可以添加请求参数，将请求参数添加到 body 中。</li><li><code>POST</code>请求产生 2 个数据包，在火狐浏览器中，产生一个数据包。</li></ol><h3 id="GET-请求和-POST-请求的差别"><a href="#GET-请求和-POST-请求的差别" class="headerlink" title="GET 请求和 POST 请求的差别"></a>GET 请求和 POST 请求的差别</h3><ol><li><code>GET</code> 请求的请求参数是添加到 <code>head</code> 中，可以在 <code>url</code> 中可以看到；<code>POST</code> 请求的请求参数是添加到<code>BODY</code>中,在<code>url</code> 中不可见。</li><li><code>GET</code> 请求参数需要使用 <code>encodeURIComponent</code> 进行编码，必须用 <code>&amp;</code> 符号隔开。</li><li>请求的<code>url</code>有长度限制，这个限制由浏览器和 <code>web</code> 服务器决定和设置的。例如 IE 浏览器对 <code>URL</code>的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应。因为<code>GET</code>请求的参数是添加到<code>URL</code>中，所以<code>GET</code>请求的<code>URL</code>的长度限制需要将请求参数长度也考虑进去。而<code>POST</code>请求不用考虑请求参数的长度。</li><li><code>GET</code>请求产生一个数据包; <code>POST</code>请求产生 2 个数据包,在火狐浏览器中，产生一个数据包。这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体。因为<code>GET</code>没有请求体，所以就发送一个数据包，而<code>POST</code>包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。</li><li>由于<code>GET</code>请求的参数是在<code>url</code>中，所以可以直接在浏览器中打开</li><li><code>GET</code> 请求会被浏览器主动缓存下来，留下历史记录，而 <code>POST</code> 默认不会。</li><li><code>GET</code>是幂等的，而<code>POST</code>不是。(幂等表示执行相同的操作，结果也是相同的)</li></ol><h3 id="GET-请求和-POST-请求的使用场景"><a href="#GET-请求和-POST-请求的使用场景" class="headerlink" title="GET 请求和 POST 请求的使用场景"></a>GET 请求和 POST 请求的使用场景</h3><p>如果想要查询的更快，可以使用<code>GET</code>请求。 其他的，并无差别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>options请求是什么？有什么用？</title>
    <link href="/2020/09/19/yuque/options%E8%AF%B7%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/"/>
    <url>/2020/09/19/yuque/options%E8%AF%B7%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.cnblogs.com/mamimi/p/10602722.html">https://www.cnblogs.com/mamimi/p/10602722.html</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自后台 restful 接口流行开来，请求了两次的情况（options 请求）越来越普遍。笔者也在实际的项目中遇到过这种情况，做一下整理总结。<br><a href="https://img2018.cnblogs.com/blog/1016870/201903/1016870-20190326174205985-700929802.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600515689085-0ac7ae68-70c0-4f6d-9776-22feb39fd93b.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=1086&size=0&status=done&style=none&width=1086"></a></p><h3 id="文章书写思路"><a href="#文章书写思路" class="headerlink" title="文章书写思路"></a>文章书写思路</h3><p><a href="https://img2018.cnblogs.com/blog/1016870/201903/1016870-20190326174325288-1358257515.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600515689073-3a2855d7-dfd4-4368-9610-b8f1208155e9.png#align=left&display=inline&height=293&margin=%5Bobject%20Object%5D&originHeight=293&originWidth=972&size=0&status=done&style=none&width=972"></a></p><h2 id="为什么发生两次请求"><a href="#为什么发生两次请求" class="headerlink" title="为什么发生两次请求"></a>为什么发生两次请求</h2><p>http 的请求方式，包括 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE 和 CONNECT 等八种请求方式。其中，get 与 post 只是我们常用的请求方式。<br>我们能在图一里看到，第一条的请求方式为 options，第二条请求，才是我们预想中的请求。所以为什么发生两条请求的原因就变成了为什么发生 options 请求。</p><h2 id="options-请求"><a href="#options-请求" class="headerlink" title="options 请求"></a>options 请求</h2><p>options 请求的官方定义：OPTIONS 方法是用于请求获得由 Request-URI 标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。<br>用白话说就是：在发生正式的请求之前，先进行一次预检请求。看服务端返回一些信息，浏览器拿到之后，看后台是否允许进行访问。</p><h3 id="如何产生-options-请求"><a href="#如何产生-options-请求" class="headerlink" title="如何产生 options 请求"></a>如何产生 options 请求</h3><p>产生 options 请求的原因包括以下几条：<br><strong>1：**</strong>产生了复杂请求**。复杂请求对应的就是简单请求。简单请求的定义是：</p><ol><li> 请求方法是 GET、HEAD 或者 POST，并且当请求方法是 POST 时，Content-Type 必须是 application/x-www-form-urlencoded, multipart/form-data 或着 text/plain 中的一个值。</li><li> 请求中没有自定义 HTTP 头部。</li></ol><p>所谓的自定义头部，在实际的项目里，我们经常会遇到需要在 header 头部加上一些 token 或者其他的用户信息，用来做用户信息的校验。<br><strong>2：**</strong>发生了跨域*<strong>*。</strong></p><h3 id="options-请求有什么作用"><a href="#options-请求有什么作用" class="headerlink" title="options 请求有什么作用"></a><strong>options 请求有什么作用</strong></h3><p>官方将头部带自定义信息的请求方式称为带预检（preflighted）的跨域请求。在实际调用接口之前，会首先发出一个 options 请求，检测服务端是否支持真实的请求进行跨域的请求。真实请求在 options 请求中，通过 request-header 将  Access-Control-Request-Headers 与 Access-Control-Request-Method 发送给后台，另外浏览器会自行加上一个 Origin 请求地址。服务端在接收到预检请求后，根据资源权限配置，在 response-header 头部加入 access-control-allow-headers（允许跨域请求的请求头）、access-control-allow-methods（允许跨域请求的请求方式）、access-control-allow-origin（允许跨域请求的域）。另外，服务端还可以通过 Access-Control-Max-Age 来设置一定时间内无须再进行预检请求，直接用之前的预检请求的协商结果即可。浏览器再根据服务端返回的信息，进行决定是否再进行真实的跨域请求。这个过程对于用户来说，也是透明的。<br>另外在 HTTP 响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回 Access-Control-Allow-Credentials: true 的，浏览器都会忽略此次响应。<br>总结：只要是带自定义 header 的跨域请求，在发送真实请求前都会先发送 OPTIONS 请求，浏览器根据 OPTIONS 请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。</p><h3 id="options-请求如何避免"><a href="#options-请求如何避免" class="headerlink" title="options 请求如何避免"></a><strong>options 请求如何避免</strong></h3><p>**其实通过以上的分析，我们能得出以下解决方案：<br>1：使用代理，避开跨域。<br>2：将复杂跨域请求更改为简单跨域请求。<br>3：不使用带自定义配置的 header 头部。</p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>笔者现在维护的项目之一是用 angularjs 作为框架，使用$resoruce 进行的通信，请求头默认采用 content-type: application/json。所以即使拿掉请求头里前台自定义的 token，仍然还会在 post 请求中额外发出 options 请求，因为不满足简单请求的条件。而 get 请求没有这这个情况。<br><a href="https://img2018.cnblogs.com/blog/1016870/201903/1016870-20190328093431589-1979860660.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600515689066-c1ce305b-07cd-4746-809e-5e512a79f803.png#align=left&display=inline&height=599&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=1095&size=0&status=done&style=none&width=1095"></a></p><p>笔者将 header 头里的 token 拿掉后，get 的 options 请求消除了。<br><a href="https://img2018.cnblogs.com/blog/1016870/201903/1016870-20190328093038869-1528593539.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600515689096-9d4935d0-4340-48ed-a721-acc18358eff3.png#align=left&display=inline&height=528&margin=%5Bobject%20Object%5D&originHeight=528&originWidth=1096&size=0&status=done&style=none&width=1096"></a><br>上图中，post 发出了 options 请求。原因在于 content-type。<br><strong>去除 post 的 options 请求：</strong><br><a href="https://img2018.cnblogs.com/blog/1016870/201903/1016870-20190328093555030-1776390407.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600515689110-3157ceb4-4d8c-4213-83ea-1226f2643a90.png#align=left&display=inline&height=732&margin=%5Bobject%20Object%5D&originHeight=732&originWidth=1222&size=0&status=done&style=none&width=1222"></a><br>有人想问不想用 options 请求，却又想验证用户信息该怎么做呢？这个时候考虑通过 cookie 进行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP的请求有多少种？详细说说每一种</title>
    <link href="/2020/09/19/yuque/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%EF%BC%9F%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E6%AF%8F%E4%B8%80%E7%A7%8D/"/>
    <url>/2020/09/19/yuque/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%EF%BC%9F%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E6%AF%8F%E4%B8%80%E7%A7%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-请求有多种方法："><a href="#HTTP-请求有多种方法：" class="headerlink" title="HTTP 请求有多种方法："></a>HTTP 请求有多种方法：</h1><p><strong>HTTP1.0</strong>定义了 3 种请求方法：<code>**GET、POST和HEAD**</code>；<br><strong>HTTP1.1</strong>新增 5 种请求方法：<code>**OPTIONS、PUT、DELETE、TRANCE和CONNECT**</code>；<br><strong>HTTP2.0</strong>协议解析采用新的<strong>二进制</strong>格式，<strong>HTTP1.x</strong>的解析是<strong>基于文本</strong>；</p><ol><li><strong>GET</strong>：请求指定页面信息，并返回实体主体；</li><li><strong>POST</strong>：向指定资源提交数据并进行处理请求，数据被包含在请求体中，POST 请求可能会导致新的资源的建立或已有资源的修改；</li><li><strong>HEAD</strong>：类似 GET 请求，只不过返回的响应中没有具体内容，<strong>用于获取报头</strong>；</li><li><strong>PUT</strong>：从客服端向服务器传送的数据取代指定的文档内容；</li><li><strong>DELETE</strong>：请求服务器删除指定的内容；</li><li><strong>CONNECT</strong>：HTTP1.1 协议中预留给能够将连接改为管道方式的<strong>代理服务器</strong>；connect 的作用就是将服务器作为代理，让服务器代替用户去访问其他网页（说白了，就是翻墙），之后将数据返回给用户</li><li><strong>TRACE</strong>：回显服务器收到的请求，主要用于<strong>测试</strong>或<strong>诊断</strong>；</li><li><strong>OPTIONS</strong>：OPTIONS 方法是用于请求获得由 Request-URI 标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。在发生正式的请求之前，先进行一次预检请求。看服务端返回一些信息，浏览器拿到之后，看后台是否允许进行访问。</li><li><strong>PATCH</strong>:是对 PUT 方法的补充，用来对已知资源进行局部更新。</li></ol><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>01</td><td>HEAD</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>02</td><td>GET</td><td>类似于 <code>GET</code> 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>03</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code> 请求可能会导致新的资源的建立或已有资源的修改。</td></tr><tr><td>04</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>05</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>06</td><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>07</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>08</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>09</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月15日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8815%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字、剑指 Offer 61. 扑克牌中的顺子、剑指 Offer 42. 连续子数组的最大和、剑指 Offer 18. 删除链表的节点</p><span id="more"></span><h1 id="剑指-Offer-53-II-0-～-n-1-中缺失的数字"><a href="#剑指-Offer-53-II-0-～-n-1-中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字</a></h1><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0 ～ n-1 之内。在范围 0 ～ n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。<br> <strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [0,1,3]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4,5,6,7</span>,<span class="hljs-number">9</span>]<br>输出: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>1 &lt;= 数组长度 &lt;= 10000</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>最简单的遍历，如果下标不等于数，返回下标。时间复杂度 O(n)。</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>题目关键词，<strong>有序数组</strong>，所以使用二分查找。如果下标和数相同，令 min 等于 mid + 1。若下标和数不同，若 mid 为 0，缺少的为 0，再确认上一个数是否和数相同，是的话返回当前下标，不是的话令 max 等于 mid - 1。时间复杂度 O(logn)。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>太简单了，不写了。</p><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> missingNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> q = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p &lt;= q) &#123;<br>    mid = <span class="hljs-built_in">parseInt</span>((p + q) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] === mid) &#123;<br>      p = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (mid === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[mid - <span class="hljs-number">1</span>] !== mid) &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        q = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums.length;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h1><p>从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。<br> <strong>示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4,5]</span><br><span class="hljs-section">输出: True</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [0,0,1,2,5]</span><br><span class="hljs-section">输出: True</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong><br>数组长度为 5 <br>数组的数取值为 [0, 13] .</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先对数组排序，如果为 0，直接跳过。如果为对子，则这不是 0 的对子，直接返回 false。计算剩余的牌的最大值及最小值，如果他们的差小于等于四则为顺子</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isStraight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums.sort();<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> min = <span class="hljs-number">13</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[i] === nums[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; max) max = nums[i];<br>    <span class="hljs-keyword">if</span> (nums[i] &lt; min) min = nums[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> max - min &lt;= <span class="hljs-number">4</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为 O(n)。<br><strong>示例 1:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>复习，本题与主站 53 题相同：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a>。<br>先比较 sum 加上当前数是否令 sum 变大，是的话，再判断 sum 是不是最大的 sum 存在 max 中。如果不是，则把当前设为一个子数组的开始，即 sum 重新开始计算。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    sum = <span class="hljs-built_in">Math</span>.max(nums[i], sum + nums[i]);<br>    max = <span class="hljs-built_in">Math</span>.max(sum, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br><strong>注意：</strong>此题对比原题有改动<br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 5</span><br><span class="hljs-section">输出: [4,1,9]</span><br><span class="hljs-section">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 1</span><br><span class="hljs-section">输出: [4,5,9]</span><br><span class="hljs-section">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>判断头结点值是否相等，是的话，返回头结点的 next。使用一个 pre 记录上一个节点，如果当前节点值相等，则将上一个节点的 next 设为当前节点的 next，返回 res。</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = head;<br>  <span class="hljs-keyword">if</span> (res.val === val) <span class="hljs-keyword">return</span> res.next;<br>  <span class="hljs-keyword">let</span> pre = head;<br>  <span class="hljs-keyword">while</span> (head) &#123;<br>    pre = head;<br>    head = head.next;<br>    <span class="hljs-keyword">if</span> (head &amp;&amp; head.val === val) &#123;<br>      pre.next = head.next;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>链表</tag>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月17日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8817%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 64. 求 1+2+…+n、剑指 Offer 56 - II. 数组中数字出现的次数 II、剑指 Offer 56 - I. 数组中数字出现的次数</p><span id="more"></span><h1 id="剑指-Offer-64-求-1-2-…-n"><a href="#剑指-Offer-64-求-1-2-…-n" class="headerlink" title="剑指 Offer 64. 求 1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求 1+2+…+n</a></h1><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。<br><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 3</span><br><span class="hljs-section">输出: 6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 9</span><br><span class="hljs-section">输出: 45</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>使用 js 隐式转换，判断 n 是否大于 0，Boolean(0)为 false，&amp;&amp;断路，终止递归。</p><h4 id="幂运算、位移动"><a href="#幂运算、位移动" class="headerlink" title="幂运算、位移动"></a>幂运算、位移动</h4><p>根据等差数列求和公式，首项加尾项乘以项数除以 2，可以得到为(1+n)n/2 = (n^2+n) /2，题目要求不出现乘除法，可以使用幂运算及位移动来代替。n^2=n**2，/2=&gt;&gt;2，所以 (n^2+n) /2 = (n ** 2 + n) &gt;&gt; 1</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>本质其实还是循环，循环加数组下标，其实加的是 0-9，所以起始值要设为 n。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNums = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n &amp;&amp; sumNums(n - <span class="hljs-number">1</span>) + n;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="幂运算、位移动-1"><a href="#幂运算、位移动-1" class="headerlink" title="幂运算、位移动"></a>幂运算、位移动</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNums = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (n ** <span class="hljs-number">2</span> + n) &gt;&gt; <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="reduce-1"><a href="#reduce-1" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNums = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(n)<br>    .fill(<span class="hljs-number">0</span>)<br>    .reduce(<span class="hljs-function">(<span class="hljs-params">a, b, index</span>) =&gt;</span> a + index, n);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h1><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。<br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,4,3,3</span>]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[9,1,7,9,7,9,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h4><p>存储每个数计数，等于 3 时删除，最后 map 中只剩下结果，返回即可。</p><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>假设对于 a、b、c、d 来说，d 出现了 1 次，其他数字出现 3 次。那么求 d 的值的表达式是：2 _ d = 3_(a + b + c + d) - (3a + 3b + 3c + d)<br>为了计算(a + b + c + d)，可以将数组去重后，再求和。去重借助的是集合（Set）。</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>最符合题目要求的解决方法就是：位运算。能在不开辟额外空间的情况下，完成要求。<br>按照位数（最高 32 位）去考虑，这种方法的关键就是找到对于只出现一次的数字，它的哪些二进制位是 1。<br>整体算法流程如下：<br>从第 1 位开始<br>创建掩码（当前位为 1，其他为 0），count 设置为 0<br>将每个数字和掩码进行&amp;运算，如果结果不为 0，count 加 1<br>如果 count 整除 3，说明出现一次的数字这一位不是 1；否则，<strong>说明出现一次的数字这一位是 1</strong><br>继续检查第 2 位，一直到 32 位，结束</p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>暂时不学</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="MAP-1"><a href="#MAP-1" class="headerlink" title="MAP"></a>MAP</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> singleNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map.get(num) === <span class="hljs-number">2</span>) &#123;<br>      map.delete(num);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.set(num, map.get(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...map.keys()][<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> singleNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-comment">//a+b+c+d的和</span><br>  <span class="hljs-keyword">const</span> sum1 = [...new <span class="hljs-built_in">Set</span>(nums)].reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  <span class="hljs-comment">//3a+3b+3c+d的和</span><br>  <span class="hljs-keyword">const</span> sum2 = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">3</span> * sum1 - sum2) / <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> singleNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bit = <span class="hljs-number">0</span>; bit &lt; <span class="hljs-number">32</span>; ++bit) &#123;<br>    <span class="hljs-comment">// 构造第i位为1的mask</span><br>    <span class="hljs-keyword">let</span> mask = <span class="hljs-number">1</span> &lt;&lt; bit;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计所有数字当前位为1的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>      <span class="hljs-keyword">if</span> (num &amp; mask) ++count;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前位1的和不能整除3，说明混入了目标数字的1，这里3可以换成任意奇数</span><br>    <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span>) &#123;<br>      res = res | mask;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<strong>要求时间复杂度是 O(n)，空间复杂度是 O(1)**。<br>**示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,1,4,6]</span><br>输出：<span class="hljs-comment">[1,6]</span> 或 <span class="hljs-comment">[6,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,10,4,1,4,3,3]</span><br>输出：<span class="hljs-comment">[2,10]</span> 或 <span class="hljs-comment">[10,2]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>两个相同数异或得到的值为 0，因此可以知道，对 nums 进行累计异或得到的 s 一定是两个不同的数 a、b 的异或值<br>创建一个数组记录结果<br>对每一个数进行与运算，可以将数分为 1、0 两个组，其中 a、b 两个只出现一次的数必定出现在不同的组<br>进行异或运算，其他出现过两次的数一定会为 0，最后只剩下只出现一次的一个数</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> singleNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-comment">// 两个相同数异或得到的值为0，因此可以知道，对nums进行累计异或得到的s一定是两个不同的数a、b的异或值</span><br>  <span class="hljs-keyword">let</span> s = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a ^ b);<br>  <span class="hljs-comment">// 这里令 k= s &amp; (-s)是求出不相同二进制串中的第一个1。进行与运算时，使用补码进行计算，求-s的补码过程如下。</span><br>  <span class="hljs-comment">// 例如s=6   原码0000 0000 0000 0000 0000 0000 0000 0110</span><br>  <span class="hljs-comment">//    s=6   补码0000 0000 0000 0000 0000 0000 0000 0110</span><br>  <span class="hljs-comment">// 例如s=-6  原码1000 0000 0000 0000 0000 0000 0000 0110</span><br>  <span class="hljs-comment">//    s=-6  反码1111 1111 1111 1111 1111 1111 1111 1001</span><br>  <span class="hljs-comment">//    s=-6  补码1111 1111 1111 1111 1111 1111 1111 1010</span><br>  <span class="hljs-comment">//    s=6   补码0000 0000 0000 0000 0000 0000 0000 0110</span><br>  <span class="hljs-comment">//          结果0000 0000 0000 0000 0000 0000 0000 0010</span><br>  <span class="hljs-keyword">let</span> k = s &amp; -s;<br>  <span class="hljs-comment">// 创建一个数组记录结果</span><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-comment">// 对每一个数进行与运算，可以将数分为1、0两个组，其中a、b两个只出现一次的数必定出现在不同的组</span><br>    <span class="hljs-keyword">if</span> (num &amp; k) &#123;<br>      <span class="hljs-comment">// 进行异或运算，其他出现过两次的数一定会为0，最后只剩下只出现一次的一个数</span><br>      res[<span class="hljs-number">0</span>] ^= num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res[<span class="hljs-number">1</span>] ^= num;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
      <tag>递归</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月16日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8816%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 54. 二叉搜索树的第 k 大节点、剑指 Offer 57 - II. 和为 s 的连续正数序列、剑指 Offer 32 - II. 从上到下打印二叉树 II</p><span id="more"></span><h1 id="剑指-Offer-54-二叉搜索树的第-k-大节点"><a href="#剑指-Offer-54-二叉搜索树的第-k-大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第 k 大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第 k 大节点</a></h1><p>给定一棵二叉搜索树，请找出其中第 k 大的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong><br>1 ≤ k ≤ 二叉搜索树元素个数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历结果就是有序数组，若先右后左则为递减数组，先左后右为递增数组。<br>可先右后左遍历后返回，数组第 k-1 个元素，则为结果。<br>或者使用计数，当 count===k-1 时设置 res 为节点值。注意判断 res 中是否有值，有的话不在进行遍历。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>返回数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, k</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  visit(root, res, k);<br>  <span class="hljs-keyword">return</span> res[k - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node, res, k</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>  visit(node.right, res, k);<br>  res.push(node.val);<br>  visit(node.left, res, k);<br>&#125;;<br></code></pre></td></tr></table></figure><p>改进</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, k</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!res) visit(node.right);<br>    <span class="hljs-keyword">if</span> (count++ === k - <span class="hljs-number">1</span>) &#123;<br>      res = node.val;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!res) visit(node.left);<br>  &#125;;<br>  visit(root);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-57-II-和为-s-的连续正数序列"><a href="#剑指-Offer-57-II-和为-s-的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为 s 的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为 s 的连续正数序列</a></h1><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[2,3,4],[4,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">15</span><br>输出：<span class="hljs-string">[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>双重循环，判断几个连续的值是否等于目标值即可。</p><h4 id="滑窗"><a href="#滑窗" class="headerlink" title="滑窗"></a>滑窗</h4><p>当长度大于 2 时，设置左窗口边界为 1，右窗口边界为 2。<br>例如 9=Math.ceil(9/2)+X = 5+X X 必然小于 5。<br>所以循环的出口为左窗口边界小于 Math.ceil(target/2)，且左窗口边界小于右窗口边界。<br>在每个循环中，求窗口内的和，若和小于 target，令右窗口边界加一。若大于 target，令左窗口边界加一。<br>若等于 target，存储窗口内的数组到结果数组中。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findContinuousSequence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; target; i++) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> tmp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; target &amp;&amp; sum &lt; target; j++) &#123;<br>      sum += j;<br>      tmp.push(j);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum === target) res.push(tmp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(findContinuousSequence(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h4 id="滑窗-1"><a href="#滑窗-1" class="headerlink" title="滑窗"></a>滑窗</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findContinuousSequence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (target.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> end = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (end &lt;= <span class="hljs-built_in">Math</span>.ceil(target / <span class="hljs-number">2</span>) &amp;&amp; start &lt; end) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) &#123;<br>      sum += i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum === target) &#123;<br>      <span class="hljs-keyword">let</span> tmp = [];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) &#123;<br>        tmp.push(i);<br>      &#125;<br>      res.push(tmp);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>      end++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      start++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>使用队列广度遍历思想。其中 splice 后再 for of，也是相当于队列出队后再将左右节点入队。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">const</span> queue = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  queue.push(root);<br>  <span class="hljs-keyword">let</span> tmp = [];<br>  <span class="hljs-keyword">while</span> (queue.length) &#123;<br>    <span class="hljs-keyword">const</span> nodes = queue.splice(<span class="hljs-number">0</span>, queue.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> node <span class="hljs-keyword">of</span> nodes) &#123;<br>      tmp.push(node.val);<br>      <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);<br>    &#125;<br>    res.push(tmp);<br>    tmp = [];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月18日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8818%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt235. 二叉搜索树的最近公共祖先、Lt155. 最小栈</p><span id="more"></span><h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600440222841-c2de5b69-3e4d-484d-a0c6-f3b8a001d5a0.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=200&size=0&status=done&style=none&width=200"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>结合二叉搜索树的特点，当当前节点值都比 p、q 要大的时候，说明公共节点在左边，返回左子树，都要小的时候说明公共节点在右边，返回右子树。当值在两个之间时，就为公共祖先。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>  <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong><br><strong>输入：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">-3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MinStack minStack = new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.getMin()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.getMin()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用双栈做法，栈内每一个元素都是[min,x]的形式，min 总是存储当前位置下最小的一个元素，求最小元素时，直接求栈顶的[0]的值即可</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.stack = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stack.length) min = x;<br>  <span class="hljs-keyword">else</span> min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], x);<br>  <span class="hljs-built_in">this</span>.stack.push([min, x]);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack.pop();<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stack.length) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stack.length) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MinStack()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.getMin()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月11日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8811%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt53.最大子序和、Lt112.路径总和、Lt299.猜数字游戏</p><span id="more"></span><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.<a href="https://leetcode-cn.com/problems/maximum-subarray/description/">最大子序和</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (52.25%)</td><td align="center">2408</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/divide-and-conquer"><code>divide-and-conquer</code></a> | <a href="https://leetcode.com/tag/dynamic-programming"><code>dynamic-programming</code></a><br><strong>Companies</strong><br><code>bloomberg</code> | <code>linkedin</code> | <code>microsoft</code><br>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p><strong>进阶:</strong><br>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><hr><p><a href="https://leetcode-cn.com/problems/maximum-subarray/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>// Kadane 算法扫描一次整个数列的所有数值，<br>// 在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。<br>// 该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。<br>// 因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出,<br>// 该算法可看成动态规划的一个例子。<br>// 状态转移方程：sum[i] = max{sum[i-1]+a[i],a[i]}  <br>// 其中(sum[i]记录以 a[i]为子序列末端的最大序子列连续和)</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=53 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [53] 最大子序和</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>,<br>    maxAns = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    pre = <span class="hljs-built_in">Math</span>.max(pre + num, num);<br>    maxAns = <span class="hljs-built_in">Math</span>.max(maxAns, pre);<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxAns;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">202</span>/<span class="hljs-number">202</span> cases passed (<span class="hljs-number">96</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">36</span>.<span class="hljs-number">77</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">27</span>.<span class="hljs-number">3</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.<a href="https://leetcode-cn.com/problems/path-sum/description/">路径总和</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (51.10%)</td><td align="center">425</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a><br><strong>Companies</strong><br><code>microsoft</code><br>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">5<br>             / \<br>           <span class="hljs-number"> 4 </span>  8<br>           /   / \<br>         <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br>         /  \      \<br>       <span class="hljs-number"> 7 </span>  <span class="hljs-number"> 2 </span>     1<br></code></pre></td></tr></table></figure><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p><hr><p><a href="https://leetcode-cn.com/problems/path-sum/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/path-sum/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>递归思想要看树最小规模，例：只看根节点及左右节点 5-4-8。如果根节点没有值，则返回 false；如果不是叶子节点，则去判断左边路径或者右边路径的和是否符合需求，传入左节点及 sum-root.val。如果没有左右节点，则直接判断值是否等于 sum。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=112 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [112] 路径总和</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">sum</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, sum</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) <span class="hljs-keyword">return</span> sum === root.val;<br>  <span class="hljs-keyword">return</span> (<br>    hasPathSum(root.left, sum - root.val) ||<br>    hasPathSum(root.right, sum - root.val)<br>  );<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">114</span>/<span class="hljs-number">114</span> cases passed (<span class="hljs-number">100</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">33</span>.<span class="hljs-number">48</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">25</span>.<span class="hljs-number">29</span> % of javascript submissions (<span class="hljs-number">41</span>.<span class="hljs-number">5</span> MB)<br></code></pre></td></tr></table></figure><h1 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299.猜数字游戏"></a>299.<a href="https://leetcode-cn.com/problems/bulls-and-cows/description/">猜数字游戏</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (48.45%)</td><td align="center">94</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/hash-table"><code>hash-table</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>你在和朋友一起玩 <a href="https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p><ol><li>你写出一个秘密数字，并请朋友猜这个数字是多少。</li><li>朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。</li><li>朋友根据提示继续猜，直到猜出秘密数字。</li></ol><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 <code>xAyB</code> ，<code>x</code> 和 <code>y</code> 都是数字，<code>A</code> 表示公牛，用 <code>B</code> 表示奶牛。</p><ul><li><code>xA</code> 表示有 <code>x</code> 位数字出现在秘密数字中，且位置都与秘密数字一致。</li><li><code>yB</code> 表示有 <code>y</code> 位数字出现在秘密数字中，但位置与秘密数字不一致。</li></ul><p>请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">secret</span> = <span class="hljs-string">&quot;1807&quot;</span>, <span class="hljs-attr">guess</span> = <span class="hljs-string">&quot;7810&quot;</span><br>输出: <span class="hljs-string">&quot;1A3B&quot;</span><br>解释: <span class="hljs-number">1</span> 公牛和 <span class="hljs-number">3</span> 奶牛。公牛是 <span class="hljs-number">8</span>，奶牛是 <span class="hljs-number">0</span>, <span class="hljs-number">1</span> 和 <span class="hljs-number">7</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">secret</span> = <span class="hljs-string">&quot;1123&quot;</span>, <span class="hljs-attr">guess</span> = <span class="hljs-string">&quot;0111&quot;</span><br>输出: <span class="hljs-string">&quot;1A1B&quot;</span><br>解释: 朋友猜测数中的第一个 <span class="hljs-number">1</span> 是公牛，第二个或第三个 <span class="hljs-number">1</span> 可被视为奶牛。<br></code></pre></td></tr></table></figure><p>**说明: **你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p><hr><p><a href="https://leetcode-cn.com/problems/bulls-and-cows/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/bulls-and-cows/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先遍历两个字符串，求得完全一样的数的个数，并将其移出数组，同时将不同的数及其个数存入 map。再遍历猜测的字符串，如果在 map 中，则奶牛数+1，并把 map 中的数量减一，相当于互相抵消。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=299 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [299] 猜数字游戏</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">secret</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">guess</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getHint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">secret, guess</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  secret = secret.split(<span class="hljs-string">&quot;&quot;</span>);<br>  guess = guess.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> bullsCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> cowsCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; secret.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (secret[i] === guess[i]) &#123;<br>      secret.splice(i, <span class="hljs-number">1</span>);<br>      guess.splice(i, <span class="hljs-number">1</span>);<br>      bullsCount++;<br>      i--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.set(secret[i], map.get(secret[i]) ? map.get(secret[i]) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; secret.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (map.has(guess[i])) &#123;<br>      <span class="hljs-keyword">if</span> (map.get(guess[i]) === <span class="hljs-number">1</span>) map.delete(guess[i]);<br>      <span class="hljs-keyword">else</span> map.set(guess[i], map.get(guess[i]) - <span class="hljs-number">1</span>);<br>      cowsCount++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;bullsCount&#125;</span>A<span class="hljs-subst">$&#123;cowsCount&#125;</span>B`</span>;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">152</span>/<span class="hljs-number">152</span> cases passed (<span class="hljs-number">100</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">45</span>.<span class="hljs-number">97</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">17</span>.<span class="hljs-number">36</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月12日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8812%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt557.反转字符串中的单词 III、Lt448.找到所有数组中消失的数字、Lt572.另一个树的子树</p><span id="more"></span><h1 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557.反转字符串中的单词 III"></a>557.<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/description/">反转字符串中的单词 III</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (73.39%)</td><td align="center">241</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/string"><code>string</code></a><br><strong>Companies</strong><br><code>zappos</code><br>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;Let&#x27;s take LeetCode contest&quot;</span><br>输出：<span class="hljs-string">&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>****</strong>提示：<strong>****</strong></p><ul><li>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</li></ul><hr><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>取出每个字符为数组，再遍历个数组，将每个元素反转后再拼接回字符串</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=557 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [557] 反转字符串中的单词 III</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseWords = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> s<br>    .split(<span class="hljs-string">&quot; &quot;</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>))<br>    .join(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">30</span>/<span class="hljs-number">30</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">72</span>.<span class="hljs-number">77</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">90</span>.<span class="hljs-number">39</span> % of javascript submissions (<span class="hljs-number">44</span>.<span class="hljs-number">2</span> MB)<br></code></pre></td></tr></table></figure><h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/description/">找到所有数组中消失的数字</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (60.04%)</td><td align="center">457</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a><br><strong>Companies</strong><br><code>google</code><br>给定一个范围在   1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。<br>您能在不使用额外空间且时间复杂度为<em>O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。<br>*</em>示例:**</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入:<br><span class="hljs-string">[4,3,2,7,8,2,3,1]</span><br>输出:<br><span class="hljs-string">[5,6]</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>set 去重，再算出长度和缺少的长度，再循环根据下标添加缺少数据结果数组，遍历完后看看 dupLength 是否还大于 0，说明还有没补上的数据，补上后就是结果。<br>自己的思路求解冗余、占用空间大，还多了排序的步骤，通过集合的 has 方法可以解决，具体看改进算法。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="最初"><a href="#最初" class="headerlink" title="最初"></a>最初</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=448 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [448] 找到所有数组中消失的数字</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findDisappearedNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> oriLength = nums.length;<br>  nums = [...new <span class="hljs-built_in">Set</span>(nums)].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">let</span> dupLength = oriLength - nums.length;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums[nums.length - <span class="hljs-number">1</span>] &amp;&amp; dupLength &gt; <span class="hljs-number">0</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] !== i + <span class="hljs-number">1</span>) &#123;<br>      nums.splice(i, <span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>      res.push(i + <span class="hljs-number">1</span>);<br>      i--;<br>      dupLength--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dupLength; i++) &#123;<br>    nums.push(nums[nums.length - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    res.push(nums[nums.length - <span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">34</span>/<span class="hljs-number">34</span> cases passed (<span class="hljs-number">344</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">30</span>.<span class="hljs-number">62</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">17</span>.<span class="hljs-number">5</span> % of javascript submissions (<span class="hljs-number">49</span>.<span class="hljs-number">5</span> MB)<br></code></pre></td></tr></table></figure><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findDisappearedNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> numsSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums);<br>  <span class="hljs-keyword">const</span> disappearedNums = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!numsSet.has(i)) &#123;<br>      disappearedNums.push(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> disappearedNums;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">34</span>/<span class="hljs-number">34</span> cases passed (<span class="hljs-number">140</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">62</span>.<span class="hljs-number">63</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">22</span>.<span class="hljs-number">5</span> % of javascript submissions (<span class="hljs-number">49</span>.<span class="hljs-number">2</span> MB)<br></code></pre></td></tr></table></figure><h1 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/description/">另一个树的子树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (47.05%)</td><td align="center">351</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a><br><strong>Companies</strong><br><code>ebay</code> | <code>facebook</code> | <code>google</code><br>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。<br><strong>示例 1:</strong><br>给定的树 s:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">4</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。<br><strong>示例 2:</strong><br>给定的树 s：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br>    /<br>   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">4</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回 <strong>false</strong>。</p><hr><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将问题拆开，相当于，遍历一颗树，判断当前节点是否与对应的节点完全一致，参考 100.<a href="https://leetcode-cn.com/problems/same-tree/description/">相同的树</a>。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=572 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [572] 另一个树的子树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSubtree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (isEqual(s, t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);<br>&#125;;<br><br><span class="hljs-keyword">const</span> isEqual = <span class="hljs-function">(<span class="hljs-params">s, t</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!s &amp;&amp; !t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (!s || !t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> (<br>    s.val === t.val &amp;&amp; isEqual(s.left, t.left) &amp;&amp; isEqual(s.right, t.right)<br>  );<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">183</span>/<span class="hljs-number">183</span> cases passed (<span class="hljs-number">112</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">59</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">15</span>.<span class="hljs-number">33</span> % of javascript submissions (<span class="hljs-number">44</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月13日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8813%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt257.二叉树的所有路径、Lt283.移动零、Lt392.判断子序列</p><span id="more"></span><h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.<a href="https://leetcode-cn.com/problems/binary-tree-paths/description/">二叉树的所有路径</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (66.05%)</td><td align="center">363</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a><br><strong>Companies</strong><br><code>apple</code> | <code>facebook</code> | <code>google</code><br>给定一个二叉树，返回所有从根节点到叶子节点的路径。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>   <span class="hljs-number">1</span><br> /   <span class="hljs-string">\</span><br><span class="hljs-number">2</span>     <span class="hljs-number">3</span><br> <span class="hljs-string">\</span><br>  <span class="hljs-number">5</span><br>输出: [<span class="hljs-string">&quot;1-&gt;2-&gt;5&quot;</span>, <span class="hljs-string">&quot;1-&gt;3&quot;</span>]<br>解释: 所有根节点到叶子节点的路径为: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/binary-tree-paths/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和之前求是否存在一条路径的和和目标值相同类似，都是深度优先遍历所有根到节点的路径。树的题思路都是用最小规模来看。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=257 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [257] 二叉树的所有路径</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> tmp = [];<br>  visit(root, res, tmp);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root, res, tmp</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>  tmp.push(root.val);<br>  <span class="hljs-keyword">if</span> (root &amp;&amp; !root.left &amp;&amp; !root.right) &#123;<br>    res.push(tmp.join(<span class="hljs-string">&quot;-&gt;&quot;</span>));<br>  &#125;<br>  <span class="hljs-keyword">if</span> (root.left) visit(root.left, res, tmp);<br>  <span class="hljs-keyword">if</span> (root.right) visit(root.right, res, tmp);<br>  tmp.pop();<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">209</span>/<span class="hljs-number">209</span> cases passed (<span class="hljs-number">88</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">61</span>.<span class="hljs-number">62</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">64</span>.<span class="hljs-number">82</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.<a href="https://leetcode-cn.com/problems/move-zeroes/description/">移动零</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (62.28%)</td><td align="center">731</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/two-pointers"><code>two-pointers</code></a><br><strong>Companies</strong><br><code>bloomberg</code> | <code>facebook</code><br>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<br><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/move-zeroes/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/move-zeroes/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>是 0 则删除放到最后，没有难度，但应该有更好的解法。</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>遍历数组，如果 i 指向的不为 0，则将 nums[k]设为 i 指向的值，k++。遍历完后，前面都为有数值的值，将剩下的都设为 0 即可。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=283 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [283] 移动零</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] === <span class="hljs-number">0</span>) &#123;<br>      nums.push(nums.splice(i, <span class="hljs-number">1</span>));<br>      i--;<br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">21</span>/<span class="hljs-number">21</span> cases passed (<span class="hljs-number">100</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">28</span>.<span class="hljs-number">13</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">44</span>.<span class="hljs-number">37</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">7</span> MB)<br></code></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=283 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [283] 移动零</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] !== <span class="hljs-number">0</span>) &#123;<br>      nums[j++] = nums[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt; nums.length) &#123;<br>    nums[j++] = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">21</span>/<span class="hljs-number">21</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">52</span>.<span class="hljs-number">73</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">34</span>.<span class="hljs-number">35</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.<a href="https://leetcode-cn.com/problems/is-subsequence/description/">判断子序列</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (50.53%)</td><td align="center">319</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/binary-search"><code>binary-search</code></a> | <a href="https://leetcode.com/tag/dynamic-programming"><code>dynamic-programming</code></a> | <a href="https://leetcode.com/tag/greedy"><code>greedy</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。<br>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。<br>**示例  1:**<br>**s** = <code>&quot;abc&quot;</code>, **t** = <code>&quot;ahbgdc&quot;</code><br>返回 <code>true</code>.<br>**示例  2:**<br>**s** = <code>&quot;axc&quot;</code>, **t** = <code>&quot;ahbgdc&quot;</code><br>返回 <code>false</code>.<br>**后续挑战** **:**<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？<br><strong>致谢:</strong><br>特别感谢** **<a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p><hr><p><a href="https://leetcode-cn.com/problems/is-subsequence/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/is-subsequence/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="遍历-t"><a href="#遍历-t" class="headerlink" title="遍历 t"></a>遍历 t</h4><p>遍历 t，看是否存在 s</p><h4 id="遍历-s"><a href="#遍历-s" class="headerlink" title="遍历 s"></a>遍历 s</h4><p>使用 indexof 遍历 s</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="遍历-t-1"><a href="#遍历-t-1" class="headerlink" title="遍历 t"></a>遍历 t</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=392 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [392] 判断子序列</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSubsequence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length &amp;&amp; k &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (t[i] === s[k]) k++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> k === s.length;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">15</span>/<span class="hljs-number">15</span> cases passed (<span class="hljs-number">96</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">27</span>.<span class="hljs-number">14</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">40</span>.<span class="hljs-number">49</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure><h4 id="遍历-s-1"><a href="#遍历-s-1" class="headerlink" title="遍历 s"></a>遍历 s</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=392 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [392] 判断子序列</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSubsequence = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tmp = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> index = t.indexOf(s[i], tmp + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    tmp = index;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">15</span>/<span class="hljs-number">15</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">80</span>.<span class="hljs-number">2</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">69</span>.<span class="hljs-number">63</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">7</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>dfs</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月14日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8814%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt121.买卖股票的最佳时机、122.买卖股票的最佳时机 II、剑指 Offer 62. 圆圈中最后剩下的数字、剑指 Offer 55 - I. 二叉树的深度</p><span id="more"></span><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (54.88%)</td><td align="center">1175</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/dynamic-programming"><code>dynamic-programming</code></a><br><strong>Companies</strong><br><code>amazon</code> | <code>bloomberg</code> | <code>facebook</code> | <code>microsoft</code> | <code>uber</code><br>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/discuss/?currentPage=1&orderBy=most_votes&query=">Discussion</a> | <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>双重循环，从最后一个开始计算，当前卖出可得的最大利润，计算完再令下标减一，继续计算。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ol><li>记录【今天之前买入的最小值】</li><li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li><li>比较【每天的最大获利】，取最大值即可</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=121 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [121] 买卖股票的最佳时机</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = prices.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (prices[i] - prices[j] &gt; <span class="hljs-number">0</span> &amp;&amp; prices[i] - prices[j] &gt; max)<br>        max = prices[i] - prices[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">200</span>/<span class="hljs-number">200</span> cases passed (<span class="hljs-number">440</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">10</span>.<span class="hljs-number">22</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">37</span>.<span class="hljs-number">05</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=121 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [121] 买卖股票的最佳时机</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (prices.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> price <span class="hljs-keyword">of</span> prices) &#123;<br>    min = <span class="hljs-built_in">Math</span>.min(min, price);<br>    max = <span class="hljs-built_in">Math</span>.max(price - min, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">200</span>/<span class="hljs-number">200</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">81</span>.<span class="hljs-number">42</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">11</span>.<span class="hljs-number">25</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122.买卖股票的最佳时机 II"></a>122.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机 II</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (63.06%)</td><td align="center">847</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/greedy"><code>greedy</code></a><br><strong>Companies</strong><br><code>bloomberg</code><br>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例  3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><hr><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/?currentPage=1&orderBy=most_votes&query=">Discussion</a> | <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>[7, 1, 5, 6]  第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=122 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [122] 买卖股票的最佳时机 II</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (prices.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">200</span>/<span class="hljs-number">200</span> cases passed (<span class="hljs-number">76</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">87</span>.<span class="hljs-number">1</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">24</span>.<span class="hljs-number">03</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h1><p>0,1,,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。<br>例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。<br><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-section">输入: n = 5, m = 3</span><br><span class="hljs-section">输出: 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 10, m = 17</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4><p>使用队列特性模拟圆圈，将报数的前几个移动到队列末尾，移出第一个。当 n 很大时，造成超时。</p><h4 id="数学公式-约瑟夫环"><a href="#数学公式-约瑟夫环" class="headerlink" title="数学公式-约瑟夫环"></a>数学公式-约瑟夫环</h4><p>约瑟夫环是一个经典的数学问题，我们不难发现这样的依次报数，似乎有规律可循。为了方便导出递推式，我们重新定义一下题目。<br><strong>问题：</strong> N 个人编号为 1，2，……，N，依次报数，每报到 M 时，杀掉那个人，求最后胜利者的编号。<br>这边我们先把结论抛出了。之后带领大家一步一步的理解这个公式是什么来的。<br><strong>递推公式：</strong><br><strong><img src="https://cdn.nlark.com/yuque/__latex/d7191cdfda23b5dab816560386e500a9.svg#card=math&code=f%28N%2CM%29%3D%28f%28N%E2%88%921%2CM%29%2BM%29%25N&height=20&width=227"></strong></p><ul><li><img src="https://cdn.nlark.com/yuque/__latex/9aa54be5b48e731aa0078eef1a998c09.svg#card=math&code=f%28N%2CM%29&height=20&width=62">表示，N 个人报数，每报到 M 时杀掉那个人，最终胜利者的编号</li><li><img src="https://cdn.nlark.com/yuque/__latex/4b97c4a6d683270439a877eb3975f91d.svg#card=math&code=f%28N%E2%88%921%2CM%29&height=20&width=91">表示，N-1 个人报数，每报到 M 时杀掉那个人，最终胜利者的编号</li></ul><p>下面我们不用字母表示每一个人，而用数字。<br>1、2、3、4、5、6、7、8、9、10、11<br>表示 11 个人，他们先排成一排，假设每报到 3 的人被杀掉。</p><ul><li>刚开始时，头一个人编号是 1，从他开始报数，第一轮被杀掉的是编号 3 的人。</li><li>编号 4 的人从 1 开始重新报数，这时候我们可以认为编号 4 这个人是队伍的头。第二轮被杀掉的是编号 6 的人。</li><li>编号 7 的人开始重新报数，这时候我们可以认为编号 7 这个人是队伍的头。第三轮被杀掉的是编号 9 的人。</li><li>……</li><li>第九轮时，编号 2 的人开始重新报数，这时候我们可以认为编号 2 这个人是队伍的头。这轮被杀掉的是编号 8 的人。</li><li>下一个人还是编号为 2 的人，他从 1 开始报数，不幸的是他在这轮被杀掉了。</li><li>最后的胜利者是编号为 7 的人。</li></ul><p>下图表示这一过程（先忽视绿色的一行）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600066946131-8b9b1c8a-30e3-4573-837f-9a8277e957c0.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&originHeight=320&originWidth=544&size=0&status=done&style=none&width=544"><br>现在再来看我们递推公式是怎么得到的！<br><strong>将上面表格的每一行看成数组，这个公式描述的是：幸存者在这一轮的下标位置</strong></p><ul><li>f(1,3)f(1,3))：只有 1 个人了，那个人就是获胜者，他的下标位置是 0</li><li>f(2,3)=(f(1,3)+3)%2=3%2=1f(2,3)=(f(1,3)+3)%2=3%2=1：在有 2 个人的时候，胜利者的下标位置为 1</li><li>f(3,3)=(f(2,3)+3)%3=4%3=1f(3,3)=(f(2,3)+3)%3=4%3=1：在有 3 个人的时候，胜利者的下标位置为 1</li><li>f(4,3)=(f(3,3)+3)%4=4%4=0f(4,3)=(f(3,3)+3)%4=4%4=0：在有 4 个人的时候，胜利者的下标位置为 0</li><li>……</li><li>f(11,3)=6f(11,3)=6</li></ul><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="模拟队列-1"><a href="#模拟队列-1" class="headerlink" title="模拟队列"></a>模拟队列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lastRemaining = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, m</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> queue = [...Array(n).keys()];<br>  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = (m - <span class="hljs-number">1</span>) % queue.length;<br>    queue = queue.concat(queue.splice(<span class="hljs-number">0</span>, count));<br>    queue.shift();<br>  &#125;<br>  <span class="hljs-keyword">return</span> queue.shift();<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="数学公式-约瑟夫环-1"><a href="#数学公式-约瑟夫环-1" class="headerlink" title="数学公式-约瑟夫环"></a>数学公式-约瑟夫环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lastRemaining = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, m</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    p = (p + m) % i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h1><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度  3 。</p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p>注意：本题与主站 104  题相同：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>树题套路，最小规模解析，再递归即可。如果为叶子节点，返回 1。如果两个节点都有，返回 1+左边或右边子树的最大深度。只有左右节点其中一个，返回 1+左右子树的深度。</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> visit(root);<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left &amp;&amp; root.right)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(visit(root.left), visit(root.right));<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + visit(root.left);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + visit(root.right);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>递归</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月10日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8810%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt606.根据二叉树创建字符串、Lt617.合并二叉树、Lt645.错误的集合</p><span id="more"></span><h1 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606.根据二叉树创建字符串"></a>606.<a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/description/">根据二叉树创建字符串</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (54.64%)</td><td align="center">143</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/string"><code>string</code></a> | <a href="https://leetcode.com/tag/tree"><code>tree</code></a><br><strong>Companies</strong><br><code>amazon</code><br>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。<br>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。<br><strong>示例 1:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: 二叉树: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>       <span class="hljs-number">1</span><br>     /   \<br>    <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br>   /<br>  <span class="hljs-number">4</span><br>输出: <span class="hljs-string">&quot;1(2(4))(3)&quot;</span><br>解释: 原本将是“<span class="hljs-number">1</span><span class="hljs-comment">(2(4)</span><span class="hljs-comment">()</span>)<span class="hljs-comment">(3()</span>)”，<br>在你省略所有不必要的空括号对之后，<br>它将是“<span class="hljs-number">1</span><span class="hljs-comment">(2(4)</span>)<span class="hljs-comment">(3)</span>”。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: 二叉树: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>       <span class="hljs-number">1</span><br>     /   <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br>     <span class="hljs-string">\</span><br>      <span class="hljs-number">4</span><br>输出: <span class="hljs-string">&quot;1(2()(4))(3)&quot;</span><br>解释: 和第一个示例相似，<br>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先序遍历，如果只有左节点，返回 val(left)。如果只有右节点，返回 val()(right)。如果有左节点和右节点，返回 val(left)(right)，如果没有节点值返回 val。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=606 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [606] 根据二叉树创建字符串</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> tree2str = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> visit(t);<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (node) &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;<br>      <span class="hljs-keyword">return</span> node.val + <span class="hljs-string">&quot;&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left &amp;&amp; !node.right) &#123;<br>      str = <span class="hljs-string">`<span class="hljs-subst">$&#123;node.val&#125;</span>(<span class="hljs-subst">$&#123;visit(node.left)&#125;</span>)`</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!node.left &amp;&amp; node.right) &#123;<br>      str = <span class="hljs-string">`<span class="hljs-subst">$&#123;node.val&#125;</span>()(<span class="hljs-subst">$&#123;visit(node.right)&#125;</span>)`</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      str = <span class="hljs-string">`<span class="hljs-subst">$&#123;node.val&#125;</span>(<span class="hljs-subst">$&#123;visit(node.left)&#125;</span>)(<span class="hljs-subst">$&#123;visit(node.right)&#125;</span>)`</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">162</span>/<span class="hljs-number">162</span> cases passed (<span class="hljs-number">108</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">25</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">70</span> % of javascript submissions (<span class="hljs-number">42</span>.<span class="hljs-number">7</span> MB)<br></code></pre></td></tr></table></figure><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">合并二叉树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (77.20%)</td><td align="center">462</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a><br><strong>Companies</strong><br><code>amazon</code><br>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为  **NULL 的节点将直接作为新二叉树的节点。<br>**示例  1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:<br>Tree<span class="hljs-number"> 1 </span>                    Tree 2<br>         <span class="hljs-number"> 1 </span>                        2<br>         / \                       / \<br>       <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span>  3<br>       /                           \   \<br>     <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span>  7<br>输出:<br>合并后的树:<br>     3<br>    / \<br>  <span class="hljs-number"> 4 </span>  5<br>  / \   \<br><span class="hljs-number"> 5 </span> <span class="hljs-number"> 4 </span>  7<br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><hr><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>当 t1，t2 都存在时，将 t1 的值加上 t2 的值赋值给 t1。然后对 t1 的左右节点递归计算。当 t1 和 t2 有一个不存在或都不存在时，返回另一个边余下的节点，余下的一边不需要进行计算。当到根节点时直接返回已经加上 t2 的 t1，所以 t1 应该放在 || 前面。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=617 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [617] 合并二叉树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> &#123; VisitorKeys &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;estraverse&quot;</span>);<br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t1</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">t2</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t1, t2</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (t1 &amp;&amp; t2) &#123;<br>    t1.val += t2.val;<br>    t1.left = mergeTrees(t1.left, t2.left);<br>    t1.right = mergeTrees(t1.right, t2.right);<br>  &#125;<br>  <span class="hljs-keyword">return</span> t1 || t2;<br>&#125;;<br><br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">183</span>/<span class="hljs-number">183</span> cases passed (<span class="hljs-number">136</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">27</span>.<span class="hljs-number">42</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">21</span>.<span class="hljs-number">84</span> % of javascript submissions (<span class="hljs-number">45</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645.错误的集合"></a>645.<a href="https://leetcode-cn.com/problems/set-mismatch/description/">错误的集合</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (42.30%)</td><td align="center">121</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/hash-table"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/math"><code>math</code></a><br><strong>Companies</strong><br><code>amazon</code><br>集合 <code>S</code> 包含从 1 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。<br>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,2,2,4]</span><br>输出: <span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定数组的长度范围是  [2, 10000]。</li><li>给定的数组是无序的。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/set-mismatch/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/set-mismatch/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>遍历数组，用 map 判断是否出现过，出现过添加到结果数组中。<br>对数组排序，如果当前元素不等于下标+1，数组中添加下标+1 的值。<br>如果遍历完都没有查到，则缺少的是最后一个数，同 nums 的长度。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=645 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [645] 错误的集合</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findErrorNums = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    <span class="hljs-keyword">if</span> (map.get(num)) &#123;<br>      res.push(num);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.set(num, map.get(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> sortArr = [...map.keys()].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">if</span> (<br>    !sortArr.some(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (e !== index + <span class="hljs-number">1</span>) &#123;<br>        res.push(index + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;)<br>  ) &#123;<br>    res.push(nums.length);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">49</span>/<span class="hljs-number">49</span> cases passed (<span class="hljs-number">156</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">20</span>.<span class="hljs-number">44</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">4</span> % of javascript submissions (<span class="hljs-number">48</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月8日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%888%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt819.最常见的单词、Lt118.杨辉三角、Lt119.杨辉三角 II</p><span id="more"></span><h1 id="819-最常见的单词"><a href="#819-最常见的单词" class="headerlink" title="819.最常见的单词"></a>819.<a href="https://leetcode-cn.com/problems/most-common-word/description/">最常见的单词</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (40.82%)</td><td align="center">72</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/dynamic-programming"><code>dynamic-programming</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。<br>题目保证至少有一个词不在禁用列表中，而且答案唯一。<br>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p><p><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>paragraph = <span class="hljs-string">&quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br>banned = [<span class="hljs-string">&quot;hit&quot;</span>]<br><span class="hljs-section">输出: &quot;ball&quot;</span><br><span class="hljs-section">解释:</span><br><span class="hljs-string">&quot;hit&quot;</span> 出现了3次，但它是一个禁用的单词。<br><span class="hljs-string">&quot;ball&quot;</span> 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。<br>注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 <span class="hljs-string">&quot;ball,&quot;</span>），<br><span class="hljs-string">&quot;hit&quot;</span>不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= 段落长度 &lt;= 1000</code></li><li><code>0 &lt;= 禁用单词个数 &lt;= 100</code></li><li><code>1 &lt;= 禁用单词长度 &lt;= 10</code></li><li>答案是唯一的, 且都是小写字母  (即使在 <code>paragraph</code> 里是大写的，即使是一些特定的名词，答案都是小写的。)</li><li><code>paragraph</code> 只包含字母、空格和下列标点符号<code>!?&#39;,;.</code></li><li>不存在没有连字符或者带有连字符的单词。</li><li>单词里只包含字母，不会出现省略号或者其他标点符号。</li></ul><hr><p><a href="https://leetcode-cn.com/problems/most-common-word/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/most-common-word/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目 tag 是动态规划，这里使用对象，字符串，正则，数组的方法来强解。字符串转为小写，正则去除标点，split 分为数组，数组遍历生成类哈希表，再根据 banned 表筛选和降序，返回第一个元素</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=819 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [819] 最常见的单词</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">paragraph</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">banned</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mostCommonWord = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paragraph, banned</span>) </span>&#123;<br>  paragraph = paragraph<br>    .toLowerCase()<br>    .replace(<span class="hljs-regexp">/([^A-Za-z])/g</span>, <span class="hljs-string">&quot; &quot;</span>)<br>    .split(<span class="hljs-string">&quot; &quot;</span>)<br>    .filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e);<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> paragraph) &#123;<br>    <span class="hljs-keyword">if</span> (obj[arr]) &#123;<br>      obj[arr] += <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj[arr] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Object</span>.entries(obj)<br>    .filter(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (banned.length) &#123;<br>        <span class="hljs-keyword">return</span> !banned.includes(e[<span class="hljs-number">0</span>]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">Number</span>(a[<span class="hljs-number">1</span>]));<br>  <span class="hljs-keyword">if</span> (res.length) &#123;<br>    <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">47</span>/<span class="hljs-number">47</span> cases passed (<span class="hljs-number">104</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">22</span>.<span class="hljs-number">56</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">24</span>.<span class="hljs-number">69</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">4</span> MB)<br></code></pre></td></tr></table></figure><h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.<a href="https://leetcode-cn.com/problems/pascals-triangle/description/">杨辉三角</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (67.28%)</td><td align="center">343</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a><br><strong>Companies</strong><br><code>apple</code> | <code>twitter</code><br>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows *行。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/1639155/1599530047203-fff1a616-1e53-4727-90ec-01212586ed7e.gif#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=260&size=0&status=done&style=none&width=260"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>*</em>示例:**</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: 5<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">     <span class="hljs-comment">[1]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[1,1]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,3,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,4,6,4,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/pascals-triangle/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/pascals-triangle/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>没有特别思路，双重循环即可。每行的第一个和最后一个添加 1。使用错行相加，例如当前行的第二个为上一行的第一个加第二个，使用 k 记录上一行的下标值，不断加一。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=118 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [118] 杨辉三角</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">numRows</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> generate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numRows</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>    temp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span> || j === i) temp.push(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">else</span> &#123;<br>        temp.push(res[i - <span class="hljs-number">1</span>][k] + res[i - <span class="hljs-number">1</span>][++k]);<br>      &#125;<br>    &#125;<br>    res.push(temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">15</span>/<span class="hljs-number">15</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">53</span>.<span class="hljs-number">67</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">06</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">1</span> MB)<br></code></pre></td></tr></table></figure><h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119.杨辉三角 II"></a>119.<a href="https://leetcode-cn.com/problems/pascals-triangle-ii/description/">杨辉三角 II</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (61.84%)</td><td align="center">176</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a><br><strong>Companies</strong><br><code>amazon</code><br>给定一个非负索引 <em>k_，其中 _k</em> ≤ 33，返回杨辉三角的第 <em>k *行。<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/1639155/1599534630216-c539089d-b6e8-42b1-b815-711ed14f6c31.gif#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=260&size=0&status=done&style=none&width=260"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>*</em>示例:**</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 3</span><br><span class="hljs-section">输出: [1,3,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p><hr><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/pascals-triangle-ii/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>可以根据规律推出，每一行每一个数即为排列公式的 Cnk 求解方案，例如第四行第一个为 C40=1 第二个为 C41 = 4，公式如下<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1639155/1599534785120-0ea2b64f-6dd8-41ce-bb65-489c8993a3d5.jpeg#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=518&size=0&status=done&style=none&width=518"></p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=119 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [119] 杨辉三角 II</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">rowIndex</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getRow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rowIndex</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">const</span> getCombineNumber = <span class="hljs-function">(<span class="hljs-params">n, k</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> getFact(n) / (getFact(k) * getFact(n - k));<br>  &#125;;<br>  <span class="hljs-keyword">const</span> getFact = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> res = num;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">1</span>) &#123;<br>      num--;<br>      res *= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rowIndex + <span class="hljs-number">1</span>; i++) &#123;<br>    res.push(getCombineNumber(rowIndex, i));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">34</span>/<span class="hljs-number">34</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">20</span>.<span class="hljs-number">96</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">10</span>.<span class="hljs-number">38</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">1</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>数学</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月9日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%889%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt441.排列硬币、Lt500.键盘行、Lt506.相对名次</p><span id="more"></span><h1 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441.排列硬币"></a>441.<a href="https://leetcode-cn.com/problems/arranging-coins/description/">排列硬币</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (41.34%)</td><td align="center">73</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/math"><code>math</code></a> | <a href="https://leetcode.com/tag/binary-search"><code>binary-search</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>你总共有 <em>n *枚硬币，你需要将它们摆成一个阶梯形状，第 *k *行就必须正好有 *k *枚硬币。<br>给定一个数字 _n_，找出可形成完整阶梯行的总行数。<br>*n *是一个非负整数，并且在 32 位有符号整型的范围内。<br>*</em>示例 1:**</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">n</span> = 5<br>硬币可排列成以下几行:<br>¤<br>¤ ¤<br>¤ ¤<br>因为第三行不完整，所以返回2.<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">n</span> = 8<br>硬币可排列成以下几行:<br>¤<br>¤ ¤<br>¤ ¤ ¤<br>¤ ¤<br>因为第四行不完整，所以返回3.<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/arranging-coins/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/arranging-coins/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>循环减，直到个数小于 0，当当前剩下的个数大于该行需要的个数时另行数加一，将总数减去相应的数量。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=441 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [441] 排列硬币</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arrangeCoins = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i = n;<br>  <span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= row + <span class="hljs-number">1</span>) &#123;<br>      row++;<br>    &#125;<br>    i -= row;<br>  &#125;<br>  <span class="hljs-keyword">return</span> row;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">1336</span>/<span class="hljs-number">1336</span> cases passed (<span class="hljs-number">144</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">11</span>.<span class="hljs-number">42</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">56</span>.<span class="hljs-number">41</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500.键盘行"></a>500.<a href="https://leetcode-cn.com/problems/keyboard-row/description/">键盘行</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (69.78%)</td><td align="center">105</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/hash-table"><code>hash-table</code></a><br><strong>Companies</strong><br><code>mathworks</code><br>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1599614523182-325ba6a7-62a2-442d-ab24-693cdc4facac.png#align=left&display=inline&height=200&margin=%5Bobject%20Object%5D&originHeight=267&originWidth=800&size=0&status=done&style=none&width=600"></p><p><strong>示例：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Alaska&quot;</span>, <span class="hljs-string">&quot;Dad&quot;</span>, <span class="hljs-string">&quot;Peace&quot;</span>]</span><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Alaska&quot;</span>, <span class="hljs-string">&quot;Dad&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>你可以重复使用键盘上同一字符。</li><li>你可以假设输入的字符串将只包含字母。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/keyboard-row/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/keyboard-row/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>使用数组建立哈希表。循环确认每一个字母是否都属于同一行。</p><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>使用 test 和正则循环判断加入结果数组即可。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=500 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [500] 键盘行</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findWords = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> rowMap = &#123;<br>    <span class="hljs-attr">q</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">w</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">e</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">r</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">t</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">u</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">i</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">o</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">p</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">Q</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">W</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">E</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">R</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">T</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">Y</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">U</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">O</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">P</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">s</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">d</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">f</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">g</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">h</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">j</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">k</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">l</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">A</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">S</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">F</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">G</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">H</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">J</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">K</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">z</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">v</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">n</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">m</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">Z</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">B</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">N</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">3</span>,<br>  &#125;;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word <span class="hljs-keyword">of</span> words) &#123;<br>    <span class="hljs-keyword">const</span> firstWordRow = rowMap[word[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> word) &#123;<br>      <span class="hljs-keyword">if</span> (rowMap[arr] != firstWordRow) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) res.push(word);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">22</span>/<span class="hljs-number">22</span> cases passed (<span class="hljs-number">68</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">84</span>.<span class="hljs-number">47</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">16</span>.<span class="hljs-number">16</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h4 id="正则-1"><a href="#正则-1" class="headerlink" title="正则"></a>正则</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=500 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [500] 键盘行</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">words</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findWords = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">words</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/^([qwertyuiop]+|[asdfghjkl]+|[zxcvbnm]+)$/i</span>;<br>  <span class="hljs-keyword">return</span> words.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> regexp.test(item));<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">22</span>/<span class="hljs-number">22</span> cases passed (<span class="hljs-number">76</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">61</span>.<span class="hljs-number">64</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">05</span> % of javascript submissions (<span class="hljs-number">38</span> MB)<br></code></pre></td></tr></table></figure><h1 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506.相对名次"></a>506.<a href="https://leetcode-cn.com/problems/relative-ranks/description/">相对名次</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (54.70%)</td><td align="center">55</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/Unknown"><code>Unknown</code></a><br><strong>Companies</strong><br><code>google</code><br>给出 <strong>N</strong> 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。<br>(注：分数越高的选手，排名越靠前。)<br><strong>示例 1:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[5, 4, 3, 2, 1]</span><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Gold Medal&quot;</span>, <span class="hljs-string">&quot;Silver Medal&quot;</span>, <span class="hljs-string">&quot;Bronze Medal&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>]</span><br>解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (<span class="hljs-string">&quot;Gold Medal&quot;</span>, <span class="hljs-string">&quot;Silver Medal&quot;</span> and <span class="hljs-string">&quot;Bronze Medal&quot;</span>).<br>余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>N 是一个正整数并且不会超过  10000。</li><li>所有运动员的成绩都不相同。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/relative-ranks/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/relative-ranks/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>使用 map 给生成一个{sort:0,score:1}记录成绩和原来排序的对象数组，再根据成绩排序，再根据下标给每一个对象添加 medal 字段，再根据原来的排序排列回来，再将每一个对象的 medal 字段提取出来为一个数组返回。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用 hash 表存储原来的排序，只需要进行一次排序，且不需要添加字段。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=506 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [506] 相对名次</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findRelativeRanks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums<br>    .map(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">score</span>: e,<br>        <span class="hljs-attr">sort</span>: index,<br>      &#125;;<br>    &#125;)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b.score) - <span class="hljs-built_in">Number</span>(a.score))<br>    .map(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> medal;<br>      <span class="hljs-keyword">switch</span> (index) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          medal = <span class="hljs-string">&quot;Gold Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>          medal = <span class="hljs-string">&quot;Silver Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>          medal = <span class="hljs-string">&quot;Bronze Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          medal = index + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(e, &#123;<br>        medal,<br>      &#125;);<br>    &#125;)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a.sort) - <span class="hljs-built_in">Number</span>(b.sort))<br>    .map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.medal);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">17</span>/<span class="hljs-number">17</span> cases passed (<span class="hljs-number">108</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">68</span>.<span class="hljs-number">71</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">22</span>.<span class="hljs-number">37</span> % of javascript submissions (<span class="hljs-number">41</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=506 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [506] 相对名次</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findRelativeRanks = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length);<br>  nums<br>    .map(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> &#123;<br>      map.set(e, index);<br>      <span class="hljs-keyword">return</span> e;<br>    &#125;)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b) - <span class="hljs-built_in">Number</span>(a))<br>    .map(<span class="hljs-function">(<span class="hljs-params">e, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> medal;<br>      <span class="hljs-keyword">switch</span> (index) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          medal = <span class="hljs-string">&quot;Gold Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>          medal = <span class="hljs-string">&quot;Silver Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>          medal = <span class="hljs-string">&quot;Bronze Medal&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          medal = index + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      res[map.get(e)] = medal;<br>    &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">17</span>/<span class="hljs-number">17</span> cases passed (<span class="hljs-number">104</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">75</span>.<span class="hljs-number">51</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">38</span>.<span class="hljs-number">16</span> % of javascript submissions (<span class="hljs-number">41</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月4日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%884%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt226.翻转二叉树、Lt100.相同的树、Lt104.二叉树的最大深度、Lt111.二叉树的最小深度</p><span id="more"></span><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.<a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">翻转二叉树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (76.37%)</td><td align="center">557</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>翻转一棵二叉树。<br><strong>示例：</strong><br>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768">原问题</a> 启发的 ：<br>谷歌：我们 90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><hr><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/invert-binary-tree/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照先序遍历模式交换左右节点即可</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=226 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [226] 翻转二叉树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> &#123; reverse &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;core-js/fn/array&quot;</span>);<br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  visit(root, <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  reverse(node);<br>  visit(node.left);<br>  visit(node.right);<br>&#125;;<br><br><span class="hljs-keyword">const</span> reverse = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> tmp = node.left;<br>  node.left = node.right;<br>  node.right = tmp;<br>&#125;;<br><br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">68</span>/<span class="hljs-number">68</span> cases passed (<span class="hljs-number">96</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">11</span>.<span class="hljs-number">62</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">42</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">3</span> MB)<br></code></pre></td></tr></table></figure><h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.<a href="https://leetcode-cn.com/problems/same-tree/description/">相同的树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (60.13%)</td><td align="center">463</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a><br><strong>Companies</strong><br><code>bloomberg</code><br>给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br><strong>示例  1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span>   <span class="hljs-number"> 2 </span>  3<br>        [1,2,3],   [1,2,3]<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入:      <span class="hljs-number">1</span>          <span class="hljs-number">1</span><br>          /           \<br>         <span class="hljs-number">2</span>             <span class="hljs-number">2</span><br><span class="hljs-string">        [1,2]</span>,     [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例  3:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>  2<br>        [1,2,1],   [1,1,2]<br>输出: false<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/same-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/same-tree/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>按照递归的思想来进行深度遍历。如果两个节点都没有子节点则返回 true，如果两个节点其中一个不为空则返回 false，若两个节点都不为空，就轮流再比较左右节点。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=100 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [100] 相同的树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSameTree = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p, q</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> (<br>    p.val === q.val &amp;&amp;<br>    isSameTree(p.left, q.left) &amp;&amp;<br>    isSameTree(p.right, q.right)<br>  );<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">59</span>/<span class="hljs-number">59</span> cases passed (<span class="hljs-number">68</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">94</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">27</span>.<span class="hljs-number">28</span> % of javascript submissions (<span class="hljs-number">38</span> MB)<br></code></pre></td></tr></table></figure><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (74.96%)</td><td align="center">688</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a><br><strong>Companies</strong><br><code>apple</code> | <code>linkedin</code> | <code>uber</code> | <code>yahoo</code><br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度  3 。</p><hr><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对一个点来说，深度为左节点深度和右节点深度的最大值+1，如果这个点是叶子节点，则深度不再增加，返回 0</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=104 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [104] 二叉树的最大深度</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> root ? <span class="hljs-built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">39</span>/<span class="hljs-number">39</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">60</span>.<span class="hljs-number">28</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">20</span>.<span class="hljs-number">88</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (44.32%)</td><td align="center">358</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a> | <a href="https://leetcode.com/tag/breadth-first-search"><code>breadth-first-search</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><hr><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/">Solution</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>对一个点来说，如果他有左节点和右节点，求最小深度，取两边节点深度小的那一个加一。如果他只有左节点或者右节点，取他左节点或者右节点的深度再加一。如果他没有左右节点，返回 1。</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=111 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [111] 二叉树的最小深度</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (root) &#123;<br>    <span class="hljs-keyword">if</span> (!root.left &amp;&amp; root.right) &#123;<br>      <span class="hljs-keyword">return</span> minDepth(root.right) + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left &amp;&amp; !root.right) &#123;<br>      <span class="hljs-keyword">return</span> minDepth(root.left) + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(minDepth(root.left), minDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">41</span>/<span class="hljs-number">41</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">67</span>.<span class="hljs-number">92</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">64</span>.<span class="hljs-number">71</span> % of javascript submissions (<span class="hljs-number">42</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月5日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%885%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt101.对称二叉树、Lt107.二叉树的层次遍历 II、Lt108.将有序数组转换为二叉搜索树</p><span id="more"></span><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.<a href="https://leetcode-cn.com/problems/symmetric-tree/description/">对称二叉树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (52.90%)</td><td align="center">998</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a> | <a href="https://leetcode.com/tag/breadth-first-search"><code>breadth-first-search</code></a><br><strong>Companies</strong><br><code>bloomberg</code> | <code>linkedin</code> | <code>microsoft</code><br>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你可以运用递归和迭代两种方法解决这个问题吗？</p><hr><p><a href="https://leetcode-cn.com/problems/symmetric-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/symmetric-tree/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和 101.<a href="https://leetcode-cn.com/problems/same-tree/description/">相同的树</a>类似，递归中传的参数分别取左右节点进行判断即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=101 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [101] 对称二叉树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> visit(root.left, root.right);<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">q, p</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> ((p &amp;&amp; !q) || (q &amp;&amp; !p)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> p.val === q.val &amp;&amp; visit(p.left, q.right) &amp;&amp; visit(p.right, q.left);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">195</span>/<span class="hljs-number">195</span> cases passed (<span class="hljs-number">96</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">40</span>.<span class="hljs-number">76</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">05</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">2</span> MB)<br></code></pre></td></tr></table></figure><h1 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107.二叉树的层次遍历 II"></a>107.<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层次遍历 II</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (66.42%)</td><td align="center">296</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/breadth-first-search"><code>breadth-first-search</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其自底向上的层次遍历为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">3</span>]<br>]<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>广度优先遍历。先将根节点放入栈中。创建一个临时栈和临时结果数组，遍历当前栈中的所有节点，如果存在左节点或右节点，将遍历节点的左节点和右节点加入临时栈中，同时将遍历节点的值加入临时结果数组中。遍历结束以后，在结果数组添加到临时结果数组的第一个。将临时栈的内容赋给栈，继续遍历下一层的节点，直到遍历完树。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=107 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [107] 二叉树的层次遍历 II</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br>  <span class="hljs-keyword">let</span> stack = [];<br>  <span class="hljs-keyword">const</span> res = [];<br>  stack.push(root);<br>  <span class="hljs-keyword">while</span> (stack.length) &#123;<br>    <span class="hljs-keyword">let</span> tempStack = [];<br>    <span class="hljs-keyword">let</span> tempRes = [];<br>    <span class="hljs-keyword">while</span> (stack.length) &#123;<br>      <span class="hljs-keyword">let</span> node = stack.shift();<br>      tempRes.push(node.val);<br>      <span class="hljs-keyword">if</span> (node.left) tempStack.push(node.left);<br>      <span class="hljs-keyword">if</span> (node.right) tempStack.push(node.right);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tempRes.length) res.unshift(tempRes);<br>    stack = stack.concat(tempStack);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">34</span>/<span class="hljs-number">34</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">42</span>.<span class="hljs-number">2</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">95</span> % of javascript submissions (<span class="hljs-number">40</span> MB)<br></code></pre></td></tr></table></figure><h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">将有序数组转换为二叉搜索树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (74.07%)</td><td align="center">572</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search"><code>depth-first-search</code></a><br><strong>Companies</strong><br><code>airbnb</code><br>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点  *的左右两个子树的高度差的绝对值不超过 1。<br>*</em>示例:**</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定有序数组: [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9],<br>一个可能的答案是：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>只有有序数组才可使用二分法，重点是点的选取总是左右剩下数组的中点，使用递归反复添加节点即可。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=108 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [108] 将有序数组转换为二叉搜索树</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedArrayToBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">parseInt</span>(nums.length / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>  node.left = sortedArrayToBST(nums.slice(<span class="hljs-number">0</span>, mid));<br>  node.right = sortedArrayToBST(nums.slice(mid + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> node;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">32</span>/<span class="hljs-number">32</span> cases passed (<span class="hljs-number">100</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">34</span>.<span class="hljs-number">03</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">9</span>.<span class="hljs-number">86</span> % of javascript submissions (<span class="hljs-number">43</span>.<span class="hljs-number">2</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>数组</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月6日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%886%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt70.爬楼梯、Lt345.反转字符串中的元音字母、Lt404.左叶子之和</p><span id="more"></span><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.<a href="https://leetcode-cn.com/problems/climbing-stairs/description/">爬楼梯</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (50.49%)</td><td align="center">1218</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/dynamic-programming"><code>dynamic-programming</code></a><br><strong>Companies</strong><br><code>adobe</code> | <code>apple</code><br>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br><strong>注意：</strong>给定 <em>n</em> 是一个正整数。<br><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/climbing-stairs/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/climbing-stairs/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>经典动态规划问题，得出的结果即为斐波那契数列</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>当 n=1 时，只能爬一层，方法 1 种。<br>当 n=2 时，可以爬一层或二层，方法 2 种。<br>当 n=3 时，相当于 F(2)+F(1)<br>所以可以得出当 n 大于 2 时，到达 n 层的方法相当于 n-1（最后一步只能走 1）层的方法加 n-2（最后一步只能走 2）层的爬法。<br>F{<br>1 (n=1),<br>2 (n=2),<br>F(n-1) + F(n-2) (n&gt;2)<br>}<br>但是递归的方法太暴力，肯定超时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=70 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [70] 爬楼梯</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> climbStairs(n - <span class="hljs-number">1</span>) + climbStairs(n - <span class="hljs-number">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>改为动态规划，自底向上进行求解<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659569-9ce70fa0-3aca-4b38-bbda-2a7ce363827e.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659570-07dd99a5-2100-4e78-8668-2a1e72ee821a.webp#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659571-3a1c1e59-ad09-4034-93df-901b6395ff1e.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659572-369eb3f6-c464-4b8a-a5c8-9b0b5be69788.webp#align=left&display=inline&height=119&margin=%5Bobject%20Object%5D&originHeight=119&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659568-78f929dc-3d29-4b06-bc60-9dc4165ba17b.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659581-88b9bc89-2508-41c2-8175-e6346f64a9d7.webp#align=left&display=inline&height=119&margin=%5Bobject%20Object%5D&originHeight=119&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659567-17b829ee-d78f-40a3-98a4-af297190ae69.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659580-1edb5fd4-fe2e-41fb-9c50-e0733be36dbb.webp#align=left&display=inline&height=119&margin=%5Bobject%20Object%5D&originHeight=119&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659572-8ceec6d0-51d1-4930-ae94-74f9c0442e1f.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1639155/1599368659571-7a2bc944-a1cf-40bb-be5b-9d1a9dae8fe2.webp#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=640&size=0&status=done&style=none&width=640"></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=70 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [70] 爬楼梯</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>    temp = a + b;<br>    a = b;<br>    b = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">45</span>/<span class="hljs-number">45</span> cases passed (<span class="hljs-number">64</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">93</span>.<span class="hljs-number">23</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">12</span>.<span class="hljs-number">26</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/">反转字符串中的元音字母</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (50.62%)</td><td align="center">112</td><td align="center">-</td></tr></tbody></table><p><strong>TagsCompanies</strong><br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;hello&quot;</span><br>输出：<span class="hljs-string">&quot;holle&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;leotcede&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>元音字母不包含字母 “y” 。</li></ul><hr><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首尾指针遍历，当 p&gt;q 时结束循环，判断是否是元音，是的话交换首尾指针指向的值即可</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=345 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [345] 反转字符串中的元音字母</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseVowels = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> q = s.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">i</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">u</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">e</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">o</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">I</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">U</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">E</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">O</span>: <span class="hljs-literal">true</span>,<br>  &#125;;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">while</span> (p &lt; q) &#123;<br>    <span class="hljs-keyword">if</span> (obj[s[p]] &amp;&amp; obj[s[q]]) &#123;<br>      <span class="hljs-keyword">let</span> temp = s[p];<br>      s[p] = s[q];<br>      s[q] = temp;<br>      p++;<br>      q--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj[s[p]] &amp;&amp; !obj[s[q]]) &#123;<br>      q--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!obj[s[p]] &amp;&amp; obj[s[q]]) &#123;<br>      p++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      p++;<br>      q--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">481</span>/<span class="hljs-number">481</span> cases passed (<span class="hljs-number">104</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">62</span>.<span class="hljs-number">27</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">16</span>.<span class="hljs-number">38</span> % of javascript submissions (<span class="hljs-number">44</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/">左叶子之和</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (55.54%)</td><td align="center">190</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/tree"><code>tree</code></a><br><strong>Companies</strong><br><code>facebook</code><br>计算给定二叉树的所有左叶子之和。<br><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">3<br>   / \<br> <span class="hljs-number"> 9 </span> 20<br>    /  \<br>  <span class="hljs-number"> 15 </span>  7<br>在这个二叉树中，有两个左叶子，分别是<span class="hljs-number"> 9 </span>和 15，所以返回 24<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>加一个是否为左节点字段，遍历所有节点，如果是左子叶才返回值</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=404 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [404] 左叶子之和</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumOfLeftLeaves = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  sum = visit(root, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;;<br><br><span class="hljs-keyword">const</span> visit = <span class="hljs-function">(<span class="hljs-params">node, isLeft</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (isLeft &amp;&amp; node.val &amp;&amp; !node.left &amp;&amp; !node.right) <span class="hljs-keyword">return</span> node.val;<br>  <span class="hljs-keyword">return</span> visit(node.left, <span class="hljs-literal">true</span>) + visit(node.right, <span class="hljs-literal">false</span>);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">102</span>/<span class="hljs-number">102</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">73</span>.<span class="hljs-number">65</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">15</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月7日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%887%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>Lt455.分发饼干、Lt575.分糖果、Lt628.三个数的最大乘积</p><span id="more"></span><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.<a href="https://leetcode-cn.com/problems/assign-cookies/description/">分发饼干</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (55.51%)</td><td align="center">196</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/greedy"><code>greedy</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值  g 这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s。如果 s &gt;= g，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br><strong>注意：</strong><br>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。<br><strong>示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3], [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释:</span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2], [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释:</span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/assign-cookies/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/assign-cookies/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>贪心算法。将孩子和饼干排序，分别设置两个指针指向第一个。判断两个指针指向的饼干尺寸是否大于等于孩子的胃口，是的话，满足的孩子数量加一，如果小于这块饼干可以直接抛弃。直到两个指针其中一个遍历完数组结束循环，表示饼干没有了或孩子全部满足了。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=455 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [455] 分发饼干</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">g</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">g, s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> childs = g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">const</span> cookies = s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b));<br>  <span class="hljs-keyword">let</span> child = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> cookie = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (child &lt; childs.length &amp;&amp; cookie &lt; cookies.length) &#123;<br>    <span class="hljs-keyword">if</span> (childs[child] &lt;= cookies[cookie]) &#123;<br>      child++;<br>    &#125;<br>    cookie++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> child;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><p>执行结果：<br>通过<br>显示详情<br>执行用时：120 ms, 在所有  JavaScript  提交中击败了 55.10%的用户<br>内存消耗：40.6 MB, 在所有  JavaScript  提交中击败了 11.47%的用户</p><h1 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575.分糖果"></a>575.<a href="https://leetcode-cn.com/problems/distribute-candies/description/">分糖果</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (67.49%)</td><td align="center">82</td><td align="center">-</td></tr></tbody></table><p><strong>TagsCompanies</strong><br>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。<br><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candies = <span class="hljs-comment">[1,1,2,2,3,3]</span><br>输出: 3<br>解析: 一共有三种种类的糖果，每一种都有两个。<br>     最优分配方案：妹妹获得<span class="hljs-comment">[1,2,3]</span>,弟弟也获得<span class="hljs-comment">[1,2,3]</span>。这样使妹妹获得糖果的种类数最多。<br></code></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candies = <span class="hljs-comment">[1,1,2,3]</span><br>输出: 2<br>解析: 妹妹获得糖果<span class="hljs-comment">[2,3]</span>,弟弟获得糖果<span class="hljs-comment">[1,1]</span>，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组的长度为[2, 10,000]，并且确定为偶数。</li><li>数组中数字的大小在范围[-100,000, 100,000]内。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/distribute-candies/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/distribute-candies/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表建立每个糖果及数量，按数量升序生成数组，遍历数组直到结果数组到达糖果总数的一半。每个糖果分类里取一个，就跳到下一个分类，如果没有下一个分类，就在当前分类取到上限。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=575 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [575] 分糖果</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">candies</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> distributeCandies = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">candies</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> candies) &#123;<br>    map.set(item, map.get(item) ? map.get(item) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> sortArr = [...map.entries()].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">while</span> (res.length &lt; candies.length / <span class="hljs-number">2</span>) &#123;<br>    res.push(sortArr[i][<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (sortArr[i + <span class="hljs-number">1</span>]) &#123;<br>      i++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(res)].length;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">205</span>/<span class="hljs-number">205</span> cases passed (<span class="hljs-number">248</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">24</span>.<span class="hljs-number">65</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">10</span> % of javascript submissions (<span class="hljs-number">54</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure><h1 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628.三个数的最大乘积"></a>628.<a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/">三个数的最大乘积</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (50.43%)</td><td align="center">164</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/math"><code>math</code></a><br><strong>Companies</strong><br><code>Unknown</code><br>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。<br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3]</span><br><span class="hljs-section">输出: 6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4]</span><br><span class="hljs-section">输出: 24</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定的整型数组长度范围是[3,10]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出 32 位有符号整数的范围。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将数组降序排序以后。若数组全为正数，则最大为前三个数的乘积。若数组存在负数，最大的乘积要么是前三个数的乘积，要么是两个最小的负数相乘再乘以最大的正数，即最后两个乘第一个</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=628 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [628] 三个数的最大乘积</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximumProduct = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(b) - <span class="hljs-built_in">Number</span>(a));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<br>    nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>] * nums[<span class="hljs-number">2</span>],<br>    nums[<span class="hljs-number">0</span>] * nums[nums.length - <span class="hljs-number">2</span>] * nums[nums.length - <span class="hljs-number">1</span>]<br>  );<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">83</span>/<span class="hljs-number">83</span> cases passed (<span class="hljs-number">160</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">23</span>.<span class="hljs-number">4</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">15</span>.<span class="hljs-number">23</span> % of javascript submissions (<span class="hljs-number">42</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月3日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%883%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.<a href="https://leetcode-cn.com/problems/majority-element/description/">多数元素</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (64.40%)</td><td align="center">723</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/array"><code>array</code></a> | <a href="https://leetcode.com/tag/divide-and-conquer"><code>divide-and-conquer</code></a> | <a href="https://leetcode.com/tag/bit-manipulation"><code>bit-manipulation</code></a><br><strong>Companies</strong><br><code>adobe</code> | <code>zenefits</code><br>给定一个大小为 <em>n <em>的数组，找到其中的多数元素。多数元素是指在数组中出现次数</em></em>大于** <code>⌊ n/2 ⌋</code> 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例  1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,3]</span><br><span class="hljs-section">输出: 3</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1,1,1,2,2]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/majority-element/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/majority-element/solution/">Solution</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1-排序计数"><a href="#1-排序计数" class="headerlink" title="1.排序计数"></a>1.排序计数</h4><p>对数组进行排序，遍历排序后的数组，对相同的元素计数，若大于数组长度的一半则返回元素。<br>实际上直接返回数组的第 1/2 个下标的元素即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> nums.sort()[<span class="hljs-built_in">parseInt</span>(nums.length / <span class="hljs-number">2</span>)];<br></code></pre></td></tr></table></figure><h4 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h4><p>遍历数组加入 map，当计数大于 n/2 时返回。</p><h4 id="3-摩尔投票"><a href="#3-摩尔投票" class="headerlink" title="3.摩尔投票"></a>3.摩尔投票</h4><p>摩尔投票法基于这样一个事实，<strong>当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。</strong><br>算法步骤：<br>1.count = 0； num = nums[0]; 表示从此时开始计算投票。 2.遍历数组，如果接下来出现的数字与 num 相同，count 加 1。如果不同，count 减 1。 3.如果 count == 0，表示之前出现的所有数字中 num 都是可以凑成不同的数对，一起抵消。大于 1/2 n 的数还会在后面出现。 4.如果 count &lt; 0，表示之前 num 中的数字没有到一半，所以此时完全不用考虑前面存储的元素，“删除”他们。直接从现在的新的元素开始计数，并令 count = 0。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="1-排序计数-1"><a href="#1-排序计数-1" class="headerlink" title="1.排序计数"></a>1.排序计数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=169 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [169] 多数元素</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-comment">//let numSort = nums.sort();</span><br>  <span class="hljs-comment">//let count = 0;</span><br>  <span class="hljs-comment">//for (let i = 0; i &lt; numSort.length; i++) &#123;</span><br>  <span class="hljs-comment">//  count++;</span><br>  <span class="hljs-comment">//  if(count&gt;numSort.length/2) return numSort[i]</span><br>  <span class="hljs-comment">//  if(numSort[i]!==numSort[i+1])&#123;</span><br>  <span class="hljs-comment">//    count=0;</span><br>  <span class="hljs-comment">//  &#125;</span><br>  <span class="hljs-comment">//&#125;</span><br>  <span class="hljs-keyword">return</span> nums.sort()[<span class="hljs-built_in">parseInt</span>(nums.length / <span class="hljs-number">2</span>)];<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">46</span>/<span class="hljs-number">46</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">46</span>.<span class="hljs-number">89</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">9</span> % of javascript submissions (<span class="hljs-number">41</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h4 id="2-map-1"><a href="#2-map-1" class="headerlink" title="2.map"></a>2.map</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=169 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [169] 多数元素</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>    map.set(num, map.has(num) ? map.get(num) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (map.get(num) &gt; nums.length / <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span> num;<br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">46</span>/<span class="hljs-number">46</span> cases passed (<span class="hljs-number">100</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">26</span>.<span class="hljs-number">29</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">37</span>.<span class="hljs-number">3</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">2</span> MB)<br></code></pre></td></tr></table></figure><h4 id="3-摩尔投票-1"><a href="#3-摩尔投票-1" class="headerlink" title="3.摩尔投票"></a>3.摩尔投票</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=169 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [169] 多数元素</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> num = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] != num) &#123;<br>      count--;<br>      <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>        count = <span class="hljs-number">0</span>;<br>        num = nums[i];<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> count++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">46</span>/<span class="hljs-number">46</span> cases passed (<span class="hljs-number">72</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">96</span>.<span class="hljs-number">22</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">72</span>.<span class="hljs-number">81</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">6</span> MB)<br></code></pre></td></tr></table></figure><h1 id="168-Excel-表列名称"><a href="#168-Excel-表列名称" class="headerlink" title="168.Excel 表列名称"></a>168.<a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">Excel 表列名称</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (38.25%)</td><td align="center">261</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/math"><code>math</code></a><br><strong>Companies</strong><br><code>facebook</code> | <code>microsoft</code> | <code>zenefits</code><br>给定一个正整数，返回它在 Excel 表中相对应的列名称。<br>例如，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1</span> -&gt; A<br>    <span class="hljs-number">2</span> -&gt; B<br>    <span class="hljs-number">3</span> -&gt; C<br>    ...<br>    <span class="hljs-number">26</span> -&gt; Z<br>    <span class="hljs-number">27</span> -&gt; AA<br>    <span class="hljs-number">28</span> -&gt; AB<br>    ...<br></code></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 1</span><br><span class="hljs-section">输出: &quot;A&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 28</span><br><span class="hljs-section">输出: &quot;AB&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例  3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 701</span><br><span class="hljs-section">输出: &quot;ZY&quot;</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/solution/">Solution</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="类-26-进制"><a href="#类-26-进制" class="headerlink" title="类 26 进制"></a>类 26 进制</h4><p>类似 26 进制，但是没有 0。使用对象存储对应数字的值。判断是否取余为 0，是的话使 n–，再取对象里的 key 为 26 的值。</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=168 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [168] Excel表列名称</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> convertToTitle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;A&quot;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&quot;B&quot;</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-string">&quot;C&quot;</span>,<br>    <span class="hljs-number">4</span>: <span class="hljs-string">&quot;D&quot;</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-string">&quot;E&quot;</span>,<br>    <span class="hljs-number">6</span>: <span class="hljs-string">&quot;F&quot;</span>,<br>    <span class="hljs-number">7</span>: <span class="hljs-string">&quot;G&quot;</span>,<br>    <span class="hljs-number">8</span>: <span class="hljs-string">&quot;H&quot;</span>,<br>    <span class="hljs-number">9</span>: <span class="hljs-string">&quot;I&quot;</span>,<br>    <span class="hljs-number">10</span>: <span class="hljs-string">&quot;J&quot;</span>,<br>    <span class="hljs-number">11</span>: <span class="hljs-string">&quot;K&quot;</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-string">&quot;L&quot;</span>,<br>    <span class="hljs-number">13</span>: <span class="hljs-string">&quot;M&quot;</span>,<br>    <span class="hljs-number">14</span>: <span class="hljs-string">&quot;N&quot;</span>,<br>    <span class="hljs-number">15</span>: <span class="hljs-string">&quot;O&quot;</span>,<br>    <span class="hljs-number">16</span>: <span class="hljs-string">&quot;P&quot;</span>,<br>    <span class="hljs-number">17</span>: <span class="hljs-string">&quot;Q&quot;</span>,<br>    <span class="hljs-number">18</span>: <span class="hljs-string">&quot;R&quot;</span>,<br>    <span class="hljs-number">19</span>: <span class="hljs-string">&quot;S&quot;</span>,<br>    <span class="hljs-number">20</span>: <span class="hljs-string">&quot;T&quot;</span>,<br>    <span class="hljs-number">21</span>: <span class="hljs-string">&quot;U&quot;</span>,<br>    <span class="hljs-number">22</span>: <span class="hljs-string">&quot;V&quot;</span>,<br>    <span class="hljs-number">23</span>: <span class="hljs-string">&quot;W&quot;</span>,<br>    <span class="hljs-number">24</span>: <span class="hljs-string">&quot;X&quot;</span>,<br>    <span class="hljs-number">25</span>: <span class="hljs-string">&quot;Y&quot;</span>,<br>    <span class="hljs-number">26</span>: <span class="hljs-string">&quot;Z&quot;</span>,<br>  &#125;;<br>  <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">26</span> === <span class="hljs-number">0</span>) &#123;<br>      n--;<br>      res = obj[<span class="hljs-number">26</span>] + res;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res = obj[n % <span class="hljs-number">26</span>] + res;<br>    &#125;<br>    n = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">26</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">18</span>/<span class="hljs-number">18</span> cases passed (<span class="hljs-number">88</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">16</span>.<span class="hljs-number">89</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">5</span>.<span class="hljs-number">44</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171.Excel 表列序号"></a>171.<a href="https://leetcode-cn.com/problems/excel-sheet-column-number/description/">Excel 表列序号</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (67.99%)</td><td align="center">171</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/math"><code>math</code></a><br><strong>Companies</strong><br>给定一个 Excel 表格中的列名称，返回其相应的列序号。<br>例如，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">A -&gt; <span class="hljs-number">1</span><br>    B -&gt; <span class="hljs-number">2</span><br>    C -&gt; <span class="hljs-number">3</span><br>    ...<br>    Z -&gt; <span class="hljs-number">26</span><br>    AA -&gt; <span class="hljs-number">27</span><br>    AB -&gt; <span class="hljs-number">28</span><br>    ...<br></code></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;A&quot;</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;AB&quot;</span><br><span class="hljs-section">输出: 28</span><br></code></pre></td></tr></table></figure><p><strong>示例  3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;ZY&quot;</span><br><span class="hljs-section">输出: 701</span><br></code></pre></td></tr></table></figure><p><strong>致谢：</strong><br>特别感谢 <a href="http://leetcode.com/discuss/user/ts">@ts</a> 添加此问题并创建所有测试用例。</p><hr><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/excel-sheet-column-number/solution/">Solution</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="类-26-进制-1"><a href="#类-26-进制-1" class="headerlink" title="类 26 进制"></a>类 26 进制</h4><p>类似 26 进制，转数组，对每一位进行求值相加，指数刚好是数组出队以后的长度。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=171 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [171] Excel表列序号</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> titleToNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sArr = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">A</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">B</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">E</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">F</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">G</span>: <span class="hljs-number">7</span>,<br>    <span class="hljs-attr">H</span>: <span class="hljs-number">8</span>,<br>    <span class="hljs-attr">I</span>: <span class="hljs-number">9</span>,<br>    <span class="hljs-attr">J</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">K</span>: <span class="hljs-number">11</span>,<br>    <span class="hljs-attr">L</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">M</span>: <span class="hljs-number">13</span>,<br>    <span class="hljs-attr">N</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">O</span>: <span class="hljs-number">15</span>,<br>    <span class="hljs-attr">P</span>: <span class="hljs-number">16</span>,<br>    <span class="hljs-attr">Q</span>: <span class="hljs-number">17</span>,<br>    <span class="hljs-attr">R</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">S</span>: <span class="hljs-number">19</span>,<br>    <span class="hljs-attr">T</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">U</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">V</span>: <span class="hljs-number">22</span>,<br>    <span class="hljs-attr">W</span>: <span class="hljs-number">23</span>,<br>    <span class="hljs-attr">X</span>: <span class="hljs-number">24</span>,<br>    <span class="hljs-attr">Y</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-attr">Z</span>: <span class="hljs-number">26</span>,<br>  &#125;;<br>  <span class="hljs-keyword">while</span> (sArr.length &gt; <span class="hljs-number">0</span>) &#123;<br>    count += obj[sArr.shift()] * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">26</span>, sArr.length);<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">1000</span>/<span class="hljs-number">1000</span> cases passed (<span class="hljs-number">96</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">70</span>.<span class="hljs-number">06</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">9</span>.<span class="hljs-number">65</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure><h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/">删除链表中的节点</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (82.74%)</td><td align="center">745</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/linked-list"><code>linked-list</code></a><br><strong>Companies</strong><br><code>adobe</code> | <code>apple</code> | <code>microsoft</code><br>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1599116007216-d4a40747-3898-4874-a21f-fd8404d648d4.png#align=left&display=inline&height=49&margin=%5Bobject%20Object%5D&originHeight=65&originWidth=395&size=0&status=done&style=none&width=300"></p><p><strong>示例 1：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 5</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]<br>解释：给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 1</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>解释：给定你链表中值为 <span class="hljs-number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">9</span>.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><hr><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/">Solution</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="阅读游戏"><a href="#阅读游戏" class="headerlink" title="阅读游戏"></a>阅读游戏</h4><p>题目的意思是删除输入的节点。使当前节点等于下一个节点的 val 和 next 即可。</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=237 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [237] 删除链表中的节点</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">node</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify node in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;<br>  node.val = node.next.val;<br>  node.next = node.next.next;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">41</span>/<span class="hljs-number">41</span> cases passed (<span class="hljs-number">84</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">72</span>.<span class="hljs-number">29</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">14</span>.<span class="hljs-number">59</span> % of javascript submissions (<span class="hljs-number">39</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure><h1 id="551-学生出勤记录-I"><a href="#551-学生出勤记录-I" class="headerlink" title="551.学生出勤记录 I"></a>551.<a href="https://leetcode-cn.com/problems/student-attendance-record-i/description/">学生出勤记录 I</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (51.69%)</td><td align="center">49</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/string"><code>string</code></a><br><strong>Companies</strong><br><code>google</code><br>给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</p><ol><li><strong>‘A’</strong> : Absent，缺勤</li><li><strong>‘L’</strong> : Late，迟到</li><li><strong>‘P’</strong> : Present，到场</li></ol><p>如果一个学生的出勤记录中不<strong>超过一个’A’(缺勤)**并且</strong>不超过两个连续的’L’(迟到)<strong>,那么这个学生会被奖赏。<br>你需要根据这个学生的出勤记录判断他是否会被奖赏。<br>**示例 1:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;PPALLP&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;PPALLL&quot;</span><br>输出: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/student-attendance-record-i/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/student-attendance-record-i/solution/">Solution</a></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p><code>/^(?!.*LLL)(?!.*(A).*\1)/</code><br>解析：<br>._(A).<em>\1 表示允许 A 重复 例如 cAbA<br>?! 表示断言不包含，不占用字符串长度<br>(?!.</em>(A)._\1) 表示断言不允许 A 重复</p><p>.*LLL 表示以 LLL 结尾 ABCLLL<br>(?!.*LLL)表示不以 LLL 结尾</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1599118955403-850cd2c9-5a82-4bde-aab8-96c99d7f94ad.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=106&originWidth=798&size=16235&status=done&style=none&width=798" alt="image.png"></p><h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><p>indexOf LLL，存在则返 false。计数 A，如果大于 1 则返 false</p><h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><h4 id="正则-1"><a href="#正则-1" class="headerlink" title="正则"></a>正则</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=551 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [551] 学生出勤记录 I</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkRecord = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/(?!.*(A).*\1)^(?!.*LLL)/</span>.test(s);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">113</span>/<span class="hljs-number">113</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">53</span>.<span class="hljs-number">02</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">25</span> % of javascript submissions (<span class="hljs-number">37</span>.<span class="hljs-number">9</span> MB)<br></code></pre></td></tr></table></figure><h4 id="遍历字符串-1"><a href="#遍历字符串-1" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=551 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [551] 学生出勤记录 I</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkRecord = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (s.indexOf(<span class="hljs-string">&quot;LLL&quot;</span>) !== -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arr <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (arr === <span class="hljs-string">&quot;A&quot;</span>) count++;<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">113</span>/<span class="hljs-number">113</span> cases passed (<span class="hljs-number">80</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">53</span>.<span class="hljs-number">02</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">13</span>.<span class="hljs-number">09</span> % of javascript submissions (<span class="hljs-number">38</span>.<span class="hljs-number">1</span> MB)<br></code></pre></td></tr></table></figure><h1 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541.反转字符串 II"></a>541.<a href="https://leetcode-cn.com/problems/reverse-string-ii/description/">反转字符串 II</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Easy (55.04%)</td><td align="center">89</td><td align="center">-</td></tr></tbody></table><p><strong>Tags</strong><br><a href="https://leetcode.com/tag/string"><code>string</code></a><br><strong>Companies</strong><br><code>google</code><br>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，你需要对从字符串开头算起的每隔 <code>2k</code> 个字符的前 <code>k</code> 个字符进行反转。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出: <span class="hljs-string">&quot;bacdfeg&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>该字符串只包含小写英文字母。</li><li>给定字符串的长度和 <code>k</code> 在 <code>[1, 10000]</code> 范围内。</li></ol><hr><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/comments/">Discussion</a> | <a href="https://leetcode-cn.com/problems/reverse-string-ii/solution/">Solution</a></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>字符串分割为数组，遍历，步长为 2k。将前 k 个数组删除，并反转后再插入，将数组转回字符串。</p><h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=541 lang=javascript</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [541] 反转字符串 II</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseStr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, k</span>) </span>&#123;<br>  s = s.split(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i = i + <span class="hljs-number">2</span> * k) &#123;<br>    <span class="hljs-keyword">const</span> reverseArr = s.slice(i, i + k).reverse();<br>    s.splice(i, k, ...reverseArr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accepted</span><br><span class="hljs-attribute">60</span>/<span class="hljs-number">60</span> cases passed (<span class="hljs-number">92</span> ms)<br><span class="hljs-attribute">Your</span> runtime beats <span class="hljs-number">38</span>.<span class="hljs-number">27</span> % of javascript submissions<br><span class="hljs-attribute">Your</span> memory usage beats <span class="hljs-number">28</span>.<span class="hljs-number">95</span> % of javascript submissions (<span class="hljs-number">40</span>.<span class="hljs-number">8</span> MB)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>「每日LeetCode」2020年9月19日</title>
    <link href="/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8819%E6%97%A5/"/>
    <url>/2020/09/19/yuque/%E3%80%8C%E6%AF%8F%E6%97%A5LeetCode%E3%80%8D2020%E5%B9%B49%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先、剑指 Offer 52. 两个链表的第一个公共节点、剑指 Offer 55 - II. 平衡二叉树、剑指 Offer 28. 对称的二叉树</p><span id="more"></span><h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600507370632-52a46caa-398a-4819-8773-d5f03287e4f4.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=200&size=0&status=done&style=none&width=200"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><p>注意：本题与主站 235 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>结合二叉搜索树的特点，当当前节点值都比 p、q 要大的时候，说明公共节点在左边，返回左子树，都要小的时候说明公共节点在右边，返回右子树。当值在两个之间时，就为公共祖先。<br>吐槽一下力扣，这题不能使用 js 写，ts 返回结构限制为 TreeNode，期望得到的答案却是 number :)。所以贴一下主站 235 的答案。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>  <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)<br>    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共节点。<br>如下面的两个链表<strong>：</strong><br><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600508828223-ab39794a-a15c-4df7-8b04-4ee5690d9eed.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=742&size=0&status=done&style=none&width=400"></a><br>在节点 c1 开始相交。</p><p><strong>示例 1：</strong><br><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600508828245-403a0d26-9a12-4bdd-9571-78891cbeb6f1.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=742&size=0&status=done&style=none&width=400"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">3</span><br>输出：Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例  2：</strong><br><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600508828243-53519327-8bb1-4bd1-812c-741bbd1b5f33.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=622&size=0&status=done&style=none&width=350"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">1</span><br>输出：Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">2</span><br>输入解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例  3：</strong><br><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/1639155/1600508828225-e1726e1e-46f0-4dab-9264-f95d06492e35.png#align=left&display=inline&height=126&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=382&size=0&status=done&style=none&width=200"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li><strong>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存</strong>。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力双重循环"><a href="#暴力双重循环" class="headerlink" title="暴力双重循环"></a>暴力双重循环</h4><p>很容易可以得到一种解法，双重遍历比较 a、b 每个节点的 next 是否相等，相等即可直接返回</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>若没有限制空间复杂度为 O(1)，可以使用 hash 表进行判断，则满足 O(n)的时间复杂度要求</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>设交集链表长 c,链表 1 除交集的长度为 a，链表 2 除交集的长度为 b，有</p><ul><li><strong>a + c + b = b + c + a</strong></li><li>若无交集，则 a + b = b + a</li></ul><p>所以当 tmpA 或 tmpB 为空时，将他们设置为另一条链的头结点，再走不是交集的那个长度，最后一定会在交点处遇上</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><h4 id="暴力双重循环-1"><a href="#暴力双重循环-1" class="headerlink" title="暴力双重循环"></a>暴力双重循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">headA, headB</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tmpA = headA;<br>  <span class="hljs-keyword">let</span> tmpB = headB;<br>  <span class="hljs-keyword">while</span> (tmpA &amp;&amp; tmpB) &#123;<br>    <span class="hljs-keyword">let</span> tmp = tmpB;<br>    <span class="hljs-keyword">while</span> (tmp) &#123;<br>      <span class="hljs-keyword">if</span> (tmpA === tmp) <span class="hljs-keyword">return</span> tmpA;<br>      tmp = tmp.next;<br>    &#125;<br>    tmpA = tmpA.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">headA, headB</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">while</span> (headA) &#123;<br>    map.set(headA, <span class="hljs-literal">true</span>);<br>    headA = headA.next;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (headB) &#123;<br>    <span class="hljs-keyword">if</span> (map.get(headB)) <span class="hljs-keyword">return</span> headB;<br>    headB = headB.next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headA</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">headB</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">headA, headB</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tmpA = headA,<br>    tmpB = headB;<br>  <span class="hljs-keyword">while</span> (tmpA != tmpB) &#123;<br>    tmpA = tmpA ? tmpA.next : headA;<br>    tmpB = tmpB ? tmpB.next : headB;<br>  &#125;<br>  <span class="hljs-keyword">return</span> tmpA;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。<br> <strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉树 [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">4</span>   <span class="hljs-number">4</span><br>返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= 树的结点个数 &lt;= 10000</code></li></ul><p>注意：本题与主站 110  题相同：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>本题结合了求树的最大深度，对每一个节点返回其左右子树的最大深度，判断他们的绝对值是否大于 1，大于即返回 false。再递归计算树里的每一个节点是否都符合这个规则即可。</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-built_in">Math</span>.abs(getDeep(root.left) - getDeep(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp;<br>    isBalanced(root.left) &amp;&amp;<br>    isBalanced(root.right)<br>  );<br>&#125;;<br><br><span class="hljs-keyword">const</span> getDeep = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">1</span> + getDeep(root.left), <span class="hljs-number">1</span> + getDeep(root.right));<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p>难度简单 83 收藏分享切换为英文关注反馈<br>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br>例如，二叉树  [1,2,2,3,4,4,3] 是对称的。<br><code> 1 / \ 2 2 / \ / \ 3 4 4 3</code><br>但是下面这个  [1,2,2,null,3,null,3] 则不是镜像对称的:<br><code> 1 / \ 2 2 \ \ 3 3</code><br> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 1000</code><br>注意：本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>写一个判断是否相等的函数。传入树 1 和树 2，如果两个都为空则返回 true 结束递归，如果有一个为空或者两个节点的值不相等则不满足情况返回 false。传入两个节点的值应该相等，同时他们的左右节点应该互相相等才符合对称。不断递归计算即可。</p><h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> isSame(root, root);<br>&#125;;<br><br><span class="hljs-keyword">const</span> isSame = <span class="hljs-function">(<span class="hljs-params">tree1, tree2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!tree1 &amp;&amp; !tree2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> ((!tree1 &amp;&amp; tree2) || (tree1 &amp;&amp; !tree2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (tree1.val === tree2.val)<br>    <span class="hljs-keyword">return</span> isSame(tree1.left, tree2.right) &amp;&amp; isSame(tree1.right, tree2.left);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>哈希表</tag>
      
      <tag>dfs</tag>
      
      <tag>递归</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
